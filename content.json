{"meta":{"title":"DK'S BLOG","subtitle":null,"description":"dk's blog, record for FE article.","author":"hbxywdk","url":"http://yoursite.com","root":"/"},"pages":[{"title":"ABOUT","date":"2019-04-15T10:04:26.000Z","updated":"2019-06-26T07:51:50.004Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"vConsole分析2-VConsoleDefaultPlugin","slug":"vConsole2","date":"2020-03-19T06:44:44.000Z","updated":"2020-03-20T07:45:07.326Z","comments":true,"path":"2020/03/19/vConsole2/","link":"","permalink":"http://yoursite.com/2020/03/19/vConsole2/","excerpt":"","text":"插件VConsole 的 _addBuiltInPlugins 方法中有这五个内置插件：VConsoleDefaultPlugin、VConsoleSystemPlugin、VConsoleNetworkPlugin、VConsoleElementPlugin、VConsoleStoragePlugin，分别对应 vConsole 五大功能区：Log、System、NetWork、Element 和 Storage。 VConsoleDefaultPlugin 和 VConsoleSystemTab 都继承了 VConsoleLogTab，VConsoleLogTab 则继承了 VConsolePlugin；VConsoleNetworkPlugin、VConsoleElementPlugin、VConsoleStoragePlugin 继承了 VConsolePlugin。 VConsolePlugin类五个内置插件最终都继承了 VConsolePlugin 所以先从它看起。VConsolePlugin 主要用于获取\\设置 _id、_name、_vConsole，与注册事件与触发事件12345678910111213141516171819202122232425262728293031323334353637383940414243class VConsolePlugin &#123; constructor(id, name = &apos;newPlugin&apos;) &#123; this.id = id; this.name = name; this.isReady = false; this.eventList = &#123;&#125;; &#125; // 省略code... /** * 注册事件 * @public * @param string * @param function */ on(eventName, callback) &#123; this.eventList[eventName] = callback; return this; &#125; /** * 触发事件 * @public * @param string * @param mixed */ trigger(eventName, data) &#123; if (typeof this.eventList[eventName] === &apos;function&apos;) &#123; // registered by `.on()` method this.eventList[eventName].call(this, data); &#125; else &#123; // registered by `.onXxx()` method let method = &apos;on&apos; + eventName.charAt(0).toUpperCase() + eventName.slice(1); if (typeof this[method] === &apos;function&apos;) &#123; this[method].call(this, data); &#125; &#125; return this; &#125;&#125; VConsoleLogTab类VConsoleLogTab 是基础 log tab 类，VConsoleDefaultPlugin 和 VConsoleSystemTab 都会继承它。 12345678910111213141516171819202122232425class VConsoleLogTab extends VConsolePlugin &#123; static AddedLogID = []; constructor(...args) &#123; super(...args); ADDED_LOG_TAB_ID.push(this.id); this.tplTabbox = &apos;&apos;; // tplTabbox 在子类中必须被重写 this.allowUnformattedLog = true; // `[xxx]` format log this.isReady = false; this.isShow = false; this.$tabbox = null; this.console = &#123;&#125;; this.logList = []; // vConsole 如果还未准备好，先把log保存在 logList 中 this.isInBottom = true; // 面板是否在底部 this.maxLogNumber = DEFAULT_MAX_LOG_NUMBER; // 最大Log展示数量 this.logNumber = 0; this.mockConsole(); &#125; // code...&#125; this.mockConsole()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mockConsole() &#123; const that = this; const methodList = [&apos;log&apos;, &apos;info&apos;, &apos;warn&apos;, &apos;debug&apos;, &apos;error&apos;]; // 将 window.console 的主要方法赋值给 this.console if (!window.console) &#123; window.console = &#123;&#125;; &#125; else &#123; methodList.map(function (method) &#123; that.console[method] = window.console[method]; &#125;); that.console.time = window.console.time; that.console.timeEnd = window.console.timeEnd; that.console.clear = window.console.clear; &#125; // 重写 console 的 &apos;log&apos;, &apos;info&apos;, &apos;warn&apos;, &apos;debug&apos;, &apos;error&apos; 五个方法，改为调用 this.printLog methodList.map(method =&gt; &#123; window.console[method] = (...args) =&gt; &#123; this.printLog(&#123; logType: method, logs: args, &#125;); &#125;; &#125;); // 重写 console.time 与 console.timeEnd 方法 const timeLog = &#123;&#125; window.console.time = function (label) &#123; timeLog[label] = Date.now(); &#125;; window.console.timeEnd = function (label) &#123; var pre = timeLog[label]; if (pre) &#123; console.log(label + &apos;:&apos;, (Date.now() - pre) + &apos;ms&apos;); delete timeLog[label]; &#125; else &#123; console.log(label + &apos;: 0ms&apos;); &#125; &#125;; // 重写 console.clear 方法，调用 this.clearLog 方法，再调用存在 this.console 中的 [native code] window.console.clear = (...args) =&gt; &#123; that.clearLog(); that.console.clear.apply(window.console, args); &#125;;&#125; this.printLog()向 Log Box 输出 Log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 向log box 输出一条 log * @protected * @param string _id 随机唯一ID * @param string tabName default|system * @param string logType log|info|debug|error|warn * @param array logs `logs` or `content` 不能为空 * @param object content `logs` or `content` 不能为空 * @param boolean noOrigin * @param int date * @param string style */printLog(item) &#123; let logs = item.logs || []; if (!logs.length &amp;&amp; !item.content) &#123; return; &#125; // 复制 log 为一个新数组如：[111, 222, 333] logs = [].slice.call(logs || []); // check `[default]` format 检查默认格式 let shouldBeHere = true; let pattern = /^\\[(\\w+)\\]$/i; let targetTabID = &apos;&apos;; let isInAddedTab = false; if (tool.isString(logs[0])) &#123; let match = logs[0].match(pattern); if (match !== null &amp;&amp; match.length &gt; 0) &#123; targetTabID = match[1].toLowerCase(); isInAddedTab = ADDED_LOG_TAB_ID.indexOf(targetTabID) &gt; -1; &#125; &#125; if (targetTabID === this.id) &#123; // 目标 tab 是否是当前展示的 tab shouldBeHere = true; &#125; else if (isInAddedTab === true) &#123; // target tab is not current tab, but in added tab list // so throw this log to other tab shouldBeHere = false; &#125; else &#123; // 目标 tab 不在已添加的 tab list 中 if (this.id === &apos;default&apos;) &#123; // 在默认 tab 中展示此条 log shouldBeHere = true; &#125; else &#123; shouldBeHere = false; &#125; &#125; if (!shouldBeHere) &#123; // 忽略此条 log 并将其扔到原始控制台中 if (!item.noOrigin) &#123; this.printOriginLog(item); &#125; return; &#125; // 添加 id if (!item._id) &#123; item._id = &apos;__vc_&apos; + Math.random().toString(36).substring(2, 8); &#125; // 存储 log 的日期 if (!item.date) &#123; item.date = (+new Date()); &#125; // vConsole 如果还未准备好，先把log保存在 this.logList 中，等 vConsole 准备好了再统一输出 if (!this.isReady) &#123; this.logList.push(item); return; &#125; // remove `[xxx]` format if (tool.isString(logs[0]) &amp;&amp; isInAddedTab) &#123; logs[0] = logs[0].replace(pattern, &apos;&apos;); if (logs[0] === &apos;&apos;) &#123; logs.shift(); &#125; &#125; // make for previous log const curLog = &#123; // 当前这条日志 _id: item._id, logType: item.logType, logText: [], hasContent: !!item.content, count: 1, &#125;; for (let i = 0; i &lt; logs.length; i++) &#123; if (tool.isFunction(logs[i])) &#123; curLog.logText.push(logs[i].toString()); &#125; else if (tool.isObject(logs[i]) || tool.isArray(logs[i])) &#123; curLog.logText.push(tool.JSONStringify(logs[i])); &#125; else &#123; curLog.logText.push(logs[i]); &#125; &#125; curLog.logText = curLog.logText.join(&apos; &apos;); // check repeat 重复检测 if (!curLog.hasContent &amp;&amp; preLog.logType === curLog.logType &amp;&amp; preLog.logText === curLog.logText) &#123; // 处理多次连续的输出同一条log，则只展示一条log，并在该条log前展示输出次数的计数 // 效果和在原始log窗口执行这段代码一样：for(let i = 0; i &lt; 100; i++)&#123;console.log(1)&#125; this.printRepeatLog(); &#125; else &#123; // 向DOM中插入新log this.printNewLog(item, logs); // save previous log 保存上一条 log preLog = curLog; // 把当前 Log &#125; // 滚动到底部（如果之前已经在底部） if (this.isInBottom &amp;&amp; this.isShow) &#123; this.autoScrollToBottom(); &#125; // 把 log 输出到原始控制台 if (!item.noOrigin) &#123; this.printOriginLog(item); &#125;&#125; this.printNewLog() 向DOM中插入新logthis.printLog，会调用 this.printNewLog 方法向DOM中插入新log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 向DOM中插入新log * @protected */printNewLog(item, logs) &#123; // create line let $line = $.render(tplItem, &#123; _id: item._id, logType: item.logType, style: item.style || &apos;&apos; &#125;); let $content = $.one(&apos;.vc-item-content&apos;, $line); // 从item.logs生成内容 for (let i = 0; i &lt; logs.length; i++) &#123; let log; try &#123; if (logs[i] === &apos;&apos;) &#123; // 如果log是空字符串则忽略掉 continue; &#125; else if (tool.isFunction(logs[i])) &#123; // 把函数转换为字符串 log = &apos;&lt;span&gt; &apos; + logs[i].toString() + &apos;&lt;/span&gt;&apos;; &#125; else if (tool.isObject(logs[i]) || tool.isArray(logs[i])) &#123; // object or array log = this.getFoldedLine(logs[i]); &#125; else &#123; // default log = &apos;&lt;span&gt; &apos; + tool.htmlEncode(logs[i]).replace(/\\n/g, &apos;&lt;br/&gt;&apos;) + &apos;&lt;/span&gt;&apos;; &#125; &#125; catch (e) &#123; log = &apos;&lt;span&gt; [&apos; + (typeof logs[i]) + &apos;]&lt;/span&gt;&apos;; &#125; if (log) &#123; if (typeof log === &apos;string&apos;) $content.insertAdjacentHTML(&apos;beforeend&apos;, log); else $content.insertAdjacentElement(&apos;beforeend&apos;, log); &#125; &#125; // 从item.content生成内容 if (tool.isObject(item.content)) &#123; $content.insertAdjacentElement(&apos;beforeend&apos;, item.content); &#125; // 将Log渲染到面板，.vc-log就是log的输出面板 $.one(&apos;.vc-log&apos;, this.$tabbox).insertAdjacentElement(&apos;beforeend&apos;, $line); // 删除超出最大上限的日志 this.logNumber++; // 累加 logNumber this.limitMaxLogs(); // 如果超出了最大Log展示数量则把多余的Log删除&#125; VConsoleDefaultTab类然后是 VConsoleDefaultTab 类只有3个方法：onReady、mockConsole 和 evalCommand。12345678910111213141516171819202122232425262728293031323334353637class VConsoleDefaultTab extends VConsoleLogTab &#123; constructor(...args) &#123; super(...args); this.tplTabbox = tplTabbox; &#125; onReady() &#123; // code... // 给 command 输入框绑定 keyup 事件 $.bind($.one(&apos;.vc-cmd-input&apos;), &apos;keyup&apos;, function (e) &#123; // code... &#125;); // 提交命令事件 $.bind($.one(&apos;.vc-cmd&apos;, this.$tabbox), &apos;submit&apos;, function (e) &#123; // code... &#125;); // code... &#125; // 使用 vConsole 的方法替换了 window.console &amp; window.onerror。 mockConsole() &#123; // code... &#125; // 执行command输入框中的命令 evalCommand(cmd) &#123; // code... &#125;&#125; mockConsole 方法使用 vConsole 的方法替换了 window.console &amp; window.onerror。 evalCommand 方法会使用 eval 来执行字符串命令。 onReady 方法会给 command输入框绑定 keyup 事件并处理命令补全相关事项。还会处理命令提交事件，调用 evalCommand 来执行命令。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"vConsole分析1","slug":"vConsole1","date":"2019-10-30T10:05:33.000Z","updated":"2020-03-19T07:06:41.671Z","comments":true,"path":"2019/10/30/vConsole1/","link":"","permalink":"http://yoursite.com/2019/10/30/vConsole1/","excerpt":"","text":"简介vConsole 是一个轻量化的移动网页前端控制台面板，它在真机上实现 PC 网页控制台的主要功能，大大简化了 H5 页面的调试过程，它的使用也非常简单，以 CDN 引入为例：1234&lt;script src=&quot;https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vConsole = new VConsole();&lt;/script&gt; 只需在 html 中引入 vConsole 脚本，并实例化一个 vConsole 即可使用，它的基本功能已足够满足一般的开发调试。 入口文件从入口文件开始看起123456789101112vconsole.js// globalimport &apos;./lib/symbol.js&apos;;// classesimport VConsole from &apos;./core/core.js&apos;;import VConsolePlugin from &apos;./lib/plugin.js&apos;;// exportVConsole.VConsolePlugin = VConsolePlugin;export default VConsole; 引入 VConsole、VConsolePlugin，并将 VConsole.VConsolePlugin 赋值为 VConsolePlugin，最后导出 VConsole。 VConsole 构造函数接下来看 core/core.js，它定义了 VConsole 类并将其导出。从构造函数看起（去除了一些不重要的代码）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class VConsole &#123; constructor(opt) &#123; // ... let that = this; this.$dom = null; // vConsole 的 HTML element this.option = &#123; // 配置项 defaultPlugins: [&apos;system&apos;, &apos;network&apos;, &apos;element&apos;, &apos;storage&apos;] &#125;; this.activedTab = &apos;&apos;; // 当前激活的 tab 的 plugin id this.tabList = []; // 已安装的 tab 的 plugin id 列表。 this.pluginList = &#123;&#125;; // 插件列表 this.switchPos = &#123; // 定位 // ... &#125;; this.tool = tool; // 辅助函数 this.$ = $; // DOM 选择器 // code 省略（合并参数，常规使用一般都不会传参） // 添加内置插件 this._addBuiltInPlugins(); // 初始化 let _onload = function() &#123; if (that.isInited) &#123; return; &#125; that._render(); // 渲染面板 DOM that._mockTap(); // 通过 touchstart &amp; touchend 来模拟点击事件 that._bindEvent(); // 绑定 DOM 事件 that._autoRun(); // 初始化完成后自动运行 &#125;; // 对 document 状态的处理，当 document 加载完成时再去调用 _onload if (document !== undefined) &#123; if (document.readyState == &apos;complete&apos;) &#123; _onload(); &#125; else &#123; $.bind(window, &apos;load&apos;, _onload); &#125; &#125; else &#123; // if document does not exist, wait for it let _timer; let _pollingDocument = function() &#123; if (!!document &amp;&amp; document.readyState == &apos;complete&apos;) &#123; _timer &amp;&amp; clearTimeout(_timer); _onload(); &#125; else &#123; _timer = setTimeout(_pollingDocument, 1); &#125; &#125;; _timer = setTimeout(_pollingDocument, 1); &#125; &#125; 主要看后半部分：调用 this._addBuiltInPlugins(); 添加内部插件，接下来定义了一个 _onload 函数，当 document 加载完成后会去调用该函数。 _addBuiltInPlugins1234567891011121314151617181920212223_addBuiltInPlugins() &#123; // 添加默认的 log 插件 this.addPlugin(new VConsoleDefaultPlugin(&apos;default&apos;, &apos;Log&apos;)); // add other built-in plugins according to user&apos;s config const list = this.option.defaultPlugins; const plugins = &#123; &apos;system&apos;: &#123;proto: VConsoleSystemPlugin, name: &apos;System&apos;&#125;, &apos;network&apos;: &#123;proto: VConsoleNetworkPlugin, name: &apos;Network&apos;&#125;, &apos;element&apos;: &#123;proto: VConsoleElementPlugin, name: &apos;Element&apos;&#125;, &apos;storage&apos;: &#123;proto: VConsoleStoragePlugin, name: &apos;Storage&apos;&#125; &#125;; if (!!list &amp;&amp; tool.isArray(list)) &#123; for (let i=0; i&lt;list.length; i++) &#123; let tab = plugins[list[i]]; if (!!tab) &#123; this.addPlugin(new tab.proto(list[i], tab.name)); &#125; else &#123; console.debug(&apos;Unrecognized default plugin ID:&apos;, list[i]); &#125; &#125; &#125;&#125; _addBuiltInPlugins 方法中调用了 this.addPlugin 先添加了必须的 log 插件，之后根据配置一次添加了 System、Network、Element、Storage 插件。几部分的插件对应的 VConsoleDefaultPlugin、VConsoleSystemPlugin...... 等等，接着是 this.addPlugin() 方法： 123456789101112131415161718addPlugin(plugin) &#123; // 重复安装插件则将其忽略 if (this.pluginList[plugin.id] !== undefined) &#123; console.debug(&apos;Plugin &apos; + plugin.id + &apos; has already been added.&apos;); return false; &#125; this.pluginList[plugin.id] = plugin; // 将插件添加到 this.pluginList 中 // 仅在 vConsole 准备就绪时初始化插件 if (this.isInited) &#123; this._initPlugin(plugin); // 如果是第一个插件则会默认显示 if (this.tabList.length == 1) &#123; this.showTab(this.tabList[0]); &#125; &#125; return true;&#125; 接下来是 this._initPlugin() 初始化插件，_initPlugin中分别触发插件的init、renderTab、addTopBar、addTool、ready事件，init会调用插件的onInit方法（如果有）；renderTab用于渲染tab栏目（最顶部的tab栏） 的内容；addTopBar用于给顶部的按钮区添加内容；addTool用于给最底部的按钮区添加内容； renderTab、addTopBar、addTool三个有回调函数，用于给对应的区域添加按钮。1234567891011121314151617181920212223242526_initPlugin(plugin) &#123; let that = this; plugin.vConsole = this; // 把vConsole挂到插件上 // 触发插件的 init 事件 plugin.trigger(&apos;init&apos;); // 渲染tab（如果是一个tab插件，则应有标签相关的事件） plugin.trigger(&apos;renderTab&apos;, function(tabboxHTML) &#123; // code... &#125;); // 渲染 top bar（顶部的按钮） plugin.trigger(&apos;addTopBar&apos;, function(btnList) &#123; // code... &#125;); // 渲染 tool bar（底部的按钮） plugin.trigger(&apos;addTool&apos;, function(btnList) &#123; // code... &#125;); // 结束初始化，标记插件的isReady为true plugin.isReady = true; // 触发插件的ready事件 plugin.trigger(&apos;ready&apos;);&#125;","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Vuex源码分析3","slug":"Vuex源码分析3","date":"2019-09-16T10:54:34.000Z","updated":"2019-09-16T08:38:08.330Z","comments":true,"path":"2019/09/16/Vuex源码分析3/","link":"","permalink":"http://yoursite.com/2019/09/16/Vuex源码分析3/","excerpt":"","text":"上篇写到 Store 构造函数中的 installModule 与 resetStoreVM 方法，这篇继续。 installModuleinstallModule 会处理开启 namespaced 的情况。所有模块的 action、mutation、getter 都会被分别挂载到 Store._actions、Store._mutations、Store._wrappedGetters 上如果没有开启 namespaced，以 getter 为例会被处理成这样：12345// Store._wrappedGetters&#123; &apos;getterName1&apos;: function wrappedGetter() &#123; // code... &#125;, &apos;getterName2&apos;: function wrappedGetter() &#123; // code... &#125;&#125; 如果开启了 namespaced，会被处理成这样：12345// Store._wrappedGetters&#123; &apos;moduleName/getterName1&apos;: function wrappedGetter() &#123; // code... &#125;, &apos;moduleName/getterName2&apos;: function wrappedGetter() &#123; // code... &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function installModule (store, rootState, path, module, hot) &#123; // 是否是 root const isRoot = !path.length // 根据 path 入参获取 namespace 如：&apos;/moduleA&apos; const namespace = store._modules.getNamespace(path) // register in namespace map if (module.namespaced) &#123; if (store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] duplicate namespace $&#123;namespace&#125; for the namespaced module $&#123;path.join(&apos;/&apos;)&#125;`) &#125; // 如果开启命名空间，就将当前 module 添加到 store._modulesNamespaceMap 中 store._modulesNamespaceMap[namespace] = module &#125; // 非根结点 &amp; 非 热修改 if (!isRoot &amp;&amp; !hot) &#123; // 获取父亲的 state const parentState = getNestedState(rootState, path.slice(0, -1)) // 当前模块名 const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; // 使用 Vue.set https://cn.vuejs.org/v2/api/#Vue-set 将当前模块设置为响应式的 Vue.set(parentState, moduleName, module.state) &#125;) &#125; // 本地化dispatch，commit，getters，state，如果没有名称空间，只需使用root const local = module.context = makeLocalContext(store, namespace, path) // 遍历注册当前 module 的 mutation module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) // 遍历注册当前 module 的 action module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) // 遍历注册当前 module 的 getter module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) // 遍历调用 installModule，安装子模块 module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125; resetStoreVM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function resetStoreVM (store, state, hot) &#123; // 旧 vm const oldVm = store._vm // bind store public getters 绑定 store 的 public getters store.getters = &#123;&#125; const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // fn 为 当前遍历 getter 值，key 为名 // use computed to leverage its lazy-caching mechanism 使用computed来利用其惰性缓存机制 // direct inline function use will lead to closure preserving oldVm. 直接内联函数使用将导致关闭保留oldVm。 // using partial to return function with only arguments preserved in closure enviroment. 使用partial返回函数，只在闭包环境中保留参数。 computed[key] = partial(fn, store) // 使用 Object.defineProperty 为每个 getter 定义 get 方法， // 当使用 getter 访问时实际返回的是 store._vm 下的同名值 Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) &#125;) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins // 使用一个 Vue 实例来存储 state 树 const silent = Vue.config.silent Vue.config.silent = true // 暂时取消 Vue 的日志与警告 // 设置 store._vm 为 Vue 实例 store._vm = new Vue(&#123; data: &#123; $$state: state // state 为 root.state &#125;, computed &#125;) Vue.config.silent = silent // 实例化完成后设置回原值 // enable strict mode for new vm if (store.strict) &#123; enableStrictMode(store) &#125; if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; // 销毁旧 Vue 实例 Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; 先遍历所有定义了的 getter ，然后使用 Object.defineProperty 将 getter 的值都转到了 store._vm 上，等于说访问 store.getter.xxx 等同于访问 store._vm.xxx。1234Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters&#125;) 之后以 root.state 为 data 实例化一个 Vue 实例，以 Vue 的响应式能力来实现 Vuex 的功能。1234567// 设置 store._vm 为 Vue 实例store._vm = new Vue(&#123; data: &#123; $$state: state // state 为 root.state &#125;, computed&#125;) Vuex 设置了 store.state 的 get 函数，当使用 store.state.xxx 时实际返回的是 store._vm._data.$$state 中的数据。123456789101112// 获取 store.vm 的数据get state () &#123; return this._vm._data.$$state&#125;// 设置 state（不允许直接修改 state）set state (v) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; // 只可使用 store.replaceState() 替换存储状态，不允许直接设置 assert(false, `use store.replaceState() to explicit replace store state.`) &#125;&#125; 接下来看其他部分： Store.commit 方法1234567891011121314151617181920212223242526272829303132333435363738// 提交 mutation https://vuex.vuejs.org/zh/api/#commit （注意：mutation为同步事物）commit (_type, _payload, _options) &#123; // check object-style commit const &#123; type, // 类型 payload, // 数据 options &#125; = unifyObjectStyle(_type, _payload, _options) // 统一不同风格的入参 const mutation = &#123; type, payload &#125; const entry = this._mutations[type] // 对应类型的 mutations // 找不到对应类型的 mutation 则返回 if (!entry) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; // 传入数据（载荷/payload）执行每一个 mutation this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) // 执行所有订阅了该 mutation 的回调 https://vuex.vuejs.org/zh/api/#subscribe this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + &apos;Use the filter functionality in the vue-devtools&apos; ) &#125;&#125; mutation 执行后，会执行所有订阅了该 mutation 的回调，订阅相关 API： https://vuex.vuejs.org/zh/api/#subscribe Store.dispatch 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 分发 action https://vuex.vuejs.org/zh/api/#dispatch（action 内可异步）dispatch (_type, _payload) &#123; // check object-style dispatch const &#123; type, // 类型 payload // 数据 &#125; = unifyObjectStyle(_type, _payload) // 统一不同风格的入参 const action = &#123; type, payload &#125; const entry = this._actions[type] // 对应类型的 actions // 找不到对应类型的 action 则返回 if (!entry) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`) &#125; return &#125; // action 执行前，调用 subscribeAction.before 回调 try &#123; this._actionSubscribers .filter(sub =&gt; sub.before) .forEach(sub =&gt; sub.before(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.warn(`[vuex] error in before action subscribers: `) console.error(e) &#125; &#125; // 执行 action const result = entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) // action 执行后，调用 subscribeAction.after 回调（Promise 的 then 内执行） return result.then(res =&gt; &#123; try &#123; this._actionSubscribers .filter(sub =&gt; sub.after) .forEach(sub =&gt; sub.after(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.warn(`[vuex] error in after action subscribers: `) console.error(e) &#125; &#125; return res &#125;)&#125; action 的执行同样也有订阅回调，与 mutation 不同的是 action 的订阅有两个 一个 before，一个 after 分别在 执行前、执行后调用。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用Canvas压缩Jpg图片丢失Exif信息问题","slug":"canvas压缩jpg丢失exif","date":"2019-08-16T10:54:34.000Z","updated":"2019-08-19T09:16:48.726Z","comments":true,"path":"2019/08/16/canvas压缩jpg丢失exif/","link":"","permalink":"http://yoursite.com/2019/08/16/canvas压缩jpg丢失exif/","excerpt":"","text":"遇到的问题最近开发遇到一个问题，后台想要在用户上传的图片中获取到 Exif 信息，APP 确认 Exif 信息有传，最后排查到 Exif 丢失的原因是 H5 对 APP 传回的照片进行了压缩。H5 使用的压缩库是 lrz，将 H5 压缩关闭后，后台就可以获取到 Exif 信息了。 APP 传给 H5 的图片内容是 base64 化的 jpg 图，前端压缩后，传压缩后的 base64 图片给后台。 APP 传给 H5 的图片比较大，本着节省用户流量与缩短上传时间的考虑，必须在前端压缩再传给后台。 问题产生的原因查看 lrz 的源码，发现它是使用 canvas 将原图绘制到其上，再将 canvas 的内容转为 base64 格式的图片。 我又看了其他一款纯前端图片压缩库后，发现它俩都是使用 canvas 来进行图片压缩（貌似纯前端图片压缩方法基本就canvas），使用 canvas 压缩图片虽然可以达到大比例压缩的目的，但是最后从 canvas 中导出的图片必然会将原图中保存的 Exif 等信息内容一并丢掉。 Base64Base64 出现的原因有些网络传输方式并不支持所有的字节，例如传统的邮件只支持可见字符的传输，像ASCII码的控制字符就不能传输。图片二进制流的每个字节不可能全部是可见字符，所以也不能传输。那么就需要在不改变传统协议的情况下，做一种扩展来支持二进制文件传输，这就是 Base64 出现的原因，它可将不可打印的字符用可打印字符来表示，以实现传输的目的。Base64 从名称就可以看出，它是一种基于64个可打印字符来表示二进制数据的方法。 Base64 原理 Base64只有64个字符，6的bit即可表示64个字符(2的6次方为64)，正常的字符是使用8bit表示。我们看下面这张图：Hello! 这个字符串的二进制值如第三行所示，正常字符使用 8bit 表示，转换 base64 则使用 6bit 表示，以 6个一截断，再对照 base64 索引表可以很容易的得出其 base64 编码结果为 SGVsbG8h。Tips: 转换后长度/转换前长度 为 4:3。 如果原始字符串长度不能被3整除，就需要用0来补充，如下图： Hello!! Base64编码的结果为 SGVsbG8hIQAA，由于补充的两个AA不应该携带信息，这里以AA表示会造成数据错误，所以会以 =替换补位的AA，故最终的结果为 SGVsbG8hIQ==。 这里只是简单讲一下 Base64，更多详情可看这篇文章：https://www.cnblogs.com/peterYong/p/10959964.html 什么是 Exif？可交换图像文件格式 Exif（Exchangeable image file format），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据，它储存在相机设备拍摄的图片的二进制文件中。Exif信息以0xFFE1作为开头标记，后两个字节表示Exif信息的长度。所以Exif信息最大为64 kb，而内部采用TIFF格式。 JPEG文件的内容都以二进制值 0xFFD8（Start of image 简称 SOI）开始, 以二进制值0xFFD9（End of image 简称 EOI）结束。 在JPEG的数据 中有好几种类似于二进制 0xFFXX 的数据, 它们都统称作 “标记”, 并且它们代表了一段JPEG的 信息数据。 SOI 与 EOI 两个特殊的标记的后不跟数据, 而其他的标记会在其后附带数据。 标记的基本结构：10xFF+标记号(1个字节)+数据大小描述符(2个字节)+数据内容(n个字节) 标记的种类又很多种，0xFFE0~0xFFEF之间的标记被叫做 应用标记，存放 Exif 信息的标记以 APP1(0xFFE1) 开头， 问题的解决方案方案一原压缩图片不变，通过 Exif.js 获取到原图 Exif 信息后通过接口传给后台，这种方案没什么意思，接着看方案二。 方案二保存原图 Exif 信息，待图片压缩完成后，将原图 Exif 信息拼接到压缩图上。 由于传输的图片都是 base64 格式，这里提供一个网址可以查看 base64 图片的 exif 信息：http://code.ciaoca.com/javascript/exif-js/demo/base64 在方案一中，我提到了 Exif.js，不过遗憾的是它提供的只有读 Exif 信息的方法，没有写 Exif 信息的方法，所以想要实现 Exif 信息拼接就得手撸了，不过好在我找到了一篇相关文章：http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#more，里面的代码已经实现了这个功能，所以我准备直接修改 lrz 源码，使其可以额外输出一个带有 Exif 信息的 base64 压缩图。 拼接 Exif 的核心代码： 压缩原始 base64 图片：123456789101112// 原始 base64 图片，由于太长，这里省略展示let orignBase64 = &apos;data:image/jpeg;base64,/9j/4QIMRXhpZgAATU0AKgAAAAgACQEAAAQAA 省略......&apos;；;let minBase64 = null; // 压缩图let exif = null; // 存 Exif 信息// 压缩使用的是 lrz 可自行在 github 上搜索lrz(orignBase64, &#123; width: 800&#125;).then(function (rst) &#123; minBase64 = rst.base64;&#125;).catch(function (err) &#123;&#125;) 取得 Exif 信息：1234567891011121314151617181920// 工具函数 将 base64 转 ArrayBufferfunction base64ToArrayBuffer(base64, contentType) &#123; contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || &apos;&apos;; // e.g. &apos;data:image/jpeg;base64,...&apos; =&gt; &apos;image/jpeg&apos; base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, &apos;&apos;); // btoa是binary to ascii，将binary的数据用ascii码表示，即Base64的编码过程 // atob则是ascii to binary，用于将ascii码解析成binary数据 var binary = atob(base64); // console.log(binary) var len = binary.length; var buffer = new ArrayBuffer(len); var view = new Uint8Array(buffer); for (var i = 0; i &lt; len; i++) &#123; view[i] = binary.charCodeAt(i); &#125; return buffer;&#125;// 将原始 base64 转换为 arrayBufferlet orignBuffer = base64ToArrayBuffer(orignBase64);// 调用 getSegments 获取 0xFFE0~0xFFEF 开头的应用标记片段getSegments(orignBuffer); 这里给出标记的大致结构，下面的代码会用到：标记开头 | 标记类型 | 标记大小 | 标记内容 | - | - | -0xff | 标记类型(1字节) | 数据大小(2字节) | 数据内容(n字节) 关于标记类型，可以在 Exif.js 的源码中找到，比如图片宽度 ImageWidth 对应的标记是 0x0100。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 获取 0xFFE0~0xFFEF 开头的应用标记片段function getSegments(arrayBuffer) &#123; var head = 0, segments = []; var length, endPoint, seg; var arr = [].slice.call(new Uint8Array(arrayBuffer), 0); while (true) &#123; // SOS(Start of Scan, 由 0xff 0xda 开头) // 遍历到 SOS 表示已经遍历完所有标记，再往下就是图像数据流了，直接 break if (arr[head] === 0xff &amp;&amp; arr[head + 1] === 0xda) &#123; break;&#125; // SOI(Start of Image)是 JPG 文件的开头内容，由 0xff 0xd8 开头 if (arr[head] === 0xff &amp;&amp; arr[head + 1] === 0xd8) &#123; head += 2; &#125; // 找出每个标记片段 else &#123; // 每个标记开头后跟着的两个字节记录了该标记所记录内容的长度 length = arr[head + 2] * 256 + arr[head + 3]; // 内容长度 endPoint = head + length + 2; // 内容结束位置 // 从0xff开头，到标记数据内容结束全部截出来 seg = arr.slice(head, endPoint); head = endPoint; // push整个标记信息 segments.push(seg); &#125; if (head &gt; arr.length) &#123; break; &#125; &#125; // console.warn(&apos;分割片段&apos;, segments); getEXIF(segments)&#125;// 从标记片段筛选 &amp; 取出 exif 信息function getEXIF(segments) &#123; if (!segments.length) &#123; return []; &#125; var seg = []; for (var x = 0; x &lt; segments.length; x++) &#123; var s = segments[x]; // 0xff 0xe1开头的才是 exif数据(即app1) if (s[0] === 0xff &amp;&amp; s[1] === 0xe1) &#123; // app1 exif 0xff 0xe1 seg = seg.concat(s); &#125; &#125; exif = seg;&#125; 拼接 Exif 到压缩后的 base64 中：1234567891011121314151617// 插入 Exif 信息function insertEXIF(resizedImg, exifArr) &#123; var arr = [].slice.call(new Uint8Array(resizedImg), 0); //不是标准的JPEG文件 if (arr[2] !== 0xff || arr[3] !== 0xe0) &#123; return resizedImg; &#125; var app0_length = arr[4] * 256 + arr[5]; //两个字节 // 拼接文件 SOI + EXIF + 去除APP0的图像信息 var newImg = [0xff, 0xd8].concat(exifArr, arr.slice(4 + app0_length)); return new Uint8Array(newImg);&#125;let minBuffer = base64ToArrayBuffer(minBase64);let newImg = insertEXIF(minBuffer, exif);console.log(&apos;最终输出图片&apos;, newImg) 把新生成的图片复制到 http://code.ciaoca.com/javascript/exif-js/demo/base64 可以看到 Exif 信息已经成功添加。 二进制数组上面有很多二进制文件操作，这里简单补充一些相关知识。 二进制数组产生的原因二进制数组产生的原因与WebGL项目有关，为的满足 JavaScript 与显卡之间大量的、实时的数据交换，这些通信的数据都得是二进制的。 ArrayBuffer 对象ArrayBuffer 是内存中的一段二进制数据，无法直接操作，可使用 视图（TypedArray、DataView）提供的数组方法，操作内存，其作用是以指定格式解读二进制数据。 TypedArray 对象用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图。123456789Int8Array：8位有符号整数，长度1个字节。Uint8Array：8位无符号整数，长度1个字节。Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。Int16Array：16位有符号整数，长度2个字节。Uint16Array：16位无符号整数，长度2个字节。Int32Array：32位有符号整数，长度4个字节。Uint32Array：32位无符号整数，长度4个字节。Float32Array：32位浮点数，长度4个字节。Float64Array：64位浮点数，长度8个字节。 TypedArray 指定数据格式读取整个 ArrayBuffer。 DataView 对象用来生成内存的视图，可以自定义格式和字节序，同样支持9种数据类型，相较于 TypedArray 更加灵活，比如可以以不同的格式读取同一个 ArrayBuffer 上不同位置的数据。 BlobBlob(binary large object)，二进制文件大对象，是存储二进制文件的“容器”。Blob构造函数接受两个参数，第一个参数是一个包含实际数据的数组，第二个参数是数据的MIME类型。1new Blob([data], &#123;type: &quot;application/octet-binary&quot;&#125;) 与 ArrayBuffer 的区别： 它俩都能存二进制数据，但 Blob 储存量更大。 Blob 可以设置数据的 MIME 类型。 ArrayBuffer 表示原始的二进制数据，需要通过视图进行操作。 Blob对象表示一个不可变、原始数据的类文件对象。 参考 https://www.cnblogs.com/peterYong/p/10959964.htmlhttps://blog.csdn.net/yyjsword/article/details/28876739http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#morehttp://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc2https://www.jianshu.com/p/54d878aa0237","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Vuex源码分析2","slug":"Vuex源码分析2","date":"2019-08-01T10:54:33.000Z","updated":"2019-09-16T05:57:57.026Z","comments":true,"path":"2019/08/01/Vuex源码分析2/","link":"","permalink":"http://yoursite.com/2019/08/01/Vuex源码分析2/","excerpt":"","text":"接下来就是实例化一个 Vuex.Store：12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) StoreStore的代码位于 src/store.js 中，先看 Store 的构造函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859constructor (options = &#123;&#125;) &#123; // code... 省略 const &#123; plugins = [], // 传入的插件配置 https://vuex.vuejs.org/zh/guide/plugins.html strict = false // 是否开启严格模式 https://vuex.vuejs.org/zh/guide/strict.html &#125; = options /* 初始化内部状态 */ this._committing = false // actions this._actions = Object.create(null) // 存放 actions 的订阅者 this._actionSubscribers = [] // mutations this._mutations = Object.create(null) // getters this._wrappedGetters = Object.create(null) // 模块收集 this._modules = new ModuleCollection(options) // 模块命名空间 Map this._modulesNamespaceMap = Object.create(null) // 存放订阅者 this._subscribers = [] // 用以实现 Vuex.Store.watch 方法的Vue实例 this._watcherVM = new Vue() // 绑定 commit 与 dispacth 的指向 const store = this const &#123; dispatch, commit &#125; = this this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; // 严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。https://vuex.vuejs.org/zh/api/#strict this.strict = strict // 根 state const state = this._modules.root.state // 初始化根模块，同时递归注册所有子模块，并收集所有模块的 getters 存放到 this._wrappedGetters 中 installModule(this, state, [], this._modules.root) // 初始化 store 的 vm，负责反应，同时将 _wrappedGetters 注册为计算属性） resetStoreVM(this, state) // plugins 应用插件 plugins.forEach(plugin =&gt; plugin(this)) // devtool 插件相关 const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools if (useDevtools) &#123; devtoolPlugin(this) &#125;&#125; 构造函数中主要是一些内部值的初始化与一些初始化方法的执行，我们按照构造函数的执行顺序由上到下分析。 ModuleCollection首先是这一句：this._modules = new ModuleCollection(options)，这里实例化了 ModuleCollection，用于模块收集，并处理成 Vuex 所需的数据结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export default class ModuleCollection &#123; constructor (rawRootModule) &#123; // 使用 Vuex.Store 的 options 注册根模块 this.register([], rawRootModule, false) &#125; get (path) &#123; return path.reduce((module, key) =&gt; &#123; return module.getChild(key) // 获取名为入参 key 的子模块 &#125;, this.root) &#125; getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + &apos;/&apos; : &apos;&apos;) &#125;, &apos;&apos;) &#125; // 更新 update (rawRootModule) &#123; update([], this.root, rawRootModule) &#125; // 注册 register (path, rawModule, runtime = true) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assertRawModule(path, rawModule) &#125; const newModule = new Module(rawModule, runtime) if (path.length === 0) &#123; this.root = newModule &#125; else &#123; const parent = this.get(path.slice(0, -1)) // 调用 Module 的 addChild 添加子模块 parent.addChild(path[path.length - 1], newModule) &#125; if (rawModule.modules) &#123; forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; this.register(path.concat(key), rawChildModule, runtime) &#125;) &#125; &#125; unregister (path) &#123; const parent = this.get(path.slice(0, -1)) const key = path[path.length - 1] if (!parent.getChild(key).runtime) return parent.removeChild(key) &#125;&#125; ModuleCollection 的构造函数中从根开始调用 this.register([], rawRootModule, false) 1234567891011121314151617181920212223242526272829// 注册register (path, rawModule, runtime = true) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assertRawModule(path, rawModule) &#125; // Module 是 Store 的基础数据结构！ const newModule = new Module(rawModule, runtime) // path = [] if (path.length === 0) &#123; // 首次注册，将 this.root 设置为 newModule this.root = newModule // 子模块走这里（path = [&apos;modulesName&apos;]） &#125; else &#123; // 获取给 路径数组的最后一个元素，也就是当前 module 的 父亲 parent 添加 child const parent = this.get(path.slice(0, -1)) // 调用 Module 的 addChild 添加子模块 parent.addChild(path[path.length - 1], newModule) &#125; // 如果用户有使用嵌套模块（modules），则遍历所有模块，为每个模块都执行 this.register 注册。 if (rawModule.modules) &#123; forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; // args：路径数组、对应module、是否是运行时 this.register(path.concat(key), rawChildModule, runtime) &#125;) &#125;&#125; 从根开始调用 register 会实例化一个 Module 对象 new Module(rawModule, runtime) 并将其赋值给 this.root。这里的 Module 对象 (src/module/module.js) 是 Store 的基础数据结构，如果使用了 module 功能，则会递归注册所有子module。register 方法的第一个参数是路径数组，举几个例子： 如果未使用 module，则 path 为[]，代码不会走到这里，一次注册就结束了 如果有一级 module，则 path 为[‘modulesName’] 如果有两级 module，则 path 为[‘modulesName’, grandsonModulesName] 依次类推 。。。。。。 对于使用了 modules 子模块的则会调用 父 Module 的 addChild 方法添加到 父 Module 的 _children 中，最终构造出以 Module 为基础结构的树状结构。 ModuleModule 是 Store 的基础数据结构，代码不多，这里直接带注释全部贴出来：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Store 的基础数据结构，包含一些属性与方法export default class Module &#123; constructor (rawModule, runtime) &#123; this.runtime = runtime // 储存一些子模块 this._children = Object.create(null) // 储存 rawModule this._rawModule = rawModule // 取出 rawModule 的 state const rawState = rawModule.state // 如果 rawState 是函数则执行，赋值 this.state 为函数返回值，否则赋值为 rawState 或 &#123;&#125; this.state = (typeof rawState === &apos;function&apos; ? rawState() : rawState) || &#123;&#125; &#125; // 获取是否开启了 namespaced get namespaced () &#123; return !!this._rawModule.namespaced &#125; // 添加子模块 addChild (key, module) &#123; this._children[key] = module &#125; // 移除子模块 removeChild (key) &#123; delete this._children[key] &#125; // 获取子模块 getChild (key) &#123; return this._children[key] &#125; // 更新方法，用传入的 rawModule 的 namespaced、actions、mutations、getters替换原有的 update (rawModule) &#123; // 更新 namespaced this._rawModule.namespaced = rawModule.namespaced // 更新 actions if (rawModule.actions) &#123; this._rawModule.actions = rawModule.actions &#125; // 更新 mutations if (rawModule.mutations) &#123; this._rawModule.mutations = rawModule.mutations &#125; // 更新 getters if (rawModule.getters) &#123; this._rawModule.getters = rawModule.getters &#125; &#125; // 取出 this._children 的每个子项，以其为参数传入 fn 执行 forEachChild (fn) &#123; forEachValue(this._children, fn) &#125; // 取出 Getter 的每个子项，以其为参数传入 fn 执行 forEachGetter (fn) &#123; if (this._rawModule.getters) &#123; forEachValue(this._rawModule.getters, fn) &#125; &#125; // 取出 Action 的每个子项，以其为参数传入 fn 执行 forEachAction (fn) &#123; if (this._rawModule.actions) &#123; forEachValue(this._rawModule.actions, fn) &#125; &#125; // 取出 Mutation 的每个子项，以其为参数传入 fn 执行 forEachMutation (fn) &#123; if (this._rawModule.mutations) &#123; forEachValue(this._rawModule.mutations, fn) &#125; &#125;&#125; 继续看构造函数赋值 this._watcherVM 为一个 Vue 实例，用以实现 Vuex.Store.watch 方法。1this._watcherVM = new Vue() watch 方法：1234567// Doc：https://vuex.vuejs.org/zh/api/#watchwatch (getter, cb, options) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(typeof getter === &apos;function&apos;, `store.watch only accepts a function.`) &#125; return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options)&#125; 绑定 commit 与 dispacth 的指向12345678const store = thisconst &#123; dispatch, commit &#125; = thisthis.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload)&#125;this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options)&#125; 调用 installModule 与 resetStoreVM 方法12345678// 根 stateconst state = this._modules.root.state// 初始化根模块，同时递归注册所有子模块，并收集所有模块的 getters 存放到 this._wrappedGetters 中 installModule(this, state, [], this._modules.root)// 以当前的 state 重置数据，同时将 _wrappedGetters 注册为计算属性resetStoreVM(this, state) 插件相关12345678// plugins 应用插件plugins.forEach(plugin =&gt; plugin(this))// devtool 插件相关const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtoolsif (useDevtools) &#123; devtoolPlugin(this)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Vuex源码分析1","slug":"Vuex源码分析1","date":"2019-07-26T10:54:33.000Z","updated":"2019-08-01T03:35:11.208Z","comments":true,"path":"2019/07/26/Vuex源码分析1/","link":"","permalink":"http://yoursite.com/2019/07/26/Vuex源码分析1/","excerpt":"","text":"Vuex 版本 3.1.1 目录结构123456789101112131415-- src -- module // 模块 -- module-collection.js -- module.js -- plugins // 插件 -- devtool.js // 开发工具插件 -- logger.js // 日志插件 -- helpers.js // 辅助函数 -- index.esm.js -- index.js // 入口文件 -- mixin.js -- store.js // Vuex.Sotre -- util.js // 工具函数 Vuex 基本用法照例，先放基本用法：1234567891011121314151617Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;)new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App), store,&#125;) 入口文件可以看到主要是导出了 Store 等相关内容。1234567891011121314import &#123; Store, install &#125; from &apos;./store&apos;import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;// 入口文件，导出 Store 等相关内容export default &#123; Store, // Store install, // install 方法 version: &apos;__VERSION__&apos;, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers&#125; install 方法Vue.use(Vuex) 会调用 Vuex 的 install 方法，它位于 src/store.js:123456789101112131415// 对外暴露 install 函数export function install (_Vue) &#123; // 二次 install 的警告 if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; console.error( &apos;[vuex] already installed. Vue.use(Vuex) should be called only once.&apos; ) &#125; return &#125; Vue = _Vue // 将变量 Vue 赋值为 install 方法传入的 Vue // 调用 applyMixin 开始混入 applyMixin(Vue)&#125; install 函数对二次 install 做了处理，并将 store.js 中名为 Vue 的变量赋值为 install 方法传入的 Vue，最后调用 applyMixin() 方法混入代码到 Vue。 applyMixin 方法applyMixin() 方法位于 src/mixin.js： 1234567891011121314151617181920212223242526272829303132333435export default function (Vue) &#123; const version = Number(Vue.version.split(&apos;.&apos;)[0]) // 版本兼容，2.x 版本使用 Vue.mixin 混入到 beforeCreate 中 if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;) // 版本兼容，1.x 版本 &#125; else &#123; // Vue.prototype._init 中注入 vuex init过程，适用于 1.x 版本向后兼容。 const _init = Vue.prototype._init Vue.prototype._init = function (options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) &#125; &#125; /** * Vuex init hook, injected into each instances init hooks list. */ function vuexInit () &#123; const options = this.$options // 传入的配置项 // store injection // 将实例化后的 store 挂载到 Vue.$store 上，这里的 store 是我们实例化后的 Store 并作为参数传给了 Vue if (options.store) &#123; this.$store = typeof options.store === &apos;function&apos; ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store &#125; &#125;&#125; applyMixin 比较清晰明了，首先是对 Vue 进行了版本兼容。2.x 版本使用 Vue.mixin 混入到 beforeCreate 中；1.x 版本则是在 Vue.prototype._init 中注入 vuex init过程。vuexInit() 函数则会将实例化后的 store 挂载到 Vue.$store 上。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Vue-router源码分析4","slug":"Vue-router源码分析4","date":"2019-07-26T08:24:33.000Z","updated":"2019-07-26T08:24:08.206Z","comments":true,"path":"2019/07/26/Vue-router源码分析4/","link":"","permalink":"http://yoursite.com/2019/07/26/Vue-router源码分析4/","excerpt":"","text":"VueRouter 构造函数中的 this.matcher123456789101112131415161718192021222324export default class VueRouter &#123; static install: () =&gt; void; static version: string; app: any; // Vue 实例 apps: Array&lt;any&gt;; ready: boolean; readyCbs: Array&lt;Function&gt;; options: RouterOptions; mode: string; // 路由使用的模式 history: HashHistory | HTML5History | AbstractHistory; matcher: Matcher; fallback: boolean; beforeHooks: Array&lt;?NavigationGuard&gt;; resolveHooks: Array&lt;?NavigationGuard&gt;; afterHooks: Array&lt;?AfterNavigationHook&gt;; constructor (options: RouterOptions = &#123;&#125;) &#123; // code... // 生成路由匹配 this.matcher = createMatcher(options.routes || [], this) // code... &#125; 构造函数中的 this.matcher = createMatcher(options.routes || [], this) 会根据用户传入的路由信息构造出路由匹配，VueRouter 的路由对象就是由它内部生成的。 createMatcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159export function createMatcher ( routes: Array&lt;RouteConfig&gt;, // 配置的路由信息 router: VueRouter // Vue-Router 实例): Matcher &#123; // 创建 route map，然后返回 pathList, pathMap, nameMap 供下次 addRoutes 使用 const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes) // 添加路由 function addRoutes (routes) &#123; createRouteMap(routes, pathList, pathMap, nameMap) &#125; // 返回对应路由信息 function match ( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route &#123; const location = normalizeLocation(raw, currentRoute, false, router) const &#123; name &#125; = location if (name) &#123; const record = nameMap[name] if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn(record, `Route with name &apos;$&#123;name&#125;&apos; does not exist`) &#125; if (!record) return _createRoute(null, location) const paramNames = record.regex.keys .filter(key =&gt; !key.optional) .map(key =&gt; key.name) if (typeof location.params !== &apos;object&apos;) &#123; location.params = &#123;&#125; &#125; if (currentRoute &amp;&amp; typeof currentRoute.params === &apos;object&apos;) &#123; for (const key in currentRoute.params) &#123; if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123; location.params[key] = currentRoute.params[key] &#125; &#125; &#125; location.path = fillParams(record.path, location.params, `named route &quot;$&#123;name&#125;&quot;`) return _createRoute(record, location, redirectedFrom) &#125; else if (location.path) &#123; location.params = &#123;&#125; for (let i = 0; i &lt; pathList.length; i++) &#123; const path = pathList[i] const record = pathMap[path] if (matchRoute(record.regex, location.path, location.params)) &#123; return _createRoute(record, location, redirectedFrom) &#125; &#125; &#125; // no match return _createRoute(null, location) &#125; function redirect ( record: RouteRecord, location: Location ): Route &#123; const originalRedirect = record.redirect let redirect = typeof originalRedirect === &apos;function&apos; ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect if (typeof redirect === &apos;string&apos;) &#123; redirect = &#123; path: redirect &#125; &#125; if (!redirect || typeof redirect !== &apos;object&apos;) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn( false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;` ) &#125; return _createRoute(null, location) &#125; const re: Object = redirect const &#123; name, path &#125; = re let &#123; query, hash, params &#125; = location query = re.hasOwnProperty(&apos;query&apos;) ? re.query : query hash = re.hasOwnProperty(&apos;hash&apos;) ? re.hash : hash params = re.hasOwnProperty(&apos;params&apos;) ? re.params : params if (name) &#123; // resolved named direct const targetRecord = nameMap[name] if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(targetRecord, `redirect failed: named route &quot;$&#123;name&#125;&quot; not found.`) &#125; return match(&#123; _normalized: true, name, query, hash, params &#125;, undefined, location) &#125; else if (path) &#123; // 1. resolve relative redirect const rawPath = resolveRecordPath(path, record) // 2. resolve params const resolvedPath = fillParams(rawPath, params, `redirect route with path &quot;$&#123;rawPath&#125;&quot;`) // 3. rematch with existing query and hash return match(&#123; _normalized: true, path: resolvedPath, query, hash &#125;, undefined, location) &#125; else &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn(false, `invalid redirect option: $&#123;JSON.stringify(redirect)&#125;`) &#125; return _createRoute(null, location) &#125; &#125; function alias ( record: RouteRecord, location: Location, matchAs: string ): Route &#123; const aliasedPath = fillParams(matchAs, location.params, `aliased route with path &quot;$&#123;matchAs&#125;&quot;`) const aliasedMatch = match(&#123; _normalized: true, path: aliasedPath &#125;) if (aliasedMatch) &#123; const matched = aliasedMatch.matched const aliasedRecord = matched[matched.length - 1] location.params = aliasedMatch.params return _createRoute(aliasedRecord, location) &#125; return _createRoute(null, location) &#125; function _createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: Location ): Route &#123; if (record &amp;&amp; record.redirect) &#123; return redirect(record, redirectedFrom || location) &#125; if (record &amp;&amp; record.matchAs) &#123; return alias(record, location, record.matchAs) &#125; return createRoute(record, location, redirectedFrom, router) &#125; return &#123; match, addRoutes &#125;&#125; createMatcher() 返回两个方法。match 用来返回匹配到的路由信息。addRoutes 用于动态添加路由。createMatcher() 第一次被调用的时候就会调用 createRouteMap，用来初始化初始路由，返回 pathList, pathMap, nameMap。当动态添加路由时仍调用 createRouteMap 方法，并以之前调用该方法的返回值为参数传入。12345678// 创建 route map，然后返回 pathList, pathMap, nameMap 供下次 addRoutes 使用const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)// 添加路由function addRoutes (routes) &#123; // 传入之前调用 createRouteMap 的返回值 createRouteMap(routes, pathList, pathMap, nameMap)&#125; createRouteMap1234567891011121314151617181920212223242526272829303132333435363738// 创建 route mapexport function createRouteMap ( routes: Array&lt;RouteConfig&gt;, oldPathList?: Array&lt;string&gt;, oldPathMap?: Dictionary&lt;RouteRecord&gt;, oldNameMap?: Dictionary&lt;RouteRecord&gt;): &#123; pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;&#125; &#123; // 路径列表用于控制路径匹配优先级 const pathList: Array&lt;string&gt; = oldPathList || [] // $flow-disable-line const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null) // $flow-disable-line const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null) // 遍历所有传入的 routes 数据，调用 addRouteRecord 添加路由记录 routes.forEach(route =&gt; &#123; addRouteRecord(pathList, pathMap, nameMap, route) &#125;) // 确保通配符(*)路由始终在最后 for (let i = 0, l = pathList.length; i &lt; l; i++) &#123; if (pathList[i] === &apos;*&apos;) &#123; pathList.push(pathList.splice(i, 1)[0]) l-- i-- &#125; &#125; return &#123; pathList, pathMap, nameMap &#125;&#125; createRouteMap 中遍历所有传入的 routes 数据，调用 addRouteRecord 添加路由记录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 添加路由记录function addRouteRecord ( pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;, route: RouteConfig, parent?: RouteRecord, matchAs?: string) &#123; const &#123; path, name &#125; = route // code... const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || &#123;&#125; const normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict) if (typeof route.caseSensitive === &apos;boolean&apos;) &#123; pathToRegexpOptions.sensitive = route.caseSensitive &#125; // 构造一个路由记录 const record: RouteRecord = &#123; path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || &#123; default: route.component &#125;, instances: &#123;&#125;, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || &#123;&#125;, props: route.props == null ? &#123;&#125; : route.components ? route.props : &#123; default: route.props &#125; &#125; // 处理子路由 if (route.children) &#123; // code... &#125; if (!pathMap[record.path]) &#123; pathList.push(record.path) pathMap[record.path] = record &#125; // 处理路由别名 if (route.alias !== undefined) &#123; // code... &#125; if (name) &#123; if (!nameMap[name]) &#123; nameMap[name] = record &#125; else if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !matchAs) &#123; warn( false, `Duplicate named routes definition: ` + `&#123; name: &quot;$&#123;name&#125;&quot;, path: &quot;$&#123;record.path&#125;&quot; &#125;` ) &#125; &#125;&#125; addRouteRecord 方法内首先会构造一个路由记录 record，如果存在子路由则递归调用 addRouteRecord。最后做对应处理后分别放入 addRouteRecord 的入参 pathMap 与 nameMap 中，由于引用传递就直接修改了外部的 pathMap 与 nameMap。 End","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Vue-router源码分析2-路由模式","slug":"Vue-router源码分析2","date":"2019-07-23T12:54:33.000Z","updated":"2019-07-23T08:07:57.502Z","comments":true,"path":"2019/07/23/Vue-router源码分析2/","link":"","permalink":"http://yoursite.com/2019/07/23/Vue-router源码分析2/","excerpt":"","text":"前文说到，Vue-Router 有三种模式包括 hash、history、abstract，对应 HashHistory、HTML5History、AbstractHistory 三个类。 hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。 history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。 它们提供了一些方法的各自实现供对外暴露的 this.history 调用。通常我们用到的就是 hash 和 history 两种，这里哟也只看 HashHistory 与 HTML5History 两个类。 HashHistory1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export class HashHistory extends History &#123; constructor (router: Router, base: ?string, fallback: boolean) &#123; super(router, base) // check history fallback deeplinking if (fallback &amp;&amp; checkFallback(this.base)) &#123; return &#125; ensureSlash() &#125; // 延迟到 app 装载完毕，以免过早的触发 hashchange事件， // 此方法会在 newRouter 时会被调用 setupListeners () &#123; const router = this.router const expectScroll = router.options.scrollBehavior // 滚动行为函数 const supportsScroll = supportsPushState &amp;&amp; expectScroll if (supportsScroll) &#123; setupScroll() &#125; // 开启监听 window.addEventListener(supportsPushState ? &apos;popstate&apos; : &apos;hashchange&apos;, () =&gt; &#123; const current = this.current if (!ensureSlash()) &#123; return &#125; // 先调用 transitionTo 之后处理 scroll 与修改 hash this.transitionTo(getHash(), route =&gt; &#123; if (supportsScroll) &#123; handleScroll(this.router, route, current, true) &#125; if (!supportsPushState) &#123; replaceHash(route.fullPath) &#125; &#125;) &#125;) &#125; push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushHash(route.fullPath) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort) &#125; replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort) &#125; go (n: number) &#123; window.history.go(n) &#125; ensureURL (push?: boolean) &#123; const current = this.current.fullPath if (getHash() !== current) &#123; push ? pushHash(current) : replaceHash(current) &#125; &#125; getCurrentLocation () &#123; return getHash() &#125;&#125; HTML5History123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263export class HTML5History extends History &#123; constructor (router: Router, base: ?string) &#123; super(router, base) const expectScroll = router.options.scrollBehavior const supportsScroll = supportsPushState &amp;&amp; expectScroll if (supportsScroll) &#123; setupScroll() &#125; const initLocation = getLocation(this.base) window.addEventListener(&apos;popstate&apos;, e =&gt; &#123; const current = this.current // Avoiding first `popstate` event dispatched in some browsers but first // history route not updated since async guard at the same time. const location = getLocation(this.base) if (this.current === START &amp;&amp; location === initLocation) &#123; return &#125; this.transitionTo(location, route =&gt; &#123; if (supportsScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;) &#125; go (n: number) &#123; window.history.go(n) &#125; push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort) &#125; replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort) &#125; ensureURL (push?: boolean) &#123; if (getLocation(this.base) !== this.current.fullPath) &#123; const current = cleanPath(this.base + this.current.fullPath) push ? pushState(current) : replaceState(current) &#125; &#125; getCurrentLocation (): string &#123; return getLocation(this.base) &#125;&#125; HashHistory 监听的是 hashchange 事件，HashHistory 监听的是 popstate 事件。HashHistory 与 HTML5History 提供了各自的 go、push、replace 等方法，并且他俩都继承自 History 类，它位于 src/history/base.js，它有这样几个主要的方法： transitionTo调用路由过渡，他会调用 confirmTransition 方法确认路由的过渡。1234567891011121314151617181920212223242526272829303132333435transitionTo ( location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) // 确认路由的过渡 this.confirmTransition( route, () =&gt; &#123; this.updateRoute(route) onComplete &amp;&amp; onComplete(route) this.ensureURL() // fire ready cbs once // ready 回调只触发一次 if (!this.ready) &#123; this.ready = true this.readyCbs.forEach(cb =&gt; &#123; cb(route) &#125;) &#125; &#125;, err =&gt; &#123; if (onAbort) &#123; onAbort(err) &#125; if (err &amp;&amp; !this.ready) &#123; this.ready = true this.readyErrorCbs.forEach(cb =&gt; &#123; cb(err) &#125;) &#125; &#125; )&#125; confirmTransition确认路由的过渡。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 确认过渡confirmTransition (route: Route, onComplete: Function, onAbort?: Function) &#123; const current = this.current const abort = err =&gt; &#123; // 当用户使用前进后退按钮时，我们不想抛出错误。我们只想在调用 push/replace 时抛出。这是它不包含在 isError 中的原因 if (!isExtendedError(NavigationDuplicated, err) &amp;&amp; isError(err)) &#123; if (this.errorCbs.length) &#123; this.errorCbs.forEach(cb =&gt; &#123; cb(err) &#125;) &#125; else &#123; warn(false, &apos;uncaught error during route navigation:&apos;) console.error(err) &#125; &#125; onAbort &amp;&amp; onAbort(err) &#125; if ( isSameRoute(route, current) &amp;&amp; // in the case the route map has been dynamically appended to route.matched.length === current.matched.length ) &#123; this.ensureURL() return abort(new NavigationDuplicated(route)) &#125; // updated, deactivated, activated 生命周期钩子函数，deactivated 是当前路由的，其他两个是下一个路由的 const &#123; updated, deactivated, activated &#125; = resolveQueue( this.current.matched, // 当前路由 route.matched // 目标路由 ) // 执行队列 const queue: Array&lt;?NavigationGuard&gt; = [].concat( // 组件内的 leave 导航(即 deactivated 钩子) extractLeaveGuards(deactivated), // 全局的(VueRouter) before 钩子 this.router.beforeHooks, // 组件内的 updated 钩子 extractUpdateHooks(updated), // in-config enter guards // 配置的进入钩子 activated activated.map(m =&gt; m.beforeEnter), // 处理异步组件，然后触发 activated 钩子 resolveAsyncComponents(activated) ) this.pending = route // 该迭代器后面会依次迭代 queue const iterator = (hook: NavigationGuard, next) =&gt; &#123; if (this.pending !== route) &#123; return abort() &#125; try &#123; hook(route, current, (to: any) =&gt; &#123; if (to === false || isError(to)) &#123; // next(false) -&gt; abort navigation, ensure current URL this.ensureURL(true) abort(to) &#125; else if ( typeof to === &apos;string&apos; || (typeof to === &apos;object&apos; &amp;&amp; (typeof to.path === &apos;string&apos; || typeof to.name === &apos;string&apos;)) ) &#123; // next(&apos;/&apos;) or next(&#123; path: &apos;/&apos; &#125;) -&gt; redirect abort() if (typeof to === &apos;object&apos; &amp;&amp; to.replace) &#123; this.replace(to) &#125; else &#123; this.push(to) &#125; &#125; else &#123; // confirm transition and pass on the value next(to) &#125; &#125;) &#125; catch (e) &#123; abort(e) &#125; &#125; // 运行队列 runQueue(queue, iterator, () =&gt; &#123; const postEnterCbs = [] const isValid = () =&gt; this.current === route // wait until async components are resolved before // extracting in-component enter guards // 等异步组件执行完成再提取组件内钩子，使用 runQueue 再次迭代 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () =&gt; &#123; if (this.pending !== route) &#123; return abort() &#125; this.pending = null onComplete(route) if (this.router.app) &#123; this.router.app.$nextTick(() =&gt; &#123; postEnterCbs.forEach(cb =&gt; &#123; cb() &#125;) &#125;) &#125; &#125;) &#125;)&#125; 取出当前组件的 deactivated 生命周期函数，目标路由的 updated, activated 生命周期函数。将它们与全局钩子函数组合成一个名为 queue 的队列。又定义了一个名为 iterator 的迭代器。调用 runQueue 方法，使用 iterator 来迭代执行 queue。runQueue 执行完之后再对异步加载的组件执行一此 runQueue。最后调用 updateRoute 更新路由：123456789// 更新路由updateRoute (route: Route) &#123; const prev = this.current this.current = route this.cb &amp;&amp; this.cb(route) this.router.afterHooks.forEach(hook =&gt; &#123; hook &amp;&amp; hook(route, prev) &#125;)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Vue-router源码分析3-视图更新","slug":"Vue-router源码分析3","date":"2019-07-23T12:54:33.000Z","updated":"2019-07-26T06:45:27.792Z","comments":true,"path":"2019/07/23/Vue-router源码分析3/","link":"","permalink":"http://yoursite.com/2019/07/23/Vue-router源码分析3/","excerpt":"","text":"transitionTo 与 confirmTransition 修改的只是 URL 与数据，视图是如何更新的呢？ VueRouter全局注册 与 组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798export default &#123; name: &apos;RouterView&apos;, functional: true, props: &#123; // 命名视图（https://router.vuejs.org/zh/guide/essentials/named-views.html） // 用的不多，通常就是默认值 &apos;default&apos; name: &#123; type: String, default: &apos;default&apos; &#125; &#125;, render (_, &#123; props, children, parent, data &#125;) &#123; // used by devtools to display a router-view badge data.routerView = true // 直接使用父上下文的createElement（）函数 // 使router-view渲染的组件可以解析命名slots const h = parent.$createElement // 父组件的createElement()函数 const name = props.name // 传入的视图名 const route = parent.$route // routerView 缓存 const cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;) // determine current view depth, also check to see if the tree // has been toggled inactive but kept-alive. let depth = 0 let inactive = false while (parent &amp;&amp; parent._routerRoot !== parent) &#123; const vnodeData = parent.$vnode &amp;&amp; parent.$vnode.data if (vnodeData) &#123; if (vnodeData.routerView) &#123; depth++ &#125; if (vnodeData.keepAlive &amp;&amp; parent._inactive) &#123; inactive = true &#125; &#125; parent = parent.$parent &#125; data.routerViewDepth = depth // 如果树处于待用状态并保持活动状态，则渲染上一个视图 if (inactive) &#123; return h(cache[name], data, children) &#125; const matched = route.matched[depth] // 未匹配到，渲染空节点 if (!matched) &#123; cache[name] = null return h() &#125; // 默认取 ‘default’ 组件 或 取传入的命名组件 const component = cache[name] = matched.components[name] // 附带实例注册钩子，它将会在实例的注入生命周期时被调用 data.registerRouteInstance = (vm, val) =&gt; &#123; // val could be undefined for unregistration const current = matched.instances[name] // 组件实例 if ( (val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm) ) &#123; matched.instances[name] = val &#125; &#125; ;(data.hook || (data.hook = &#123;&#125;)).prepatch = (_, vnode) =&gt; &#123; matched.instances[name] = vnode.componentInstance &#125; data.hook.init = (vnode) =&gt; &#123; if (vnode.data.keepAlive &amp;&amp; vnode.componentInstance &amp;&amp; vnode.componentInstance !== matched.instances[name] ) &#123; matched.instances[name] = vnode.componentInstance &#125; &#125; let propsToPass = data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name]) if (propsToPass) &#123; // clone to prevent mutation propsToPass = data.props = extend(&#123;&#125;, propsToPass) // pass non-declared props as attrs const attrs = data.attrs = data.attrs || &#123;&#125; for (const key in propsToPass) &#123; if (!component.props || !(key in component.props)) &#123; attrs[key] = propsToPass[key] delete propsToPass[key] &#125; &#125; &#125; return h(component, data, children) &#125;&#125; 主要是根据匹配到的路由的不同，render 函数渲染不同的视图。 监听 _route1234567891011121314151617181920212223242526src/install.js// 全局注入 beforeCreate 与 destroyed Vue.mixin(&#123; beforeCreate () &#123; /** * 我们在 new Vue() 时传入 router，vue就会把 router 挂载到 this.$options 上， * 这里判断 this.$options.router 是否存在， * 这就是 new Vue() 需要传入 router 的原因 */ if (isDef(this.$options.router)) &#123; this._routerRoot = this // Vue this._router = this.$options.router // VueRouter this._router.init(this) // 调用 VueRouter init 方法 // 添加对 ‘_route’ 的监听。 // 调用 history.transitionTo，改变路由后会改变 ‘_route’， // 就会使 ‘&lt;router-view&gt;’ 组件的 render 方法重新渲染。 Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125;&#125;) 修改 _route 在 VueRouter 的 init 方法中提供一个回调函数，并调用 history.listen。 这个回调函数会去修改 _route 12345history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;)&#125;) history.listen 保存回调函数 123listen (cb: Function) &#123; this.cb = cb&#125; confirmTransition 方法执行成功后，调用 this.updateRoute(route) 他会调用之前保存的回调函数改变 _route。_route改变后，RouterView 的 render 方法会重新执行渲染界面。 123456789// 更新路由updateRoute (route: Route) &#123; const prev = this.current this.current = route this.cb &amp;&amp; this.cb(route) // &lt;====== this.router.afterHooks.forEach(hook =&gt; &#123; hook &amp;&amp; hook(route, prev) &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108export default &#123; name: &apos;RouterLink&apos;, props: &#123; to: &#123; type: toTypes, required: true &#125;, tag: &#123; // 组件渲染成的标签名，默认为a type: String, default: &apos;a&apos; &#125;, exact: Boolean, append: Boolean, replace: Boolean, activeClass: String, exactActiveClass: String, event: &#123; // 声明可以用来触发导航的事件。 type: eventTypes, default: &apos;click&apos; &#125; &#125;, render (h: Function) &#123; const router = this.$router const current = this.$route const &#123; location, route, href &#125; = router.resolve( this.to, current, this.append ) const classes = &#123;&#125; // &lt;router-link&gt; 的默认“激活 class 类名。https://router.vuejs.org/zh/api/#linkactiveclass const globalActiveClass = router.options.linkActiveClass // 全局配置 &lt;router-link&gt; 精确激活的默认的 class。https://router.vuejs.org/zh/api/#linkexactactiveclass const globalExactActiveClass = router.options.linkExactActiveClass // 如果没传 linkActiveClass 或 linkExactActiveClass，为它俩设置默认值 const activeClassFallback = globalActiveClass == null ? &apos;router-link-active&apos; : globalActiveClass const exactActiveClassFallback = globalExactActiveClass == null ? &apos;router-link-exact-active&apos; : globalExactActiveClass // router-link 没有传入 active-class 属性，就将其赋值为全局配置的 linkActiveClass const activeClass = this.activeClass == null ? activeClassFallback : this.activeClass // router-link 没有传入 exact-active-class 属性，就将其赋值为全局配置的 linkExactActiveClass const exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass // 对重定向的处理 const compareTarget = route.redirectedFrom ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router) : route classes[exactActiveClass] = isSameRoute(current, compareTarget) classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget) // 事件处理函数 const handler = e =&gt; &#123; if (guardEvent(e)) &#123; // 调用 router.replace 或 router.push 跳转路由 if (this.replace) &#123; router.replace(location) &#125; else &#123; router.push(location) &#125; &#125; &#125; const on = &#123; click: guardEvent &#125; if (Array.isArray(this.event)) &#123; this.event.forEach(e =&gt; &#123; on[e] = handler &#125;) &#125; else &#123; on[this.event] = handler &#125; // 构造 createElement 的 data 参数 const data: any = &#123; class: classes &#125; if (this.tag === &apos;a&apos;) &#123; data.on = on data.attrs = &#123; href &#125; &#125; else &#123; // find the first &lt;a&gt; child and apply listener and href const a = findAnchor(this.$slots.default) if (a) &#123; // in case the &lt;a&gt; is a static node a.isStatic = false const aData = (a.data = extend(&#123;&#125;, a.data)) aData.on = on const aAttrs = (a.data.attrs = extend(&#123;&#125;, a.data.attrs)) aAttrs.href = href &#125; else &#123; // doesn&apos;t have &lt;a&gt; child, apply listener to self data.on = on &#125; &#125; return h(this.tag, data, this.$slots.default) &#125;&#125; 组件比较简单，首先处理全局配置的 linkActiveClass 与 linkExactActiveClass，之后处理 router-link 组件的 active-class 属性与 exact-active-class 属性。构造 createElement 的 data 参数，包括 on、attrs。handel 函数为事件的回调函数：12345678910const handler = e =&gt; &#123; if (guardEvent(e)) &#123; // 调用 router.replace 或 router.push 跳转路由 if (this.replace) &#123; router.replace(location) &#125; else &#123; router.push(location) &#125; &#125;&#125; guardEvent 函数会过滤掉无需处理事件，最后根据是否有 replace 属性，调用 router.replace 或 router.push 跳转路由。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Vue-router源码分析1","slug":"Vue-router源码分析1","date":"2019-07-16T12:54:33.000Z","updated":"2019-07-26T08:55:43.392Z","comments":true,"path":"2019/07/16/Vue-router源码分析1/","link":"","permalink":"http://yoursite.com/2019/07/16/Vue-router源码分析1/","excerpt":"","text":"Vue-router 版本 3.0.7 目录结构123456789101112-- lib -- components // 存放 &lt;router-view&gt; 与 &lt;router-link&gt; 组件 -- history // 存放几种路由方式文件 -- base.js // 所有模式共有部分 -- hash.js // hash 模式 -- html5.js // h5 history 模式 ...... -- util // 工具函数 -- create-matcher.js // -- create-route-map.js // -- index.js // 入口文件 -- install.js // 用于 Vue.use() Vue-router 在模块化项目中的常规使用123456789101112131415161718import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;// 调用 Vue.use()，在模块化项目中必须手动调用，在常规项目中（script 标签引入） Vue 会主动调用 use。Vue.use(VueRouter)// 创建路由实例var router = new VueRouter(&#123; mode: &apos;hash&apos;, // 路由模式 routes: routes // 路由配置&#125;)// 创建 Vue 实例new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App), router,&#125;) 我们按照 Vue-router 的使用一步步来看。 Vue.use(VueRouter)Vue.use 方法会调用插件的 install 方法，Vue-router 的 install 方法位于 src/install.js 文件中：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export let _Vueexport function install (Vue) &#123; if (install.installed &amp;&amp; _Vue === Vue) return // 已被安装 return install.installed = true _Vue = Vue const isDef = v =&gt; v !== undefined const registerInstance = (vm, callVal) =&gt; &#123; let i = vm.$options._parentVnode if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123; i(vm, callVal) &#125; &#125; // 全局注入 beforeCreate 与 destroyed Vue.mixin(&#123; beforeCreate () &#123; // 这里判断 this.$options.router 是否存在，我们在 new Vue() 时传入 router，vue就会把 router 挂载到 this.$options 上，这是 new Vue() 需要传入 router 的原因 if (isDef(this.$options.router)) &#123; this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current) &#125; else &#123; this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this &#125; registerInstance(this, this) &#125;, destroyed () &#123; registerInstance(this) &#125; &#125;) // 在 Vue 的原型上定义 $router，使之可以在 Vue 组件中以 this.$router 调用 Object.defineProperty(Vue.prototype, &apos;$router&apos;, &#123; get () &#123; return this._routerRoot._router &#125; &#125;) // 在 Vue 的原型上定义 $route，使之可以在 Vue 组件中以 this.$route 调用 Object.defineProperty(Vue.prototype, &apos;$route&apos;, &#123; get () &#123; return this._routerRoot._route &#125; &#125;) // 全局注册 &lt;router-view&gt; 与 &lt;router-link&gt; 组件 Vue.component(&apos;RouterView&apos;, View) Vue.component(&apos;RouterLink&apos;, Link) const strats = Vue.config.optionMergeStrategies // use the same hook merging strategy for route hooks strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created&#125; 首先使用 Vue.mixin 全局混入了 beforeCreate 与 destroyed 两个周期函数。接着在 Vue 的原型上定义 $router 和 $route，我们就可以在 Vue 组件中访问到 this.$router 和 this.router。最后使用 Vue.component 全局注册 &lt;router-view&gt; 与 &lt;router-link&gt; 组件。 new VueRouter()VueRouter 的构造函数：123456789101112131415161718192021222324252627282930313233343536constructor (options: RouterOptions = &#123;&#125;) &#123; this.app = null this.apps = [] this.options = options this.beforeHooks = [] this.resolveHooks = [] this.afterHooks = [] this.matcher = createMatcher(options.routes || [], this) let mode = options.mode || &apos;hash&apos; this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false if (this.fallback) &#123; mode = &apos;hash&apos; &#125; if (!inBrowser) &#123; mode = &apos;abstract&apos; &#125; this.mode = mode // 根据模式的不同实例化不同的 this.history switch (mode) &#123; case &apos;history&apos;: this.history = new HTML5History(this, options.base) break case &apos;hash&apos;: this.history = new HashHistory(this, options.base, this.fallback) break case &apos;abstract&apos;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &apos;production&apos;) &#123; assert(false, `invalid mode: $&#123;mode&#125;`) &#125; &#125;&#125; VueRouter的构造函数中会根据模式的不同实例化不同的 this.history，包括 hash、history、abstract 三种，对应 HashHistory、HTML5History、AbstractHistory 三个类，这三个类分别实现了自己的 onReady、onError、push、replace、go、getCurrentLocation 等方法，VueRouter 类向外暴露的同名方法实际上就是调用了上面三个类自己实现的方法：123456789101112131415161718192021222324252627onReady (cb: Function, errorCb?: Function) &#123; this.history.onReady(cb, errorCb)&#125;onError (errorCb: Function) &#123; this.history.onError(errorCb)&#125;push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.push(location, onComplete, onAbort)&#125;replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.replace(location, onComplete, onAbort)&#125;go (n: number) &#123; this.history.go(n)&#125;back () &#123; this.go(-1)&#125;forward () &#123; this.go(1)&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Axios源码4-请求的取消","slug":"Axios源码4","date":"2019-07-15T13:30:34.000Z","updated":"2019-07-15T09:11:38.898Z","comments":true,"path":"2019/07/15/Axios源码4/","link":"","permalink":"http://yoursite.com/2019/07/15/Axios源码4/","excerpt":"","text":"Axios 请求取消的相关用法文档上有给出两种用法。一种是使用 CancelToken.source 工厂方法创建 cancel token：123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel(&apos;Operation canceled by the user.&apos;); 另一种是通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get(&apos;/user/12345&apos;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 这两种用法的不同点是第一种不需要我们手动去 new CancelToken()，共同点是都需要传入一个 cancelToken 参数。 xhr.js 与 http.js 对 cancelToken 的处理对于取消的处理都在代码的末尾处：xhr.js1234567891011121314151617181920if (config.cancelToken) &#123; // 请求取消相关 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // Clean up request request = null; &#125;);&#125;if (requestData === undefined) &#123; requestData = null;&#125;// 4. ========== 发起请求 ==========request.send(requestData); http.js123456789101112131415161718if (config.cancelToken) &#123; // 处理取消 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (req.aborted) return; req.abort(); reject(cancel); &#125;);&#125;// 发送请求if (utils.isStream(data)) &#123; data.on(&apos;error&apos;, function handleStreamError(err) &#123; reject(enhanceError(err, config, null, req)); &#125;).pipe(req);&#125; else &#123; req.end(data);&#125; xhr.js 与 http.js 中都有这么一段：123config.cancelToken.promise.then(function onCanceled(cancel) &#123; // code... 取消代码省略&#125;); cancelToken.promise 是一个 Promise，一旦它的状态变为成功，则会执行对应的 request 的取消操作。接下来看 CancelToken CancelTokenlib/cancel/CancelToken.js123456789101112131415161718192021222324252627282930313233343536373839function CancelToken(executor) &#123; // executor 不是函数则抛错 if (typeof executor !== &apos;function&apos;) &#123; throw new TypeError(&apos;executor must be a function.&apos;); &#125; var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve; &#125;); var token = this; executor(function cancel(message) &#123; if (token.reason) &#123; // 请求已经取消过了，不允许再次取消 return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason); &#125;);&#125;CancelToken.prototype.throwIfRequested = function throwIfRequested() &#123; if (this.reason) &#123; throw this.reason; &#125;&#125;;CancelToken.source = function source() &#123; var cancel; var token = new CancelToken(function executor(c) &#123; cancel = c; &#125;); return &#123; token: token, cancel: cancel &#125;;&#125;; 第二种用法中，我们调用了 cancel()，来取消请求，而 cancel 是 CancelToken 的参数的参数 c。 而在 CancelToken.js 的 CancelToken.source 中，也就是第一种用法调用的，Axios 其实帮我们 new 了 CancelToken，我们调用 source.cancel() 取消时，这个 source.cancel 还是 CancelToken 的参数的参数 c，也就是下面代码中的 cancel 函数:123456789101112131415var resolvePromise;this.promise = new Promise(function promiseExecutor(resolve) &#123; resolvePromise = resolve;&#125;);var token = this;executor(function cancel(message) &#123; if (token.reason) &#123; // 请求已经取消过了，不允许再次取消 return; &#125; token.reason = new Cancel(message); resolvePromise(token.reason);&#125;); 其中 this.promise 就等于 xhr.js 与 http.js 中的 config.cancelToken.promise，当用户手动调用 cancel 方法，就会使 config.cancelToken.promise 的状态变为成功，进而执行对应的请求取消操作（前提是这个请求还没有完成）。 其他还剩一点东西就在这里一同写了吧： axios.all 与 axios.spread它俩搭配，可用于等待多个请求通知返回。用法类似 Promise.all123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 实际上 axios.all 方法返回的就是 Promise.all，因为 axios 的返回本就是 Promise：123axios.all = function all(promises) &#123; return Promise.all(promises);&#125;; axios.spread 作为 axios.all 的参数实际上就是对其包了一层，使之可以在 axios 上下文中执行。12345module.exports = function spread(callback) &#123; return function wrap(arr) &#123; return callback.apply(null, arr); &#125;;&#125;;","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Axios源码3-请求方法","slug":"Axios源码3","date":"2019-07-15T13:30:34.000Z","updated":"2019-07-15T07:38:25.165Z","comments":true,"path":"2019/07/15/Axios源码3/","link":"","permalink":"http://yoursite.com/2019/07/15/Axios源码3/","excerpt":"","text":"dispatchRequest上篇文章中说到，在lib/core/Axios.js中有用到 dispatchRequest 方法，这个方法就用于发起请求，并返回一个 Promise：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465lib/core/dispatchRequest.jsmodule.exports = function dispatchRequest(config) &#123; // 请求取消相关 throwIfCancellationRequested(config); // 如果配置了 baseURL，这里会做处理 if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) &#123; config.url = combineURLs(config.baseURL, config.url); &#125; // 保证请求头的存在 config.headers = config.headers || &#123;&#125;; // 转换请求数据 config.data = transformData( config.data, config.headers, config.transformRequest ); // Flatten headers config.headers = utils.merge( config.headers.common || &#123;&#125;, config.headers[config.method] || &#123;&#125;, config.headers || &#123;&#125; ); utils.forEach( [&apos;delete&apos;, &apos;get&apos;, &apos;head&apos;, &apos;post&apos;, &apos;put&apos;, &apos;patch&apos;, &apos;common&apos;], function cleanHeaderConfig(method) &#123; delete config.headers[method]; &#125; ); // 使用用户配置的 adapter 或默认的 adapter var adapter = config.adapter || defaults.adapter; // 发起请求 return adapter(config).then(function onAdapterResolution(response) &#123; throwIfCancellationRequested(config); // Transform response data response.data = transformData( response.data, response.headers, config.transformResponse ); return response; &#125;, function onAdapterRejection(reason) &#123; if (!isCancel(reason)) &#123; throwIfCancellationRequested(config); // Transform response data if (reason &amp;&amp; reason.response) &#123; reason.response.data = transformData( reason.response.data, reason.response.headers, config.transformResponse ); &#125; &#125; return Promise.reject(reason); &#125;);&#125;; dispatchRequest 方法比较简单，主要是处理请求数据，并调用 adapter 方法发起请求。 adapter 方法1var adapter = config.adapter || defaults.adapter; 用户可以自定义 adapter，如果没有的话则是用默认的 adapter 方法，这个我在第一篇文章的末尾有提到：123456789101112function getDefaultAdapter() &#123; var adapter; // Node.js 有 process，可以依此来判断 Node.js 环境 if (typeof process !== &apos;undefined&apos; &amp;&amp; Object.prototype.toString.call(process) === &apos;[object process]&apos;) &#123; // node 使用 http adapter = require(&apos;./adapters/http&apos;); &#125; else if (typeof XMLHttpRequest !== &apos;undefined&apos;) &#123; // 浏览器使用 XHR adapter = require(&apos;./adapters/xhr&apos;); &#125; return adapter;&#125; axios 会根据环境的不同引入不同的代码，浏览器下为 xhr.js，Node.js 下为 http.js，先看 xhr.js: lib/adapters/xhr.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146module.exports = function xhrAdapter(config) &#123; return new Promise(function dispatchXhrRequest(resolve, reject) &#123; var requestData = config.data; var requestHeaders = config.headers; if (utils.isFormData(requestData)) &#123; delete requestHeaders[&apos;Content-Type&apos;]; // Let the browser set it &#125; // 1. ========== 实例化 xhr ========== var request = new XMLHttpRequest(); // HTTP Authorization 请求头 if (config.auth) &#123; var username = config.auth.username || &apos;&apos;; var password = config.auth.password || &apos;&apos;; requestHeaders.Authorization = &apos;Basic &apos; + btoa(username + &apos;:&apos; + password); &#125; // 2. ========== 调用 open 方法 ========== request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true); request.timeout = config.timeout; // 设置超时时间 // 3. ========== 监听 readystatechange 事件 ========== request.onreadystatechange = function handleLoad() &#123; if (!request || request.readyState !== 4) &#123; return; &#125; if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf(&apos;file:&apos;) === 0)) &#123; return; &#125; // Prepare the response var responseHeaders = &apos;getAllResponseHeaders&apos; in request ? parseHeaders(request.getAllResponseHeaders()) : null; var responseData = !config.responseType || config.responseType === &apos;text&apos; ? request.responseText : request.response; var response = &#123; data: responseData, status: request.status, statusText: request.statusText, headers: responseHeaders, config: config, request: request &#125;; settle(resolve, reject, response); // Clean up request request = null; &#125;; // Handle browser request cancellation (as opposed to a manual cancellation) // 处理浏览器请求取消（非手动取消） request.onabort = function handleAbort() &#123; if (!request) &#123; return; &#125; reject(createError(&apos;Request aborted&apos;, config, &apos;ECONNABORTED&apos;, request)); request = null; &#125;; // 处理低级别网络错误 request.onerror = function handleError() &#123; reject(createError(&apos;Network Error&apos;, config, null, request)); request = null; &#125;; // 超时处理 request.ontimeout = function handleTimeout() &#123; reject(createError(&apos;timeout of &apos; + config.timeout + &apos;ms exceeded&apos;, config, &apos;ECONNABORTED&apos;, request)); request = null; &#125;; // 添加 xsrf 头，仅标准浏览器中 if (utils.isStandardBrowserEnv()) &#123; var cookies = require(&apos;./../helpers/cookies&apos;); // Add xsrf header var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) &amp;&amp; config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined; if (xsrfValue) &#123; requestHeaders[config.xsrfHeaderName] = xsrfValue; &#125; &#125; // 给请求添加头信息 if (&apos;setRequestHeader&apos; in request) &#123; utils.forEach(requestHeaders, function setRequestHeader(val, key) &#123; if (typeof requestData === &apos;undefined&apos; &amp;&amp; key.toLowerCase() === &apos;content-type&apos;) &#123; // Remove Content-Type if data is undefined delete requestHeaders[key]; &#125; else &#123; // Otherwise add header to the request request.setRequestHeader(key, val); &#125; &#125;); &#125; // 如果需要添加 withCredentials 到请求中 if (config.withCredentials) &#123; request.withCredentials = true; &#125; // 如果需要添加 responseType 到请求中 if (config.responseType) &#123; try &#123; request.responseType = config.responseType; &#125; catch (e) &#123; // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2. // But, this can be suppressed for &apos;json&apos; type as it can be parsed by default &apos;transformResponse&apos; function. if (config.responseType !== &apos;json&apos;) &#123; throw e; &#125; &#125; &#125; // 处理请求的进度 if (typeof config.onDownloadProgress === &apos;function&apos;) &#123; request.addEventListener(&apos;progress&apos;, config.onDownloadProgress); &#125; // 对 onUploadProgress 事件的处理 if (typeof config.onUploadProgress === &apos;function&apos; &amp;&amp; request.upload) &#123; request.upload.addEventListener(&apos;progress&apos;, config.onUploadProgress); &#125; if (config.cancelToken) &#123; // 请求取消相关 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (!request) &#123; return; &#125; request.abort(); reject(cancel); // Clean up request request = null; &#125;); &#125; if (requestData === undefined) &#123; requestData = null; &#125; // 4. ========== 发起请求 ========== request.send(requestData); &#125;);&#125;; xhr.js 返回了一个 Promise，在 Promise 中 实例化 xhr new XMLHttpRequest()，监听 onreadystatechange 事件，再处理各种配置参数，最后调用 send 方法，发起请求。 lib/adapters/http.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137var isHttps = /https:?/;/*eslint consistent-return:0*/module.exports = function httpAdapter(config) &#123; return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) &#123; var timer; var resolve = function resolve(value) &#123; clearTimeout(timer); resolvePromise(value); &#125;; var reject = function reject(value) &#123; clearTimeout(timer); rejectPromise(value); &#125;; var data = config.data; var headers = config.headers; /* code... 省略 */ // 参数 var options = &#123; path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, &apos;&apos;), method: config.method.toUpperCase(), headers: headers, agent: agent, auth: auth &#125;; /* code... 省略 */ // 请求方法的选择 var transport; var isHttpsProxy = isHttpsRequest &amp;&amp; (proxy ? isHttps.test(proxy.protocol) : true); if (config.transport) &#123; transport = config.transport; &#125; else if (config.maxRedirects === 0) &#123; transport = isHttpsProxy ? https : http; &#125; else &#123; if (config.maxRedirects) &#123; options.maxRedirects = config.maxRedirects; &#125; transport = isHttpsProxy ? httpsFollow : httpFollow; &#125; /* code... 省略 */ // 创建请求 var req = transport.request(options, function handleResponse(res) &#123; if (req.aborted) return; var stream = res; switch (res.headers[&apos;content-encoding&apos;]) &#123; case &apos;gzip&apos;: case &apos;compress&apos;: case &apos;deflate&apos;: stream = (res.statusCode === 204) ? stream : stream.pipe(zlib.createUnzip()); delete res.headers[&apos;content-encoding&apos;]; break; &#125; var lastRequest = res.req || req; var response = &#123; status: res.statusCode, statusText: res.statusMessage, headers: res.headers, config: config, request: lastRequest &#125;; if (config.responseType === &apos;stream&apos;) &#123; response.data = stream; settle(resolve, reject, response); &#125; else &#123; var responseBuffer = []; stream.on(&apos;data&apos;, function handleStreamData(chunk) &#123; responseBuffer.push(chunk); // make sure the content length is not over the maxContentLength if specified if (config.maxContentLength &gt; -1 &amp;&amp; Buffer.concat(responseBuffer).length &gt; config.maxContentLength) &#123; stream.destroy(); reject(createError(&apos;maxContentLength size of &apos; + config.maxContentLength + &apos; exceeded&apos;, config, null, lastRequest)); &#125; &#125;); stream.on(&apos;error&apos;, function handleStreamError(err) &#123; if (req.aborted) return; reject(enhanceError(err, config, null, lastRequest)); &#125;); stream.on(&apos;end&apos;, function handleStreamEnd() &#123; var responseData = Buffer.concat(responseBuffer); if (config.responseType !== &apos;arraybuffer&apos;) &#123; responseData = responseData.toString(config.responseEncoding); &#125; response.data = responseData; settle(resolve, reject, response); &#125;); &#125; &#125;); // 处理错误 req.on(&apos;error&apos;, function handleRequestError(err) &#123; if (req.aborted) return; reject(enhanceError(err, config, null, req)); &#125;); // 处理超时 if (config.timeout) &#123; timer = setTimeout(function handleRequestTimeout() &#123; req.abort(); reject(createError(&apos;timeout of &apos; + config.timeout + &apos;ms exceeded&apos;, config, &apos;ECONNABORTED&apos;, req)); &#125;, config.timeout); &#125; if (config.cancelToken) &#123; // 处理取消 config.cancelToken.promise.then(function onCanceled(cancel) &#123; if (req.aborted) return; req.abort(); reject(cancel); &#125;); &#125; // 发送请求 if (utils.isStream(data)) &#123; data.on(&apos;error&apos;, function handleStreamError(err) &#123; reject(enhanceError(err, config, null, req)); &#125;).pipe(req); &#125; else &#123; req.end(data); &#125; &#125;);&#125;; http.js 整体返回也是一个 Promise，不过内部使用了 Node.js 的 http 与 https 模块，对参数进行处理后发起请求。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Axios源码2-Axios构造函数","slug":"Axios源码2","date":"2019-07-14T10:30:41.000Z","updated":"2019-07-15T06:26:24.819Z","comments":true,"path":"2019/07/14/Axios源码2/","link":"","permalink":"http://yoursite.com/2019/07/14/Axios源码2/","excerpt":"","text":"Axios 实例lib/core/Axios.js首先是 Axios 的构造函数：12345678function Axios(instanceConfig) &#123; this.defaults = instanceConfig; // request &amp; response 拦截器 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125; this.defaults 存放默认配置。this.interceptors 存放 request 与 response 的拦截器，我们看下拦截器的实现： 拦截器12345678910111213141516171819202122232425262728293031lib/core/InterceptorManager.jsfunction InterceptorManager() &#123; // 用于储存所有 use 方法传入的拦截器 this.handlers = [];&#125;// 添加一个新拦截器InterceptorManager.prototype.use = function use(fulfilled, rejected) &#123; this.handlers.push(&#123; fulfilled: fulfilled, rejected: rejected &#125;); return this.handlers.length - 1;&#125;;// 移除一个拦截器InterceptorManager.prototype.eject = function eject(id) &#123; if (this.handlers[id]) &#123; this.handlers[id] = null; &#125;&#125;;// 迭代所有注册的拦截器，fn函数会调用每一个拦截器InterceptorManager.prototype.forEach = function forEach(fn) &#123; utils.forEach(this.handlers, function forEachHandler(h) &#123; if (h !== null) &#123; fn(h); &#125; &#125;);&#125;; 拦截器比较简单，this.handlers 用于存放拦截器，use 用于添加拦截器，eject 用于删除拦截器，forEach 用于迭代所有拦截器。 Axios.prototype.request 方法12345678910111213141516171819202122232425262728293031Axios.prototype.request = function request(config) &#123; // 处理这种方式调用： axios(&apos;example/url&apos;[, config]) if (typeof config === &apos;string&apos;) &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0]; &#125; else &#123; config = config || &#123;&#125;; &#125; config = mergeConfig(this.defaults, config); // 合并参数 config.method = config.method ? config.method.toLowerCase() : &apos;get&apos;; // 判断请求方法，默认为 get // Hook up interceptors middleware var chain = [dispatchRequest, undefined]; var promise = Promise.resolve(config); // 遍历每一个 request 拦截器，unshift fulfilled 与 rejected 进 chain this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123; chain.unshift(interceptor.fulfilled, interceptor.rejected); &#125;); // 遍历每一个 response 拦截器，push fulfilled 与 rejected 进 chain this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123; chain.push(interceptor.fulfilled, interceptor.rejected); &#125;); while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; return promise;&#125;; 我们从定义 chain 这个变量开始看起：1var chain = [dispatchRequest, undefined]; chain 是一个数组，数组中有两个元素 dispatchRequest 和 undefined，dispatchRequest 我们姑且可以简单的认为是一个返回 Promise 的请求方法。接下来定义了变量 promise。传入 config 参数：1var promise = Promise.resolve(config); 之后分别遍历 request 拦截器、response 拦截器，将每一个 request 拦截器的 fulfilled 与 rejected 方法添加到 chain 这个数组的前面，将每一个 response 拦截器的 fulfilled 与 rejected 方法添加到 chain 的后面。 之后 while 循环，当 chain 还有 length 时候，就会一直取出 chain 的前两个元素，再将它们作为参数执行 promise.then(元素0，元素1)，并将其赋值给 promise，最后返回 promise。初看 request 方法时，懵逼就懵逼再这里。 我们将其简化一下，不考虑所有拦截器的情况：12345678910111213var config = &#123; url: &apos;test&apos; &#125; // 配置function testRequest (config) &#123; // 模拟请求 console.log(&apos;testRequest&apos;, config) return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;,3000) &#125;)&#125;var promise = Promise.resolve(config)promise = promise.then(testRequest, undefined)// axios.get().then() ⬇promise.then(() =&gt; &#123; alert(&apos;用户定义 then 方法&apos;)&#125;) axios 充分利用了 Promise 的特性，Promise 也会返回一个 Promise、Promise.resolve 的参数会传递给 then 的 fulfilled 方法，使得我们在 testRequest 中也可以得到 config，当 testRequest 成功后，再执行用户自定义的 then 方法。 接下来我们看有拦截器的情况这里我们假设 request、response拦截器各定义了两个，那么遍历每一个拦截器之后的 chain 就是这个样子的:[request成功拦截, request失败拦截, request成功拦截，request失败拦截, testRequest, undefined, response成功拦截, response失败拦截, response成功拦截, response失败拦截]之后执行 while 循环，当 chain 还有 length 时候，就会一直移除 chain 的前两个元素，并将它们作为参数执行 promise.then(元素0，元素1)chain 就会变成下面的样子：[request成功拦截，request失败拦截, testRequest, undefined, response成功拦截, response失败拦截, response成功拦截, response失败拦截][testRequest, undefined, response成功拦截, response失败拦截, response成功拦截, response失败拦截]当 while 遍历到 testRequest 则会发起请求，resolve 向下传递数据就由 config 修改为了 response。[response成功拦截, response失败拦截, response成功拦截, response失败拦截][response成功拦截, response失败拦截][]当 chain 长度为0后，就会去执行用户定义的 then 方法。 整个过程大致可以用以下代码来描述：123456789101112131415161718192021222324252627282930313233343536373839404142var config = &#123; url: &apos;test&apos; &#125; // 配置参数function testRequest (config) &#123; // 模拟请求 console.log(&apos;testRequest&apos;, config) return new Promise((resolve) =&gt; &#123; // 请求返回数据 var res = &#123; status: 200, data:&apos;I am&apos; &#125; setTimeout(() =&gt; &#123; resolve(res) &#125;,3000) &#125;)&#125;// request 拦截器的成功函数var requestInterceptorsFulfilled = function (config) &#123; console.log(&apos;原始config：&apos;, config, &apos;我会修改 config 后返回&apos;) config.url = config.url + &apos;~!~&apos; return config&#125;// response 拦截器的成功函数var responseInterceptorsFulfilled = function (response) &#123; console.log(&apos;原始response：&apos;, response, &apos;我会修改 response 后返回&apos;) response.data = response.data + &apos; OK&apos; return response&#125;// request、response错误处理var requestInterceptorsRejected = responseInterceptorsRejected = function (error) &#123; return Promise.reject(error);&#125;// 执行链var chain = [ requestInterceptorsFulfilled, requestInterceptorsRejected, requestInterceptorsFulfilled, requestInterceptorsRejected, testRequest, undefined, responseInterceptorsFulfilled, responseInterceptorsRejected, responseInterceptorsFulfilled, responseInterceptorsRejected]var promise = Promise.resolve(config)// 循环执行while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift());&#125;// 用户自定义then方法：axios.get().then() ⬇promise.then((res) =&gt; &#123; console.log(&apos;用户最终拿到的数据&apos;, res)&#125;) 我们执行这段代码，可以在 console 面板中看到输出：12345678910原始config： &#123;url: &quot;test&quot;&#125; 我会修改 config 后返回 // 此处第一个 request 拦截器对 config 进行修改原始config： &#123;url: &quot;test~!~&quot;&#125; 我会修改 config 后返回 // 此处第二个 request 拦截器对 config 进行修改testRequest &#123;url: &quot;test~!~~!~&quot;&#125; // 执行 testRequest 函数，此处会等待三秒，可以看到 config 已经被修改了两次，变为 &#123;url: &quot;test~!~~!~&quot;&#125;Promise &#123;&lt;pending&gt;&#125; // pending 状态的 Promise原始response： &#123;status: 200, data: &quot;I am&quot;&#125; 我会修改 response 后返回 // 请求返回了数据，response 拦截器对 response 进行修改原始response： &#123;status: 200, data: &quot;I am OK&quot;&#125; 我会修改 response 后返回 // 请求返回了数据，response 拦截器对 response 进行修改用户最终拿到的数据 &#123;status: 200, data: &quot;I am OK OK&quot;&#125; // 这里是用户自定义的 then 中拿到的结果 request 方法是 axios 的核心之一，初看有些懵逼，但真正看明白了，会让人直呼妙啊！妙啊！ 其他定义 getUri 方法1234Axios.prototype.getUri = function getUri(config) &#123; config = mergeConfig(this.defaults, config); return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, &apos;&apos;);&#125;; 添加 axios 支持的方法的别名这一步使得用户可以以 axios.get()、axios.post() 的方式调用。别名的定义分为两种，区别在于传参的方式不同。123456789101112131415161718192021// 添加支持的方法的别名utils.forEach([&apos;delete&apos;, &apos;get&apos;, &apos;head&apos;, &apos;options&apos;], function forEachMethodNoData(method) &#123; /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) &#123; return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url &#125;)); &#125;;&#125;);utils.forEach([&apos;post&apos;, &apos;put&apos;, &apos;patch&apos;], function forEachMethodWithData(method) &#123; /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) &#123; return this.request(utils.merge(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;);","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Axios源码1-入口文件","slug":"Axios源码1","date":"2019-07-12T12:30:41.000Z","updated":"2019-07-16T05:48:21.587Z","comments":true,"path":"2019/07/12/Axios源码1/","link":"","permalink":"http://yoursite.com/2019/07/12/Axios源码1/","excerpt":"","text":"Axios 版本 0.19.0 目录结构12345678-- lib -- adapters // 请求方法，分为浏览器与 Node.js 两个环境 -- cancel // Axios 取消请求相关 -- core // Axios 核心 -- helpers // 存放辅助函数 -- axios.js // 入口文件 -- defaults.js // Axios 默认配置 -- utils.js // 工具方法 入口文件axios 的 入口文件为 lib/axios.js:1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个 Axios 实例function createInstance(defaultConfig) &#123; var context = new Axios(defaultConfig); // 使用 bind 包装一下，以提供直接调用 axios(&#123;url: &apos;xxx&apos;, ...&#125;) 的能力 var instance = bind(Axios.prototype.request, context); // 拷贝 axios.prototype 到 instance 上 utils.extend(instance, Axios.prototype, context); // 拷贝 context 到 instance 上 utils.extend(instance, context); return instance;&#125;// 创建要导出的默认实例var axios = createInstance(defaults);// 暴露 Axios 类以允许类继承axios.Axios = Axios;// 用于创建新实例的工厂函数axios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;// 暴露 Cancel &amp; CancelTokenaxios.Cancel = require(&apos;./cancel/Cancel&apos;);axios.CancelToken = require(&apos;./cancel/CancelToken&apos;);axios.isCancel = require(&apos;./cancel/isCancel&apos;);// 暴露 all/spread 方法axios.all = function all(promises) &#123; return Promise.all(promises);&#125;;axios.spread = require(&apos;./helpers/spread&apos;);module.exports = axios;// 允许在 TypeScript 中使用默认导入语法module.exports.default = axios; 首先定一个函数 createInstance 用于创建 axios 实例：12345678function createInstance(defaultConfig) &#123; var context = new Axios(defaultConfig); // 使用 bind 包装一下，以提供直接调用 axios(&#123;url: &apos;xxx&apos;, ...&#125;) 的能力 var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;&#125; 其中使用 bind 对 axios 包装了一下，以提供 axios({url: ‘xxx’, …}) 这种方式调用的能力bind函数：123456789module.exports = function bind(fn, thisArg) &#123; return function wrap() &#123; var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i]; &#125; return fn.apply(thisArg, args); &#125;;&#125;; 调用 bind 函数进行包装，对于直接传参调用 axios 的形式会就会主动去执行 Axios.prototype.request 来发起请求。1var instance = bind(Axios.prototype.request, context); 调用 createInstance 创建实例，并在之后将其导出12345678910// 创建要导出的默认实例var axios = createInstance(defaults);// 暴露 Axios 类以允许类继承axios.Axios = Axios;// 用于创建新实例的工厂函数axios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;; 这里有两点要看，一是直接调用 createInstance 并传入 defaults 配置来创建一个 axios 实例：1var axios = createInstance(defaults); 二是定义了 axios.create 来提供自定义创建 axios 实例的能力：123axios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;; axios.create 与 axios 的区别在于 axios.create 会合并用户调用 axios.create 传入的参数与 axios 默认的参数，且不会主动执行 createInstance 方法，需用户主动执行 axios.create 才会创建实例并返回。 其他方法的暴露123456789101112131415// 暴露 Cancel &amp; CancelTokenaxios.Cancel = require(&apos;./cancel/Cancel&apos;);axios.CancelToken = require(&apos;./cancel/CancelToken&apos;);axios.isCancel = require(&apos;./cancel/isCancel&apos;);// 暴露 all/spread 方法axios.all = function all(promises) &#123; return Promise.all(promises);&#125;;axios.spread = require(&apos;./helpers/spread&apos;);module.exports = axios;// 允许在 TypeScript 中使用默认导入语法module.exports.default = axios; 其他上面有提到 axios 的默认配置，这里就先简单看一下:12345678910111213141516171819202122lib/defaults.js// code...var defaults = &#123; adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data, headers) &#123; // code... &#125;], transformResponse: [function transformResponse(data) &#123; // code... &#125;], timeout: 0, xsrfCookieName: &apos;XSRF-TOKEN&apos;, xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, maxContentLength: -1, validateStatus: function validateStatus(status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; &#125;&#125;;// code... defaults.adapter 会执行 getDefaultAdapter 函数：123456789101112function getDefaultAdapter() &#123; var adapter; // Node.js 有 process，可以依此来判断 Node.js 环境 if (typeof process !== &apos;undefined&apos; &amp;&amp; Object.prototype.toString.call(process) === &apos;[object process]&apos;) &#123; // node 使用 http adapter = require(&apos;./adapters/http&apos;); &#125; else if (typeof XMLHttpRequest !== &apos;undefined&apos;) &#123; // 浏览器使用 XHR adapter = require(&apos;./adapters/xhr&apos;); &#125; return adapter;&#125; getDefaultAdapter 函数会对环境进行判断，require 不同的请求方法，再赋值给 defaults.adapter。axios 在浏览器与 node.js 中都可以使用的原因就是在此。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"学习Vue源码13-Keep-Alive","slug":"学习Vue源码13-Keep-Alive","date":"2019-07-02T10:04:41.000Z","updated":"2019-07-03T07:00:02.188Z","comments":true,"path":"2019/07/02/学习Vue源码13-Keep-Alive/","link":"","permalink":"http://yoursite.com/2019/07/02/学习Vue源码13-Keep-Alive/","excerpt":"","text":"keep-alive组件本身就是一个组件，其代码位于 core/components/keep-alive.js 中:1234567891011121314151617181920212223242526272829export default &#123; name: &apos;keep-alive&apos;, abstract: true, props: &#123; include: patternTypes, // 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude: patternTypes, // 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max: [String, Number] // 数字。最多可以缓存多少组件实例。 &#125;, // created created () &#123; // code... &#125;, // mounted mounted () &#123; // code... &#125;, // destroyed 时销毁虽有组件 destroyed () &#123; // code... &#125;, render () &#123; // code... &#125;&#125; 首先，定义了三个 props，对应keep-alive文档 中的三个可传参数。 接下来，按着 vue 生命周期来看，由于 keep-alive 组件使用了 render 方法，则这里的生命周期为：created -&gt; render -&gt; mounted -&gt; destroyed。 created这一步比较简单，定义了一个空对象 cache，一个空数组 key 用来存放要缓存的内容：1234created () &#123; this.cache = Object.create(null) this.keys = []&#125; render接下来是 render 函数，这一步代码比较多，也是 keep-alive 的核心内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950render () &#123; const slot = this.$slots.default // 所有slots数组 // 获取 slots 中第一个有效子组件 const vnode: VNode = getFirstComponentChild(slot) const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions // vnode 的配置项 if (componentOptions) &#123; // check pattern // 组件名，没有组件名就返回 tag 名 const name: ?string = getComponentName(componentOptions) const &#123; include, exclude &#125; = this // 不在 included 或者说 在 excluded 中，则是不缓存的组件，直接返回 vnode。 if ( // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode &#125; const &#123; cache, keys &#125; = this // vnode 有 key 则赋值为 key，没 key 则赋一个 key，这个 key 用于缓存组件 const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &apos;&apos;) : vnode.key // 已缓存过，直接取缓存中的 componentInstance 给 vnode if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance // make current key freshest // 移除缓存 key，之后重新添加，使 key 保持最新 remove(keys, key) keys.push(key) // 未缓存过，添加缓存 &#125; else &#123; cache[key] = vnode keys.push(key) // prune oldest entry // 最大缓存组件 if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; // keepAlive 标记 vnode.data.keepAlive = true &#125; return vnode || (slot &amp;&amp; slot[0])&#125; 首先，获取第一个子组件，接着会检测是否存在于 included 和 excluded 中，如果不在 included 或者说在 excluded 中，则是不缓存的组件，就直接返回 vnode 渲染。 接着会定义一个 key 用于组件的缓存。 如果缓存中存在，则直接取缓存中的 componentInstance 赋给 vnode（keep-alive的第一个slot组件） 的 componentInstance，最后返回让 render 函数渲染。 如果缓存中不存在，则将其添加进缓存，并做最大缓存组件数量的处理，最后添加 keep-alive 标记，并返回 vnode。 mounted12345678910mounted () &#123; // 监听 include，变化后执行 pruneCache this.$watch(&apos;include&apos;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) // 监听 exclude，变化后执行 pruneCache this.$watch(&apos;exclude&apos;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;)&#125;, 在 mounted 中使用 $watch 分别对 include 与 exclude 两个 props 进行了监听，一旦变化则执行对应函数 pruneCache。注意：include 与 exclude 的函数参数是有区别的，一个是 name =&gt; matches(val, name) 一个是 name =&gt; !matches(val, name)。 pruneCache:遍历 cache ，这里分两种情况：一种是 include 的，当新的 include 改变，移除了某个组件，则会调用 pruneCacheEntry 函数清除该缓存。另一种是 exclude 的，当新的 exclude 改变，添加了某个忽略，则也会调用 pruneCacheEntry 函数清除该缓存。123456789101112131415161718192021222324/** * * @param &#123;any&#125; keepAliveInstance keep-alive实例 * @param &#123;Function&#125; filter 返回是否匹配上的函数 */function pruneCache (keepAliveInstance: any, filter: Function) &#123; // cache（create中创建的一个空对象） // keys（create中创建的一个空数组） // _vnode（keep-alive组件的_vnode属性） const &#123; cache, keys, _vnode &#125; = keepAliveInstance // 遍历缓存 for (const key in cache) &#123; const cachedNode: ?VNode = cache[key] if (cachedNode) &#123; // 当前遍历组件名称 const name: ?string = getComponentName(cachedNode.componentOptions) if (name &amp;&amp; !filter(name)) &#123; pruneCacheEntry(cache, key, keys, _vnode) &#125; &#125; &#125; &#125; matchesmatches 函数用来匹配 pattern 中是否有 name，有返回 true，无返回 false。1234567891011function matches (pattern: string | RegExp | Array&lt;string&gt;, name: string): boolean &#123; if (Array.isArray(pattern)) &#123; return pattern.indexOf(name) &gt; -1 &#125; else if (typeof pattern === &apos;string&apos;) &#123; return pattern.split(&apos;,&apos;).indexOf(name) &gt; -1 &#125; else if (isRegExp(pattern)) &#123; return pattern.test(name) &#125; /* istanbul ignore next */ return false&#125; pruneCacheEntry销毁实例，并从 cache 中移除12345678910111213function pruneCacheEntry ( cache: VNodeCache, key: string, keys: Array&lt;string&gt;, current?: VNode) &#123; const cached = cache[key] if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123; cached.componentInstance.$destroy() &#125; cache[key] = null remove(keys, key)&#125; destoryed最后是 destoryed，这个没啥说的，keep-alive 组件销毁的时候，清空所有缓存过的内容，完事。12345destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache, key, this.keys) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Koa源码2","slug":"Koa-2","date":"2019-05-16T06:24:37.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2019/05/16/Koa-2/","link":"","permalink":"http://yoursite.com/2019/05/16/Koa-2/","excerpt":"","text":"compose处理中间件上篇说到在 this.handleRequest(ctx, fn) 中的这一句 fnMiddleware(ctx).then(handleResponse).catch(onerror)，这里使用了 Promise.resolve() 依次执行各中间件，最后执行.then()，结束请求。我们向上寻找，可以发现 fnMiddleware 就是 compose(this.middleware) 的结果，compose 函数来自 koa-compose 这个库，在 node_modules 中找到它：1234567891011121314151617181920212223242526272829303132333435363738function compose (middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;) for (const fn of middleware) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;) &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] // 当前中间件 if (i === middleware.length) fn = next // 没有中间件了，返回一个没有参数的 Promise.resolve() 就会调用 .then() if (!fn) return Promise.resolve() try &#123; /** * 使用 Promise.resolve 可以依次执行当前中间件，第二个参数 dispatch.bind(null, i + 1) 它就是我们定义中间件时的 next 参数： * app.use(async (ctx, next) =&gt; &#123; * next(); * &#125;); * 这也是中间件不调用 next() 下一个中间件绝不会执行的原因 */ return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 这里主要利用了 Promise.resolve 的参数如果还是一个 Promise，Promise.resolve 会将参数原封不动的 resolve 下去这一点实现中间件的顺序执行。我这里把代码简化一下：12345678910111213141516171819202122232425262728// 中间件var middleware = [ (ctx, next) =&gt; &#123; console.log(1); next() &#125;, (ctx, next) =&gt; &#123; console.log(2); next() &#125;, (ctx, next) =&gt; &#123; console.log(3) &#125;]var ctx = &#123;&#125; // 模拟 ctx 这里直接给个空对象var index = 0 // 起始下标function run(ctx) &#123; return dispatch(0) function dispatch(i) &#123; index = i var fn = middleware[i] // 当前要执行的中间件 // 没有中间件了，返回一个没有参数的 Promise.resolve() 就会调用 .then() if (!fn) return Promise.resolve() // dispatch.bind(null, i + 1) = 中间件的 next 参数 = 下一个中间件 return Promise.resolve( fn(ctx, dispatch.bind(null, i + 1)) ) &#125;&#125;run(ctx).then(() =&gt; &#123; console.log(&apos;res.end()&apos;)&#125;).catch(err =&gt; &#123; console.error(err)&#125;) Promise.resolve 的参数是当前要执行的中间件，中间件有两个参数 ctx 与 dispatch.bind(null, i + 1)，这个 dispatch 被调用后就会执行下一个中间件（我们在编写中间件时调用的 next() 就是这个玩意儿），并返回一个Promise.resolve。这样最开始的 Promise.resolve 的参数就是一个 Promise，而这个 Promise 的参数还会是一个 Promise（有多少 middleware 就重复多少次），就可以将所有的 middleware 全部执行完。 这里我再把代码简化一下：1234567891011121314var middleware = [() =&gt; console.log(1), () =&gt; console.log(2), () =&gt; console.log(3)] // 中间件var index = 0 // 起始下标function run() &#123; var fn = middleware[index] // 当前要执行的中间件 index++ // 没有中间件了，返回一个没有参数的 Promise.resolve() 就会调用 .then() if (!fn) return Promise.resolve() return Promise.resolve(run(fn()))&#125;run().then(function () &#123; console.log(&apos;End&apos;)&#125;) 这样看就更简单明了了。 context.js1234567891011121314151617181920const proto = module.exports = &#123; inspect() &#123;&#125;, // util.inspect() implementation, which just returns the JSON output. toJSON() &#123;&#125;, // Return JSON representation. assert: httpAssert, // http 断言，与 node 的 assert() 方法类似. throw() &#123;&#125;, // 引用了 http-errors 库，用于抛错 onerror() &#123;&#125;, // 默认的错误处理 get cookies() &#123; if (!this[COOKIES]) &#123; this[COOKIES] = new Cookies(this.req, this.res, &#123; keys: this.app.keys, secure: this.request.secure &#125;); &#125; return this[COOKIES]; &#125;, set cookies(_cookies) &#123; this[COOKIES] = _cookies; &#125;&#125; context.js 主要定义了几个方法（省略了具体代码），这些方法都可以通过 ctx.xxxx 调用，context 主要还是用来挂载 request、response 等对象的。 request.js 与 response.js这两个文件结构一样，都是一些 getter、setter 函数，这些方法同样被挂载到了 ctx 上，包括下面一些： Request 别名以下访问器和 Request 别名等效：12345678910111213141516171819202122232425262728293031ctx.headerctx.headersctx.methodctx.method=ctx.urlctx.url=ctx.originalUrlctx.originctx.hrefctx.pathctx.path=ctx.queryctx.query=ctx.querystringctx.querystring=ctx.hostctx.hostnamectx.freshctx.stalectx.socketctx.protocolctx.securectx.ipctx.ipsctx.subdomainsctx.is()ctx.accepts()ctx.acceptsEncodings()ctx.acceptsCharsets()ctx.acceptsLanguages()ctx.get() Response 别名以下访问器和 Response 别名等效：123456789101112131415161718ctx.bodyctx.body=ctx.statusctx.status=ctx.messagectx.message=ctx.length=ctx.lengthctx.type=ctx.typectx.headerSentctx.redirect()ctx.attachment()ctx.set()ctx.append()ctx.remove()ctx.lastModified=ctx.etag= END引用 https://koa.bootcss.com","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[]},{"title":"Koa源码1","slug":"Koa-1","date":"2019-05-15T08:50:34.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2019/05/15/Koa-1/","link":"","permalink":"http://yoursite.com/2019/05/15/Koa-1/","excerpt":"","text":"前言再开一坑，学习一下Koa的源码，好在Koa的源码不长且易读，这个坑应该很快能填上。Koa的版本为 2.7.0 Koa的使用 安装 Node 环境（Koa 依赖 node v7.6.0 或 ES2015及更高版本和 async 方法支持） 安装 Koa： npm i koa 创建如下 app.js 文件并运行：node app.js123456789// app.jsconst Koa = require(&apos;koa&apos;);const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000) 打开浏览器访问 localhost:3000，将会看到 ‘Hello World’. 入口文件application.js了解了最简单的使用，现在开始分析。从 koa 的 package.json 文件中可以看到其主入口是 “main”: “lib/application.js”application.js 暴露出一个 class Application，这个 Application 就是 koa，它继承了 events，让 koa 可以监听与触发事件。 我们以上面的 app.js 为例，开始分析： new Koa()1234567891011121314151617module.exports = class Application extends Emitter &#123; constructor() &#123; super(); // 属性定义 this.proxy = false; this.middleware = []; // 存放所有 use 的中间件 this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; // 其他三个文件，导出的都是 Object this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125;&#125; 这一步比较简单，定义了一些属性，将 context、request、response 分别挂在 this.context、this.request、this.response上。 app.use()1234567891011121314use(fn) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); // 中间件必须为函数 // 检查是否是 generator 函数，如果是则会给出提示：将会在 3.x 版本移除对 generator 函数的支持 if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); // 将中间件函数 push 到 this.middleware中 this.middleware.push(fn); return this;&#125; use 也比较简单，它对入参 fn 做了限制，如果 fn 是 generator 函数的话，会经过 convert() 的转换，最后 push 到 this.middleware 中。 app.listen(3000);12345listen(...args) &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen(...args);&#125; 使用 http.createServer 创建 Node 服务，其参数为 this.callback()，下面看下 this.callback 都写了什么： this.callback12345678910111213callback() &#123; // compose 会使用 Promise.resolve 处理各个中间件，最后返回一个函数，这个函数再依次执行中间件时会用到。 const fn = compose(this.middleware); if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror); // 定义handleRequest 👇 const handleRequest = (req, res) =&gt; &#123; // ctx const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; // 👆 return handleRequest;&#125; 定义 handleRequest 并返回，在 handleRequest 中 定义 ctx，又执行并返回 this.handleRequest(ctx, fn)，所以 const handleRequest = (req, res) =&gt; { // code… } 才是 http.createServer 的参数。 之后 server.listen(…args) 启动了服务，当我们收到服务之后 👇 this.createContext - 创建ctx12345678910111213141516createContext(req, res) &#123; // 参数 req、res 是 http.createServer 中得到的 req、res // context 是一个Object，request与response会挂载在它上面 const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; // 将它们的 app 属性全部指向 this context.req = request.req = response.req = req; // 挂载原始的 req 在各自 req 属性上 context.res = request.res = response.res = res; // 挂载原始的 res 在各自 res 属性上 request.ctx = response.ctx = context; // 挂载 response 到 request、response 的 ctx 属性上 request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; // 挂载请求的 url context.state = &#123;&#125;; // state return context; // 返回&#125; createContext 创建了 context，并在 context、request、response 上挂载了各种属性，同时又将 request、response 挂载在 context 上，最后返回。 this.handleRequest(ctx, fn)123456789101112handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; // 错误处理 const onerror = err =&gt; ctx.onerror(err); // 处理 response const handleResponse = () =&gt; respond(ctx); // 当HTTP请求关闭、完成或发生错误时执行 onerror 回调 onFinished(res, onerror); // 使用 Promise.resolve() 依次执行中间件，所有中间件执行完成，则会调用 respond(ctx) 自动帮我们 res.end() return fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125; 主要看这句 fnMiddleware(ctx).then(handleResponse).catch(onerror)，这里使用 Promise.resolve() 依次执行各中间件，最后执行.then()，结束请求。","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[]},{"title":"学习Vue源码12-Vue中的watch与computed","slug":"学习Vue源码12-Vue中的watch与computed","date":"2019-05-14T07:04:41.000Z","updated":"2019-06-26T07:51:50.000Z","comments":true,"path":"2019/05/14/学习Vue源码12-Vue中的watch与computed/","link":"","permalink":"http://yoursite.com/2019/05/14/学习Vue源码12-Vue中的watch与computed/","excerpt":"","text":"Vue 的 _init() 方法调用了 initState 方法：1234567891011121314core\\instance\\state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // code... 省略代码 // 处理computed if (opts.computed) initComputed(vm, opts.computed) // 处理watch if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 先看watch： Watch12345678910111213141516171819202122232425262728293031core\\instance\\state.jsfunction initWatch (vm: Component, watch: Object) &#123; // 遍历 options.watch 参数 // 调用 createWatcher for (const key in watch) &#123; const handler = watch[key] if (Array.isArray(handler)) &#123; for (let i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]) &#125; &#125; else &#123; createWatcher(vm, key, handler) &#125; &#125;&#125;function createWatcher ( vm: Component, expOrFn: string | Function, handler: any, options?: Object) &#123; if (isPlainObject(handler)) &#123; options = handler handler = handler.handler &#125; if (typeof handler === &apos;string&apos;) &#123; handler = vm[handler] &#125; return vm.$watch(expOrFn, handler, options)&#125; createWatcher 会调用 vm.$watch(expOrFn, handler, options) vm.$watch 是在 core\\instance\\index.js 调用 stateMixin(Vue) 时定义的 1234567891011121314151617181920212223242526Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true // 实例化了一个 Watcher const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value) &#125; catch (error) &#123; handleError(error, vm, `callback for immediate watcher &quot;$&#123;watcher.expression&#125;&quot;`) &#125; &#125; // 返回 unwatchFn return function unwatchFn () &#123; watcher.teardown() &#125;&#125; Vue.prototype.$watch 中实例化了一个 Watcher，返回了一个 unwatchFn 函数，调用它可以卸载该 watch。 接下来我们转到 Watcher ，这一块的代码有些多，我会省略大部分代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102core\\observer\\watcher.jsexport default class Watcher &#123; // code... 省略代码 constructor (vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) &#123; this.vm = vm // 如果是渲染的 Watcher ，vm._watcher 指向当前 this if (isRenderWatcher) &#123; vm._watcher = this &#125; // 向 vm._watchers push this vm._watchers.push(this) // 这是 watch 的配置项 if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync this.before = options.before &#125; else &#123; // watch 没配置项，给默认配置 this.deep = this.user = this.lazy = this.sync = false &#125; // 一系列初始化 this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== &apos;production&apos; ? expOrFn.toString() : &apos;&apos; // parse expression for getter if (typeof expOrFn === &apos;function&apos;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` + &apos;Watcher only accepts simple dot-delimited paths. &apos; + &apos;For full control, use a function instead.&apos;, vm ) &#125; &#125; this.value = this.lazy ? undefined : this.get() // 调用 this.get() &#125; /** * Evaluate the getter, and re-collect dependencies. */ get () &#123; // 👇 pushTarget(this)，将 Dep.target 赋值为 this pushTarget(this) let value const vm = this.vm try &#123; // 要 watch 的获取值 value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; // 👇 清空 Dep.target popTarget() // 清空依赖 this.cleanupDeps() &#125; return value &#125; // 👇 以下代码全部省略 addDep (dep: Dep) &#123;&#125; // 向此指令添加依赖项 cleanupDeps () &#123;&#125; // 清理依赖集合 update () &#123;&#125; // 在依赖变更时调用 run () &#123;&#125; evaluate () &#123;&#125; depend () &#123;&#125; teardown () &#123;&#125; // 移除 watch&#125; 这里调用 pushTarget(this)，将 Dep.target 赋值为 this ，这样做的目的是可以将 当前 Watcher 添加到 Dep 的订阅列表中我们回过头看 defineReactive 函数的其中一段：123456789101112131415161718192021222324// 使用 Object.defineProperty 对数据进行监听Object.defineProperty(obj, key, &#123; enumerable: true, // 可枚举 configurable: true, // 可配置 get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 这个Dep.target是用于添加 Watcher 的，正常情况下它的值为 null if (Dep.target) &#123; 👈👈👈👈👈👈👈 // 添加 Watcher 相关 dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; // 返回对应值 return value &#125;, set: function reactiveSetter (newVal) &#123; // code... 代码省略 &#125;&#125;) 通过 defineReactive 函数，我们劫持了数据，Watcher 的 get 方法会去获取劫持过的数据，获取数据就会触发 get，上面手指所指的地方，当 Dep 存在静态属性 target 的时候，就成功的向 Dep 添加了 Watcher，一旦数据改变，就会触发用户定义好的回调。 接着看 computed： Computed第一部分代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556core\\instance\\state.js// 初始化 computedconst computedWatcherOptions = &#123; lazy: true &#125;function initComputed (vm: Component, computed: Object) &#123; // watchers = vm._computedWatchers = 空对象 const watchers = vm._computedWatchers = Object.create(null) // computed properties are just getters during SSR const isSSR = isServerRendering() // 遍历 computed for (const key in computed) &#123; const userDef = computed[key] // 如果定义的 computed 是函数，则获取函数，如果是 getter、setter 形式，则获取 get函数 const getter = typeof userDef === &apos;function&apos; ? userDef : userDef.get if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; getter == null) &#123; warn( `Getter is missing for computed property &quot;$&#123;key&#125;&quot;.`, vm ) &#125; // 非服务端渲染下 赋值 watchers[key] 为 Watcher // 比如赋值后 watchers 变为 &#123; &apos;computedName&apos;: new Watcher(args) &#125; if (!isSSR) &#123; // create internal watcher for the computed property. // 为 computed 属性定义 Watcher ------------------------------------ 标注一 ------------------------------------ watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions // &#123; lazy: true &#125; ) &#125; // component-defined computed properties are already defined on the // component prototype. We only need to define computed properties defined // at instantiation here. // 定义过重名的（data、props中），则报错，没有重名则调用 defineComputed if (!(key in vm)) &#123; defineComputed(vm, key, userDef) &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123; if (key in vm.$data) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined in data.`, vm) &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn(`The computed property &quot;$&#123;key&#125;&quot; is already defined as a prop.`, vm) &#125; &#125; &#125;&#125; 这里以一个最简单的例子来说明：12345computed: &#123; fullName: function () &#123; return this.firstName + this.lastName &#125;&#125; 首先：const getter = typeof userDef === ‘function’ ? userDef : userDef.getgetter 其实就是我们定义的 computed 函数:123function () &#123; return this.firstName + this.lastName&#125; 然后看标注一的位置，这里 new 了一个 Watcher123456watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions // &#123; lazy: true &#125;) 这里只 new Watcher()，Watcher 内部的方法都不会被调用。 之后调用了 defineComputed 方法，我们接着看第二部分代码： 第二部分代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: noop, set: noop&#125;function createComputedGetter (key) &#123; return function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key] if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate() &#125; if (Dep.target) &#123; watcher.depend() &#125; return watcher.value &#125; &#125;&#125;function createGetterInvoker(fn) &#123; return function computedGetter () &#123; return fn.call(this, this) &#125;&#125;export function defineComputed ( target: any, key: string, userDef: Object | Function) &#123; const shouldCache = !isServerRendering() // isServerRendering() 我们直接认为是 false，所以 shouldCache = true // 修改 sharedPropertyDefinition 的getter/setter // 之后会用 Object.defineProperty 劫持 computed 数据 // 获取数据的时候，走 getter 函数，getter 函数会处理我们定义的 computed 函数，并返回结果 // 函数形式的 computed if (typeof userDef === &apos;function&apos;) &#123; ------------------------------------ 标注二 ------------------------------------ sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef) sharedPropertyDefinition.set = noop // getter / setter 形式的 computed &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop sharedPropertyDefinition.set = userDef.set || noop &#125; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( `Computed property &quot;$&#123;key&#125;&quot; was assigned to but it has no setter.`, this ) &#125; &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125; 我们看标注二，这里我们默认只考虑浏览器环境，所以：123456789101112131415161718192021222324252627// 假设 key = &apos;fullName&apos;sharedPropertyDefinition.get = createComputedGetter(fullName)]// =&gt; 等同于sharedPropertyDefinition = &#123; enumerable: true, configurable: true, get: function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[&apos;fullName&apos;] if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate() &#125; if (Dep.target) &#123; ------------------------------------ 标注四 ------------------------------------ watcher.depend() &#125; return watcher.value &#125; &#125;, set: noop&#125;// 然后使用 Object.defineProperty 对 fullName 进行劫持Object.defineProperty(target, key, sharedPropertyDefinition) 当我们使用 computed 时，就触发了他的 get 方法，然后会调用前面定义的 Watcher 的 evaluate 方法。evaluate 方法会调用 Watcher 的 get，然后我们转到 Watcher 中看 get 方法： 12345678910111213141516171819202122232425262728core\\observer\\watcher.js// Watcher 的 get 方法会被调用get () &#123; // 👇 pushTarget(this)，将 Dep.target 赋值为 this（当前Watcher） pushTarget(this) let value const vm = this.vm try &#123; // 要 watch 的获取值 ------------------------------------ 标注三 ------------------------------------ value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; else &#123; throw e &#125; &#125; finally &#123; if (this.deep) &#123; traverse(value) &#125; // 👇 清空 Dep.target popTarget() // 清空依赖 this.cleanupDeps() &#125; return value&#125; get 方法首先将 Dep.target 指向当前 Watcher接着标注三的位置调用了 this.getter.call(vm, vm)，也就是 return this.firstName + this.lastName。然后触发了 firstName 与 lastName 的 getter，将当前 Watcher 添加到 这两个 data 的订阅者列表中，如果 firstName 与 lastName 发生变化都会调用当前 Watcher 的 update 方法。同时也算出了 value 值。Watcher 的 update 方法被调用，就会触发 get 方法，获取最新的值，算出最新的 value。 最后 return watcher.value END TIPS: 这里如果不清楚如何订阅者列表可以去看这篇","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码11-Vue中的props与data","slug":"学习Vue源码11-Vue中的props与data","date":"2019-05-14T06:48:02.000Z","updated":"2019-06-26T07:51:50.000Z","comments":true,"path":"2019/05/14/学习Vue源码11-Vue中的props与data/","link":"","permalink":"http://yoursite.com/2019/05/14/学习Vue源码11-Vue中的props与data/","excerpt":"","text":"Vue 的 _init() 方法调用了 initState 方法：12345678910111213141516171819core\\instance\\state.jsexport function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 处理props if (opts.props) initProps(vm, opts.props) // code... 省略代码 if (opts.data) &#123; // 存在data处理data initData(vm) &#125; else &#123; // 不存在data默认data为&#123;&#125; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // code... 省略代码&#125; Props看initProps方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function initProps (vm: Component, propsOptions: Object) &#123; const propsData = vm.$options.propsData || &#123;&#125; const props = vm._props = &#123;&#125; // cache prop keys so that future props updates can iterate using Array instead of dynamic object key enumeration. // 缓存一下prop，以后会用到 const keys = vm.$options._propKeys = [] const isRoot = !vm.$parent // root instance props should be converted // 当前实例是根实例应该转换一下 if (!isRoot) &#123; toggleObserving(false) &#125; for (const key in propsOptions) &#123; keys.push(key) const value = validateProp(key, propsOptions, propsData, vm) /* 下面这一大段最终都会调用 defineReactive 方法 */ // 👇 /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos;) &#123; const hyphenatedKey = hyphenate(key) if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( `&quot;$&#123;hyphenatedKey&#125;&quot; is a reserved attribute and cannot be used as component prop.`, vm ) &#125; defineReactive(props, key, value, () =&gt; &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( `Avoid mutating a prop directly since the value will be ` + `overwritten whenever the parent component re-renders. ` + `Instead, use a data or computed property based on the prop&apos;s ` + `value. Prop being mutated: &quot;$&#123;key&#125;&quot;`, vm ) &#125; &#125;) &#125; else &#123; defineReactive(props, key, value) &#125; // static props are already proxied on the component&apos;s prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. // 静态props在 Vue.extend() 时已经代理到组件的 prototype上了。我们只需要在实例化时，在这里代理 props 定义 if (!(key in vm)) &#123; proxy(vm, `_props`, key) &#125; &#125; toggleObserving(true)&#125; initProps 处理 props 参数，再循环调用 defineReactive(props, key, value)添加监听。 defineReactive:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273core\\observer\\index.jsexport function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() // 获取 obj.key 的属性描述 const property = Object.getOwnPropertyDescriptor(obj, key) // 没有属性描述直接返回 if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters // 属性描述的 getter/setter（定义了则可以获取到） const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) // 使用 Object.defineProperty 对数据进行监听 Object.defineProperty(obj, key, &#123; enumerable: true, // 可枚举 configurable: true, // 可配置 get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 这个Dep.target是用于添加 Watcher 的，正常情况下它的值为 null if (Dep.target) &#123; // 添加 Watcher 相关 dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; // 返回对应值 return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ // 设置的新旧值一样，return if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter // 访问器属性没有 setter 也 return if (getter &amp;&amp; !setter) return // 有 setter 则调用它 if (setter) &#123; setter.call(obj, newVal) &#125; // 没有 setter 直接赋值 else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) // 值修改后通知所有 Watcher dep.notify() &#125; &#125;)&#125; Data接下来看 initData：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647core\\instance\\state.jsfunction initData (vm: Component) &#123; let data = vm.$options.data // 这里判断 data 是不是函数，如果是函数则需要通过 getData() 方法来获得 对象data（至于为什么存在 data 为函数的情况，Vue官方教程有提） data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; // 使用 Object.prototype.toString 来判断 data 不是一个 obj，不是则打出警告，data = &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( &apos;data functions should return an object:\\n&apos; + &apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) // 拿到键名 const props = vm.$options.props // props const methods = vm.$options.methods // 方法 let i = keys.length while (i--) &#123; const key = keys[i] // 方法与 data 重名提示 if (process.env.NODE_ENV !== &apos;production&apos;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm ) &#125; &#125; // props 与 data 重名提示 if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // 开始观察数据 observe(data, true /* asRootData */) 👈&#125; observe 函数中 实例化了 new Observer()123456789101112131415161718192021222324252627282930313233343536373839404142core\\observer\\index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 // 给value定义&apos;__ob__&apos;属性，值为this def(value, &apos;__ob__&apos;, this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; // 遍历 value 所有的属性，每一个都调用 defineReactive 函数（这个方法仅在 value 是 Object 时调用） walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; // 观察数组元素 observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; defineReactive 函数在 Props 中已经分析过了，这里不再提了。 可以回过头看下第四篇：学习Vue源码4第四篇内容和本篇的很多是类似的，只不过第四篇是一个超简化版Vue基本原理，看那一篇会比较清晰。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码10-Vue事件机制","slug":"学习Vue源码10-Vue事件机制","date":"2019-05-14T02:26:53.000Z","updated":"2019-06-26T07:51:50.000Z","comments":true,"path":"2019/05/14/学习Vue源码10-Vue事件机制/","link":"","permalink":"http://yoursite.com/2019/05/14/学习Vue源码10-Vue事件机制/","excerpt":"","text":"这一篇来了解一下Vue的事件机制core\\instance\\index.js1234567891011function Vue (options) &#123; this._init(options)&#125;initMixin(Vue) // 初始化混入stateMixin(Vue)eventsMixin(Vue) // 混入 Vue.prototype.$on 、$once、$off、$emit方法lifecycleMixin(Vue)renderMixin(Vue)export default Vue 自定义事件用法见自定义事件文档 在this._init()方法中调用了initEvents(vm)初始化了Events；12345678910111213core\\instance\\events.js// 初始化事件export function initEvents (vm: Component) &#123; // 创建vm._events，它是一个空对象，用来存放事件 vm._events = Object.create(null) // 是否存在事件钩子，初始为false vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners // 这个是父组件上添加的事件监听，HTML上的事件不走这里 if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; vm._events，它是一个空对象，用来存放自定义事件后面经过$on方法之后vm._event会变成这个样子：1234vm._events = &#123; eventName1: [fna1, fna2], eventName2: [fnb1, fnb2]&#125; eventsMixin()方法，在Vue.prototype上定义了 $on 、$once、$off、$emit 四个方法；$on定义事件12345678910111213141516171819const hookRE = /^hook:/Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; // 如果 vm._events 中定义过这个事件，就直接把回调 &apos;fn&apos; push进去 // 没定义过这个事件就把 vm._events[event] 赋值为 []，在把 &apos;fn&apos; push进去 (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125; $once使用该方法定义的事件只会触发一次1234567891011Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on () &#123; vm.$off(event, on) fn.apply(vm, arguments) &#125; on.fn = fn // 该事件只要执行过一次，就会执行 on 回调函数，销毁该事件 vm.$on(event, on) return vm&#125; $off移除定义的事件123456789101112131415161718192021222324252627282930313233343536Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // all if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // event参数是个数组，循环，依次调用$off if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$off(event[i], fn) &#125; return vm &#125; // cbs 就是我们要 off 的事件 const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; // 没有fn传入，则直接销毁对应&apos;全部&apos;event，然后返回vm if (!fn) &#123; vm._events[event] = null return vm &#125; // 这里处理要销毁指定函数的情况 let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; return vm&#125; $emit12345678910111213141516171819202122232425262728Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this if (process.env.NODE_ENV !== &apos;production&apos;) &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event &quot;$&#123;lowerCaseEvent&#125;&quot; is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for &quot;$&#123;event&#125;&quot;. ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use &quot;$&#123;hyphenate(event)&#125;&quot; instead of &quot;$&#123;event&#125;&quot;.` ) &#125; &#125; // 在 vm._events 中寻找有没有对应的事件 let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs // 截掉第一个event参数，保留其他参数 const args = toArray(arguments, 1) const info = `event handler for &quot;$&#123;event&#125;&quot;` for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; // 带有错误处理的调用 invokeWithErrorHandling(cbs[i], vm, args, vm, info) &#125; &#125; return vm&#125; 另外core\\instance\\state.js 中 initState内根据参数会调用 initProps、initMethods、initData、initComputed、initWatch方法initMethods将每一个方法绑定在vm上，故可以以this.methodName()来调用methods{}中的方法 Vue中的事件可以分为两种，一类是绑定在DOM上的，另一类是绑定在组件上的自定义事件： HTML事件事件在何时进行绑定呢？当然是在 vm.$mount 方法调用之后的方法中 看下面一段代码：123456789var vm = new Vue(&#123; el:&apos;.arrow&apos;, data:&#123;a:1&#125;, template: &apos;&lt;div @click=&quot;b&quot;&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt;&apos;, methods: &#123; b: function() &#123; alert(1) &#125; &#125;&#125;)console.log(vm.$options.render) 我们得到：1234ƒ anonymous() &#123;with(this)&#123;return _c(&apos;div&apos;,&#123;on:&#123;&quot;click&quot;:b&#125;&#125;,[_v(_s(a))])&#125;&#125; 在render函数中可以看到 {on:{“click”:b}} 是_c的参数，在之前的文章我有提到 _c 其实就是 createElement 这个方法 执行 render 函数返回VNode Tree，对应的事件在 data 参数里，事件的绑定和代码运行环境有关（浏览器 和 Weex） 浏览器环境下：platforms\\web\\runtime\\modules\\events.js123456789101112131415161718192021222324252627282930function add ( // 添加事件 name: string, handler: Function, capture: boolean, passive: boolean) &#123; // code... 部分代码省略 target.addEventListener( name, handler, supportsPassive ? &#123; capture, passive &#125; : capture )&#125;function remove ( // 移除事件 name: string, handler: Function, capture: boolean, _target?: HTMLElement) &#123; (_target || target).removeEventListener( name, handler._wrapper || handler, capture )&#125; 然后暴露 updateDOMListeners 来处理 vNode 变动之后的事件的变化：12345678910111213function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) &#123; // 新老vNode都没有data.on，return if (isUndef(oldVnode.data.on) &amp;&amp; isUndef(vnode.data.on)) &#123; return &#125; const on = vnode.data.on || &#123;&#125; const oldOn = oldVnode.data.on || &#123;&#125; target = vnode.elm normalizeEvents(on) // 更新事件 updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context) target = undefined&#125; component自定义事件关于组件的自定义事件，我们看下面的代码：12345678910111213141516171819202122232425262728var vm = new Vue(&#123; el: &apos;#logo&apos;, template: &quot;&lt;div&gt;Father Text &lt;test @show=&apos;fn&apos;&gt;&lt;/test&gt;&lt;/div&gt;&quot;, data: &#123; &#125;, methods: &#123; fn: function () &#123; alert(&apos;Father Method&apos;) &#125; &#125;, components: &#123; &apos;test&apos;: &#123; template: &quot;&lt;div @click=&apos;cfn&apos;&gt;Child Text&lt;/div&gt;&quot;, mounted() &#123; this.$on(&apos;show&apos;, () =&gt; &#123; alert(&apos;XXX&apos;) &#125;) &#125;, methods: &#123; cfn: function () &#123; // console.log(this._events.show[0]) // createFnInvoker console.log(&apos;Child Method&apos;) this.$emit(&apos;show&apos;) &#125; &#125;, &#125; &#125;&#125;)console.log(vm.$options.render) 组件的render函数是这样的：1234ƒ anonymous() &#123;with(this)&#123;return _c(&apos;div&apos;,[_v(&quot;Father Text &quot;),_c(&apos;test&apos;,&#123;on:&#123;&quot;show&quot;:fn&#125;&#125;)],1)&#125;&#125; 如果是组件的情况下，_createElement会调用 createComponent(Ctor, data, context, children, tag) 来创建组件（事件参数在data里）看下createComponent方法：123456789101112131415161718192021222324252627282930313233core\\vdom\\create-component.jsexport function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; // code... 省略代码 // extract listeners, since these needs to be treated as child component listeners instead of DOM listeners // 提取data参数里的事件(data.on)，这些事件会被作为为子组件事件侦听而不是DOM侦听。 const listeners = data.on // replace with listeners with .native modifier so it gets processed during parent component patch. // data大概长这样&#123;on: &#123;&apos;click&apos;: fn1&#125;, nativeOn: &#123;&apos;click&apos;: fn2&#125;&#125; // data.nativeOn内存放 在组件上绑定了具有.native修饰符的事件，这些事件最终会被绑定在DOM上，其他的事件仍然走Vue自定义事件那一套。 data.on = data.nativeOn // 这里用 listeners 缓存了原有的 data.on ，再用 data.nativeOn 来覆盖 原有data.on // code... 省略代码 // 实例化一个VNode，返回 const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) // code... 省略代码 return vnode&#125; 如果绑定在组件上的事件又.native修饰符，该事件最终会绑定在DOM上我们回到 core\\instance\\events.js 文件，看 initEvents 方法12345678910111213141516171819// 初始化事件export function initEvents (vm: Component) &#123; // 创建vm._events，它是一个空对象，用来存放事件，之后会变为这个样子 // vm._events = &#123; // eventName1: [fna1, fna2], // eventName2: [fnb1, fnb2] // &#125; vm._events = Object.create(null) // 是否存在事件钩子，初始为false vm._hasHookEvent = false // init parent attached events 👇 // 这个 listeners 是父组件上添加的事件监听，HTML上的事件不走这里，大概长这样 &#123;&apos;eventName&apos;, fn&#125; const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125; 👆&#125; 箭头所指这一段代码，说明绑定在组件上的自定义事件会交由 updateComponentListeners 方法处理：12345678910111213141516171819core\\instance\\events.jsfunction add (event, fn) &#123; target.$on(event, fn)&#125;function remove (event, fn) &#123; target.$off(event, fn)&#125;export function updateComponentListeners ( vm: Component, listeners: Object, oldListeners: ?Object) &#123; target = vm updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, createOnceHandler, vm) target = undefined&#125; updateComponentListeners 调用了 updateListeners。好吧，再跳转到 updateListeners 方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950core\\vdom\\helpers\\update-listeners.jsexport function updateListeners ( on: Object, oldOn: Object, add: Function, remove: Function, createOnceHandler: Function, vm: Component) &#123; let name, def, cur, old, event // 遍历on for (name in on) &#123; def = cur = on[name] old = oldOn[name] event = normalizeEvent(name) /* istanbul ignore if WEEX的处理 */ if (__WEEX__ &amp;&amp; isPlainObject(def)) &#123; cur = def.handler event.params = def.params &#125; // 事件不存在会在非生产模式下报警告 if (isUndef(cur)) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Invalid handler for event &quot;$&#123;event.name&#125;&quot;: got ` + String(cur), vm ) &#125; else if (isUndef(old)) &#123; if (isUndef(cur.fns)) &#123; cur = on[name] = createFnInvoker(cur, vm) &#125; // 处理只触发一次的自定义事件 if (isTrue(event.once)) &#123; cur = on[name] = createOnceHandler(event.name, cur, event.capture) &#125; // 添加事件 add(event.name, cur, event.capture, event.passive, event.params) &#125; else if (cur !== old) &#123; old.fns = cur on[name] = old &#125; &#125; // 遍历oldOn，移除on中已经移除的事件 for (name in oldOn) &#123; if (isUndef(on[name])) &#123; event = normalizeEvent(name) remove(event.name, oldOn[name], event.capture) &#125; &#125;&#125; updateListeners 主要是两个 for in 循环，分别循环了 on 与 oldOn，遍历 on 来添加自定义事件，遍历 oldOn 来移除已经删掉的事件。 Vue的事件机制到这里就差不多分析完了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"HTTP2","slug":"HTTP2","date":"2019-05-10T05:49:12.000Z","updated":"2019-06-26T07:51:49.995Z","comments":true,"path":"2019/05/10/HTTP2/","link":"","permalink":"http://yoursite.com/2019/05/10/HTTP2/","excerpt":"","text":"HTTPHTTP协议（超文本传输协议）是因特网上应用最广泛的一种网络传输协议，它基于TCP/IP协议来传递数据，它是无连接、无状态的，不会在两个请求之间记录任何状态，而且它可以发送任何类型的数据。 目前使用最广泛的版本是HTTP/1.1 HTTP大致存在的问题： 使用明文传输数据。 HTTP请求头臃肿，且没有什么好的压缩方案。 被限制的最大TCP连接数量。对同一域名浏览器限制了最大TCP连接数量，通常来说是6个(不同浏览器有不同的限制)。 排头阻塞(Head-of-line blocking)HTTP协议早期，我们发送一个请求，服务器收到并做出响应后才会进行下一个请求，这样十分没有效率。后来在HTTP/1.1中提出了管线化(pipelining)技术，允许一次性发送多个请求。然而管线化技术在接收response时需要按照请求发出的顺序依次接收服务器响应。如果这一组请求中一旦有请求阻塞了，后面的所有请求都会进入等待状态，这也是浏览器限制最大TCP连接数的原因。 HTTPSHTTPS是在HTTP的基础上增加了SSL/TLS层，网站开发者可以向CA购买证书，再进行相应配置即可将网站升级成HTTPS。之后数据都会通过非对称加密的形式传输，客户端可通过向CA机构查询以确保自己所访问的页面的正确。 HTTP2HTTP2基于SPDY（2012年谷歌提出）设计，HTTP2主要有以下新特性： 二进制数据传输 多路复用对于同一个域名下的多个请求，只需开启一个TCP连接，然后以流标识符标识数据属于哪一个请求，不断向客户端推数据，客户端接收后即可根据流标识符来组成不同请求的完整数据。有了多路复用浏览器对于最大同时TCP连接数也就没了意义，同时之前的一些优化手段也可以不用使用了（如：雪碧图，可以尽情使用小图了）。 服务端推送浏览器发送一个请求，服务器可以主动向浏览器推送与这个请求相关资源，浏览器就不用发起后续请求了。 请求Header压缩使用HPACK算法压缩头部内容","categories":[{"name":"协议","slug":"协议","permalink":"http://yoursite.com/categories/协议/"}],"tags":[]},{"title":"撸一个简易富文本编辑器","slug":"撸一个简易富文本编辑器","date":"2019-05-07T03:31:00.000Z","updated":"2019-06-26T07:51:50.003Z","comments":true,"path":"2019/05/07/撸一个简易富文本编辑器/","link":"","permalink":"http://yoursite.com/2019/05/07/撸一个简易富文本编辑器/","excerpt":"","text":"前言印象中，富文本编辑器一直是一个高大上的玩意儿，想实现一个应该也挺难的。既然如此，那必须得学啊，这篇文章就是记录如何实现一个超简易的富文本编辑器。 实现方式实现富文本编辑器通常来说有两种方式： 给元素设置 contenteditable=’true’123&lt;div contenteditable=&quot;true&quot;&gt; 设置 contenteditable=&apos;true&apos; 后，该元素内的内容就是可以编辑了。&lt;/div&gt; 设置 iframe 的 designMode 为 ‘on’1234567891011121314&lt;iframe style=&quot;width: 500px;height: 330px;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var ifr = document.getElementsByTagName(&apos;iframe&apos;)[0] function printText() &#123; // 输出内容 console.log(ifr.contentWindow.document.body.innerHTML) &#125; function init() &#123; var doc = ifr.contentWindow.document doc.designMode = &apos;on&apos; doc.body.innerHTML = &apos;&lt;div&gt;设置 iframe 的 designMode&lt;/div&gt;&apos; &#125; init()&lt;/script&gt; 现在大多数都使用 contenteditable=’true’ 方法来实现富文本编辑器，我这里也采用这种方式document​.exec​Command定义：当一个HTML文档切换到设计模式时，document暴露 execCommand 方法，该方法允许运行命令来操纵可编辑内容区域的元素。使用：document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)参数： aCommandName 命令的名称，具体可看命令列表 aShowDefaultUI 布尔值，是否展示用户界面，一般为 false。 aValueArgument 额外的命令参数，默认为 null。 可以使用 document​.query​Command​State(commandName) 来检测是否支持命令 命令列表详细的可以查看这里，这里只列一些常见的：1234567891011121314151617181920212223242526272829303132333435363738394041424344backColor修改文档的背景颜色。在styleWithCss模式下，则只影响容器元素的背景颜色。这需要一个&lt;color&gt; 类型的字符串值作为参数传入。注意，IE浏览器用这个设置文字的背景颜色。bold开启或关闭选中文字或插入点的粗体字效果。IE浏览器使用 &lt;strong&gt;标签，而不是&lt;b&gt;标签。createLink将选中内容创建为一个锚链接。这个命令需要一个hrefURI字符串作为参数值传入。URI必须包含至少一个字符，例如一个空格。（浏览器会创建一个空链接）copy拷贝当前选中内容到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。cut剪贴当前选中的文字并复制到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。delete删除选中部分.fontName在插入点或者选中文字部分修改字体名称. 需要提供一个字体名称字符串 (例如：&quot;Arial&quot;)作为参数。fontSize在插入点或者选中文字部分修改字体大小. 需要提供一个HTML字体尺寸 (1-7) 作为参数。foreColor在插入点或者选中文字部分修改字体颜色. 需要提供一个颜色值字符串作为参数。heading添加一个标题标签在光标处或者所选文字上。 需要提供 aValueArgument 参数 (例如. &quot;H1&quot;, &quot;H6&quot;). (IE 和 Safari不支持)italic在光标插入点开启或关闭斜体字。 (Internet Explorer 使用 EM 标签，而不是 I )justifyCenter、justifyFull、justifyLeft、justifyRight对光标插入位置或者所选内容进行文字居中、文本对齐、左对齐、右对齐。selectAll选中编辑区里的全部内容。redo重做被撤销的操作。undo撤销最近执行的命令。 到这里正式开始撸HTML部分：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Editor&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html, body &#123; height: 100%; width: 100%; &#125; ul &#123; list-style: none; &#125; .wrap-editor&#123; width: 800px; height: 500px; border: 1px solid #ccc; position: fixed; top: 0; left: 0; right: 0; bottom: 0; margin: auto; overflow: hidden; &#125; .wrap-editor .menu&#123; width: 100%; height: 35px; border-bottom: 1px solid #ccc; cursor: pointer; font-size: 0; line-height: 35px; &#125; .wrap-editor .menu li&#123; display: inline-block; font-size: 14px; padding: 0 10px; &#125; .wrap-editor .editor&#123; width: 100%; height: 465px; outline: 0; overflow: auto; padding: 8px; box-sizing: border-box; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;wrap-editor&quot;&gt; &lt;!-- 按钮区域 --&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;bold&quot;&gt;B&lt;/li&gt; &lt;/ul&gt; &lt;!-- 编辑区域 --&gt; &lt;div class=&quot;editor&quot; contenteditable=&quot;true&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 接下来是Js部分一步步来，实现最基本的功能先：1234567891011121314var editor = document.querySelector(&apos;.editor&apos;) // 编辑器var bold = document.querySelector(&apos;.bold&apos;) // 加粗按钮editor.innerHTML = &apos;请输入内容&apos; // 给编辑器一个初始内容// 执行命令function execCommand(commandName, value) &#123; value = value ? value : null document.execCommand(commandName, false, value)&#125;bold.onclick = function (e) &#123; execCommand(&apos;bold&apos;)&#125; 这段代码十分简单，连我之前也没想到会如此简单。接着我们点击加粗按钮，这里会遇到一个坑无论怎么操作都无法加粗选择的文字，而且编辑区还失去了焦点。这个问题也很好解释，因为我们点击的按钮的文字也是可以选择的，点击按钮时所选区域自然就清空了，当然会出现没有加粗与失去焦点的问题啦。 下面是我所知道的几种解决方法： 在加粗按钮上阻止 onmousedown 的默认事件： 1&lt;li class=&quot;bold&quot; onmousedown=&quot;event.preventDefault();&quot;&gt;B&lt;/li&gt; 在按钮区域添加CSS user-select: none;这种方式存在兼容问题，如果不考虑低版本浏览器则可以使用。 123.wrap-editor .menu&#123; user-select: none;&#125; 缓存所选区域，点击事件触发后，手动调用API重新选中文字：监听editor区域的onkeyup、onmouseup、onmouseout等操作，在这些操作后缓存editor中的选中区域，点击事件触发后，手动调用API重新选中文字。这种方法下面会讲。 缓存用户所选区域 在键盘、鼠标、移出编辑区等操作后，缓存当前所选区域 点击按钮后恢复所选区域、focus()编辑器，之后执行 document.execCommand 修改内容 具体用法见 Window​.get​Selection修改后的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var editor = document.querySelector(&apos;.editor&apos;) // 编辑器var bold = document.querySelector(&apos;.bold&apos;) // 加粗按钮editor.innerHTML = &apos;请输入内容&apos; // 给编辑器一个初始内容// 执行命令function execCommand(commandName, value) &#123; value = value ? value : null document.execCommand(commandName, false, value)&#125;// 定义一个变量var selectedRange// 保存选择区域function saveSelection() &#123; var sel = window.getSelection() if (sel.getRangeAt &amp;&amp; sel.rangeCount) &#123; selectedRange = sel.getRangeAt(0) &#125;&#125;// 恢复选择区域function restoreSelection() &#123; var selection = window.getSelection() if (selectedRange) &#123; try &#123; selection.removeAllRanges() &#125; catch (ex) &#123; document.body.createTextRange().select() document.selection.empty() &#125; selection.addRange(selectedRange) &#125;&#125;// 在editor内做了鼠标键盘操作就保存一下选择区域editor.onmouseup = editor.onkeyup = editor.onmouseout = function () &#123; saveSelection();&#125;bold.onclick = function (e) &#123; restoreSelection() // 恢复选择区域 editor.focus() // focus一下 execCommand(&apos;bold&apos;) saveSelection() // 再保存一下选择区域&#125; 如何插入图片使用 FileReader 将图片读为 base64 格式，调用对应 API 将图片插入编辑区。1document.execCommand(&apos;insertImage&apos;, false, imgUrl) 将图片读为 base64 格式部分HTML:1&lt;input class=&quot;inster-img&quot; type=&quot;file&quot; /&gt; 部分Js：1234567891011121314151617181920212223// 将图片读为base64格式function imgToBase64(file) &#123; return new Promise((resolve, reject) =&gt; &#123; var reader = new FileReader() reader.readAsDataURL(file); reader.onload = function () &#123; resolve(this.result) &#125; &#125;)&#125;var insterImg = document.querySelector(&apos;.inster-img&apos;)insterImg.onchange = function (e) &#123; restoreSelection() // 恢复选择区域 editor.focus() // focus一下 var file = e.target.files[0] imgToBase64(file).then((val) =&gt; &#123; var base64Url = val execCommand(&apos;insertImage&apos;, base64Url) saveSelection() // 再保存一下选择区域 &#125;) &#125; 到此学习如何实现一个简易富文本编辑器的目的已经达到了，这里就不再写了下面放上简易编辑器的完整的代码，写的比较随意⊙﹏⊙‖∣，将就看吧： 完整代码参考 bootstrap-wysiwyg","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"学习Vue源码9-浅谈Vue中的Diff算法","slug":"学习Vue源码9-浅谈Vue中的Diff算法","date":"2019-05-06T10:46:26.000Z","updated":"2019-06-26T07:51:50.002Z","comments":true,"path":"2019/05/06/学习Vue源码9-浅谈Vue中的Diff算法/","link":"","permalink":"http://yoursite.com/2019/05/06/学习Vue源码9-浅谈Vue中的Diff算法/","excerpt":"","text":"虚拟DOM操作DOM的代价操作DOM的代价很高，影响页面性能的主要问题有以下几点： 访问和修改DOM元素 修改DOM元素的样式，导致重绘或重排 通过对DOM元素的事件处理，完成与用户的交互功能 DOM的修改会导致重绘或重排 重绘：重绘是指一些样式的修改，元素的位置和大小都没有改变，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 重排/回流：是指元素的位置或尺寸发生了变化，浏览器需要重新计算渲染树，而新的渲染树建立后，浏览器会重新绘制页面。 重绘相对于重排还好一些，重绘仅仅改变变化元素的样式即可，但重排（回流）则会重新计算所有元素之间的位置关系然后重新绘制元素如果频繁操作DOM，其必然带来性能变低，浏览器卡慢 为何需要虚拟DOM？接下来，我们看一下真实的DOM元素，我们打开某度的首页，在控制台输入以下代码：1234var dom1 = document.querySelectorAll(&apos;div&apos;)[0]for ( let x in dom1 ) &#123; console.log(x)&#125; 可以看到一个div下其实是有很多属性的：123456789101112131415aligntitlelangtranslatedirdatasethiddentabIndexaccessKeydraggablespellcheckautocapitalizecontentEditableisContentEditable......等上百个 一个DOM拥有这么多属性，这也是带来性能问题的原因之一，撇开我们用不上的属性，我们其实可以使用js来模拟一个仅保留我们需要的属性的DOM，这样的模拟DOM其实就是虚拟DOM。比如我们可以用以下代码模拟一个内容为’Hello Word’，id名与class名为test的div元素：123456&#123; tag: &apos;div&apos;, id: &apos;test&apos;, className: &apos;test&apos; text: &apos;Hello Word&apos;&#125; Vue、React都使用了虚拟DOM技术，让新、旧DOM的变化对比在Js层完成，最后仅修改变化了的DOM，直接避免了频繁操作DOM的情况，大大提升页面性能。 VnodeVnode就是虚拟DOM技术在Vue中的实现，它的源码在这里，它在模拟DOM的情况下又添加了很多框架本身需要的属性。123456789101112131415export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component&apos;s scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // code...&#125; 有了虚拟DOM那么就要有对比新、旧虚拟DOM的变化算法，这种算法就叫Diff算法： Diff算法Diff算法同级比较求两个任意树之间的最小修改是一个时间复杂度为O(n^3)问题。这样的时间复杂度是我们无法接受的。在Web应用中将组件移动到树中的不同级别是非常罕见的，通常只在孩子中间横向移动。所以Diff算法采用的是同级比较，将算法的时间复杂度降低到了O(N)，这大大降低了复杂性，同时也不会造成很大损失，正如下图所示： 所以如果我们进行了跨级别的组件移动操作，实际上是会先删除DOM，再在对应的层级上新建一个DOM。 循环中为何需要key属性？我们看这张图： 如果我们循环生成了5个组件，然后我们又插入了一个新的同类组件，对于我们来说很难知道如何在两个组件Lists中建立映射，所以就会变成上图左侧所示，按顺序一一建立关联。如果有了key的存在情况则大不一样，它能很容易的帮助代码解决映射问题，让代码在正确的地方进行正确的操作，这对代码的性能提升也有很大的帮助。 简单分析Diff算法我们以Vue（v2.6.8）代码为例，代码位置在src/core/vdom/patch.js中。 首先我们先明确几个方法： 工具方法isUndef、isDef等： 123456789// 判断v是否是undefined或nullexport function isUndef (v: any): boolean %checks &#123; return v === undefined || v === null&#125;// 判断v是否不是undefined或nullexport function isDef (v: any): boolean %checks &#123; return v !== undefined &amp;&amp; v !== null&#125;// 其他工具方法可以自行查看 sameVnode： 1234567891011121314151617// 判断是否是同一个Vnodefunction sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; nodeOps 封装了一些原生DOM操作方法，在platforms\\web\\runtime\\node-ops.js中 12345678910111213141516171819202122232425// code...export function createElementNS (namespace: string, tagName: string): Element &#123; return document.createElementNS(namespaceMap[namespace], tagName)&#125;export function createTextNode (text: string): Text &#123; return document.createTextNode(text)&#125;export function createComment (text: string): Comment &#123; return document.createComment(text)&#125;export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123; parentNode.insertBefore(newNode, referenceNode)&#125;export function removeChild (node: Node, child: Node) &#123; node.removeChild(child)&#125;export function appendChild (node: Node, child: Node) &#123; node.appendChild(child)&#125;// code... patch对比新、老vnode，进行最小程度的修改 如果是初始化会传以下几个参数（core\\instance\\lifecycle.js）： vm.__patch__(vm.$el, vnode, hydrating, false) // vm.$el 是要挂载到的DOM，vnode就是vnode，hydrating用于服务端渲染不用管，最后一个参数是removeOnly 如果是更新会传两个参数 vm.__patch__(prevVnode, vnode) // prevVnode 是旧 vNode，vnode 是新 vNode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120core\\vdom\\patch.jsreturn function patch (oldVnode, vnode, hydrating, removeOnly) &#123; // vnode不存在，oldVnode存在，说明节点被移除了，直接调用销毁钩子 if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] // 如果oldVnode不存在的话，就新建一个根节点 if (isUndef(oldVnode)) &#123; // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; // 👇根据 oldVnode 是否存在 nodeType 属性 来判断是否是一个真实DOM节点 // 👇如果存在 nodeType 说明当前走的是 初始化 流程 const isRealElement = isDef(oldVnode.nodeType) // 走update流程 且 是同一个节点，直接调用 patchVnode 方法 if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // 修补现有根节点 patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; // oldVnode 是 真实节点，走 init 流程 if (isRealElement) &#123; // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. // Vnode在服务端渲染的一些处理，这里暂且不看 // 如果oldVnode的是一个Element节点 &amp;&amp; 存在服务端渲染的属性 if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; // 则移除其SSR属性，再将hydrating设置为true oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn( &apos;The client-side rendered virtual DOM tree is not matching &apos; + &apos;server-rendered content. This is likely caused by incorrect &apos; + &apos;HTML markup, for example nesting block-level elements inside &apos; + &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; + &apos;full client-side render.&apos; ) &#125; &#125; // either not server-rendered, or hydration failed. // create an empty node and replace it // 不是服务端渲染的话，且是初始化流程，把oldVnode替换为一个空的vNode oldVnode = emptyNodeAt(oldVnode) &#125; // 当前节点与其父节点 const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // 创建一个新的 node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively // 递归更新父节点占位节点元素 if (isDef(vnode.parent)) &#123; let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) &#123; for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123; cbs.destroy[i](ancestor) &#125; ancestor.elm = vnode.elm if (patchable) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, ancestor) &#125; // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the &quot;inserted&quot; hook. const insert = ancestor.data.hook.insert if (insert.merged) &#123; // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) &#123; insert.fns[i]() &#125; &#125; &#125; else &#123; registerRef(ancestor) &#125; ancestor = ancestor.parent &#125; &#125; // 有父元素 if (isDef(parentElm)) &#123; removeVnodes(parentElm, [oldVnode], 0, 0) &#125; // 没有父元素触发销毁 else if (isDef(oldVnode.tag)) &#123; invokeDestroyHook(oldVnode) &#125; &#125; &#125; invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; patch 方法针对初始化与更新这两种情况做处理，关于初始化与更新的判断：patch 函数的第一个参数传的如果是一个真实DOM，那么就会有nodeType属性，则是初始化。如果是更新，且新旧两个vNode值得比较（即调用samevnode方法返回true，说明是同一个节点）则会调用 patchVnode 进一步比较。 patchVnode修补vnode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function patchVnode ( oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly ) &#123; // 如果是同一个vnode return if (oldVnode === vnode) &#123; return &#125; if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123; // 克隆重用 vnode vnode = ownerArray[index] = cloneVNode(vnode) &#125; // 设置 新vnode的elm 与 旧vnode.elm 相同（都为同一个DOM） const elm = vnode.elm = oldVnode.elm if (isTrue(oldVnode.isAsyncPlaceholder)) &#123; if (isDef(vnode.asyncFactory.resolved)) &#123; hydrate(oldVnode.elm, vnode, insertedVnodeQueue) &#125; else &#123; vnode.isAsyncPlaceholder = true &#125; return &#125; // 静态树重用元素 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; if (isUndef(vnode.text)) &#123; // 如果新旧 vNode都有 children 则调用 updateChildren 方法来对比他俩的 children if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; checkDuplicateKeys(ch) &#125; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &apos;&apos;) addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &apos;&apos;) &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text) &#125; if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125;&#125; 这里主要看这段：123if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)&#125; 如果 oldVnode 与 vNode 都有 children 则调用 updateChildren 方法来对比他俩的 children，在 updateChildren 方法中就会用到 Diff算法 来对比、更新节点，同时再 updateChildren 中也会调用 patchVnode 继续对比下一级子节点。 如果oldVnode 没有 children，而 vNode 有，则调用 addVnode 方法，添加所有的 children。 如果 oldVnode 有 children，而 vNode 有，则调用 removeVnode 方法，移除原有的 children。 如果 oldVnode 与 vNode 都是文本节点，则会用 vNode 的文本替换 oldVnode 的文本。 updateChildren这个方法是 diff 算法的核心：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 // 旧list起始索引 let newStartIdx = 0 // 新list起始索引 let oldEndIdx = oldCh.length - 1 // 旧list结尾索引 let oldStartVnode = oldCh[0] // 旧的起始vnode初始赋值为list的第一个 let oldEndVnode = oldCh[oldEndIdx] // 旧的结尾vnode初始赋值为list的最后一个 let newEndIdx = newCh.length - 1 // 新list结尾索引 let newStartVnode = newCh[0] // 旧的起始vnode初始赋值为list的第一个 let newEndVnode = newCh[newEndIdx] // 旧的结尾vnode初始赋值为list的最后一个 /** * 变量定义 * oldKeyToIdx要存一个哈希表，存放的内容是oldVnode的key * idxInOld会存放根据哈希表中的key找到的对应oldVnode * vnodeToMove我们要移动的vnode * refElm就到下面去看注释把 */ let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly是一个用于&lt;transition-group&gt;的特殊的flag // 以保证移除有过渡效果的的元素时保持它正确的定位 const canMove = !removeOnly if (process.env.NODE_ENV !== &apos;production&apos;) &#123; checkDuplicateKeys(newCh) &#125; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // oldStartVnode不存在，则将oldStartVnode赋值为下一个vnode if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left // oldEndVnode不存在则将oldEndVnode赋值为上一个vnode &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] // 如果oldStartVnode, newStartVnode为同一个vnode，直接去patchVnode（打补丁） // 然后，新旧startVnode各向前前进一格 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] // 如果oldEndVnode, newEndVnode为同一个vnode，直接去patchVnode（打补丁） // 然后，新旧endVnode各向后后退一格 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] // 如果oldStartVnode, newEndVnode为同一个vnode（vnode被移动到右边去了） // oldStartVnode前进一格 // newEndVnode后退一格 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] // 如果oldEndVnode, newStartVnode是同一个vnode，说明vnode被移到左边去了 // newStartVnode前进一格 // oldEndVnode后退一格 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] // 最后，所有的对比不上 &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 创建了一个哈希表，其存放的内容是old vnode的key idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // old vnode的哈希表中找不到，则说明是新元素啊，这里就新建一个元素 if (isUndef(idxInOld)) &#123; // New element 新加进来的元素 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) // else 就是找到啦， &#125; else &#123; // 这个就是我们找到的和 newVnode的startIndex 索引相同的 oldVnode，我们要把它移到当前的oldStartVnode的前面去 vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element // 不过呢，万一key相同，但是通过sameVnode方法比较出来的结果是不相同，则new一个元素，插到当前的oldStartVnode的前面去 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; // 这里就循环完毕啦 // 但是如果这里发现 oldStartIdx &gt; oldEndIdx 说明，有新增的元素 // 我们把它们选出来，用refElm存一下，然后啊，使用addVnodes批量调用创建（createElm）把这些vnode加到真实DOM中 if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) // else呢，说明新的vnodes比老的少 // 我们调用removeVnodes方法，参数包含oldStartIdx 与 oldEndIdx，把不要的删掉嘛 &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; updateChildren的代码中呢，主要是一个while循环，新旧Lists中无论哪一个先循环完都会退出循环1234567891011121314while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // code...&#125;// oldStartIdx &gt; oldEndIdx，新Lists中新增了某些元素if (oldStartIdx &gt; oldEndIdx) &#123; // addVnodes操作 // code...&#125;// else说明新Lists中移除了某些元素else if (newStartIdx &gt; newEndIdx) &#123; // removeVnodes操作 // code...&#125; 直接看源码感觉头都炸了，这里通过画图的方式会更合适一些。注意：以下每张图之间没有联系 首先会在新旧Lists的头尾定义各定义一个标记，分别为：oldStartIdx，oldEndIdx，newStartIdx，newEndIdx，用图表示是这个样子： oldStartVnode, newStartVnode相同的情况：执行patchVnode方法oldStartVnode与newStartVnode都前进一格完成这些操作就变成了下图这样： oldEndVnode, newEndVnode相同的情况：执行patchVnode方法oldEndVnode与newEndVnode都后退一格完成这些操作就变成了下图这样： oldStartVnode, newEndVnode相同的情况：这种情况下意味着当前 旧Lists的StartIdx位置的元素，在新Lists中被挪到了EndIdx位置（Vnode moved right）在执行完patchVnode方法之后，在真实DOM中我们还要将 oldStart 插到 oldEnd之后oldStartVnode前进一格newEndVnode后退一格 oldEndVnode, newStartVnode相同的情况：这种情况下意味着当前 旧Lists的EndIdx位置的元素，在新Lists中被挪到了StartIdx位置（Vnode moved left）在执行完patchVnode方法之后，在真实DOM中我们还要将 oldEnd 插到 oldStart之前newStartVnode前进一格oldEndVnode后退一格 ELSE！如果上面四种情况都比对不中，也是就出现下图的情况： 则会执行 createKeyToOldIdx 方法，123456789function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125; 返回一个 哈希表(obj)，各项 键为 vnode 的 key属性，值为 vnode 的下标哈希表中的内容包含处于 oldStart 至 oldEnd 的 vnode，大概长这样：12345&#123; vnodeKeyA: 1, vnodeKeyC: 2, vnodeKeyD: 3&#125; 接着从哈希表中寻找是否有与newStartVnode一致key的oldVNode节点接着看下面第5条： 我们在哈希表中找到了oldVnode节点：1vnodeToMove = oldCh[idxInOld] // 这个就是我们找到的`旧的vnode` 这里还分了两种情况 一、光比较key，肯定不足以判断两个vnode相同，我着这里再调用sameVnode(vnodeToMove, newStartVnode)方法来对比如果相同：执行patchVnodeoldCh[idxInOld]赋undefined // oldCh[idxInOld] = undefined ，我们已经用vnodeToMove保存了一份了然后在真实DOM中，把vnodeToMove插入到oldStart之前newStartVnode都前进一格放代码把：123456vnodeToMove = oldCh[idxInOld]if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)&#125; else &#123;&#125; 二、key相同，但sameVnode比较出来不相同这种情况下则调用createElm创建一个新的元素插到oldStart前面newStartVnode都前进一格 我们在哈希表中！！！没有找到oldVnode！！！节点：这种情况下和 5 中的第二种情况一模一样调用createElm创建一个新的元素插到oldStart前面newStartVnode都前进一格 到了这一步，while已经循环完毕了，接下来要处理新旧List长短不相同的情况 一、oldStartIdx &gt; oldEndIdx，oldStart 超过了oldEnd，说明新List比旧Lists长我们需要把没遍历到的vnode选出来，用refElm存一下，然后啊，使用addVnodes批量调用创建（createElm）把这些vnode加到真实DOM中1234if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)&#125; 二、newStartIdx &gt; newEndIdx，说明旧List比新Lists长我们调用removeVnodes方法，参数包含oldStartIdx 与 oldEndIdx，把多余的删掉123456if&#123; // code...&#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)&#125; 参考 高频dom操作和页面性能优化探索React’s diff algorithmhttps://github.com/answershuto/learnVue","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码8-vm._render与vm._update","slug":"学习Vue源码8-vm-render与vm-update","date":"2019-05-06T01:35:36.000Z","updated":"2019-06-26T07:51:50.002Z","comments":true,"path":"2019/05/06/学习Vue源码8-vm-render与vm-update/","link":"","permalink":"http://yoursite.com/2019/05/06/学习Vue源码8-vm-render与vm-update/","excerpt":"","text":"接上篇$mount方法总结 获得模版 template。 调用 compileToFunctions 获得 template 对应的 render函数。 调用 mountComponent ，其中的 vm._render() 将 render函数 转化为 vNode。 vm._update() 以生成的 vNode 为参数发布更新。 vm._render()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667core\\instance\\render.jsVue.prototype._render = function (): VNode &#123; const vm: Component = this // 这个 render 是之前以 template 生成的 &apos;render函数&apos;，生成后它就在 vm.$options 上挂着，这里将他取出。 const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) &#125; // 设置父vNode，允许 render函数 访问占位节点上的数据 vm.$vnode = _parentVnode // render self let vnode try &#123; // There&apos;s no need to maintain a stack becaues all render fns are called // separately from one another. Nested component&apos;s render fns are called // when parent component is patched. currentRenderingInstance = vm // vm._renderProxy在core\\instance\\init.js中，这里可以看做this // vnode = render.call(this, vm.$createElement) vnode = render.call(vm._renderProxy, vm.$createElement) // 👈👈👈👈👈 &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it // 如果返回的数组只有一个元素，则 vnode = vnode[0] if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; Array.isArray(vnode)) &#123; warn( &apos;Multiple root nodes returned from render function. Render function &apos; + &apos;should return a single root node.&apos;, vm ) &#125; // render 函数抛错则返回一个空vNode vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; vm._render主要是这一句：vnode = render.call(vm._renderProxy, vm.$createElement)，第一个参数可以直接看做this，第二个参数是 createElement 方法。 vm.$options.render 的内容以这段代码为例：123456789101112var vm = new Vue(&#123; el: &apos;.logo&apos;, data: &#123; a: 1 &#125;, template: ` &lt;div&gt; hello&#123;&#123; a &#125;&#125; &lt;div&gt;111&lt;/div&gt; &lt;div&gt;222&lt;/div&gt; &lt;/div&gt; `&#125;)console.log(vm.$options.render) 这里输出的是一段匿名函数1234(function anonymous() &#123; with(this)&#123;return _c(&apos;div&apos;,[_v(&quot;hello&quot;+_s(a)),_c(&apos;div&apos;,[_v(&quot;111&quot;)]),_c(&apos;div&apos;,[_v(&quot;222&quot;)])])&#125;&#125;) 这些函数简写对应如下：_c = createElement // createElement 其实就是 _createElement_v = createTextVNode_s = toString// 等…..其他的可以在 core\\instance\\render-helpers\\index.js 找。 _createElement方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// core\\vdom\\create-element.jsexport function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` + &apos;Always create fresh vnode data objects in each render!&apos;, context ) return createEmptyVNode() &#125; // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode() &#125; // warn against non-primitive key if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) &#123; if (!__WEEX__ || !(&apos;@binding&apos; in data.key)) &#123; warn( &apos;Avoid using non-primitive value as key, &apos; + &apos;use string/number value instead.&apos;, context ) &#125; &#125; // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === &apos;function&apos; ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === &apos;string&apos;) &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) // 检查是否是当前运行环境（默认指浏览器）下存在的标签名，方法在：platforms\\web\\util\\element.js中 if (config.isReservedTag(tag)) &#123; // platform built-in elements // 创建 vNode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123; // component // 创建组件 vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children // 未知元素 vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; // direct component options / constructor // 直接就是个组件 vnode = createComponent(tag, data, context, children) &#125; // return vnode 的各种判断 if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; 如果tag是浏览器中存在的标签，则返回 new Vnode() 如果是个组件，则返回 createComponent() 如果是未知元素也返回 new VNode() resolveAsset：寻找options中对应组件，作为 createComponent 的第一个参数1234567891011121314151617181920212223242526272829303132333435363738core\\util\\options.jsexport function resolveAsset ( options: Object, type: string, id: string, warnMissing?: boolean): any &#123; /* istanbul ignore if */ if (typeof id !== &apos;string&apos;) &#123; return &#125; const assets = options[type] // 找出options中的所有组件 --&gt; vm.$options[&apos;components&apos;] // 先检查本地的 components 有没有对应的组件（对应形参id） if (hasOwn(assets, id)) return assets[id] // 上面一步如果没找到，则将组件名称转为驼峰写法。 const camelizedId = camelize(id) // 用驼峰写法的组件名再次寻找 if (hasOwn(assets, camelizedId)) return assets[camelizedId] // 还找不到，则将组件名首字母转为大写，再找一次 const PascalCaseId = capitalize(camelizedId) if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId] // fallback to prototype chain const res = assets[id] || assets[camelizedId] || assets[PascalCaseId] // 找不到组件警告 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warnMissing &amp;&amp; !res) &#123; warn( &apos;Failed to resolve &apos; + type.slice(0, -1) + &apos;: &apos; + id, options ) &#125; return res&#125; 最终生成了vNode： vm._update()1234567891011121314151617181920212223242526272829303132// core\\instance\\lifecycle.jsVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // 没有vm._vnode说明没有 mount过，这里走初始化流程 if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; // 有vm._vnode说明已经 mount过，这里走更新流程 else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // 更新 __vue__ 引用 if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125;&#125; 这里的 vm.__patch__ 就是 core\\vdom\\patch.js 中的 patch 方法。 之后 patch函数 会使用 diff 算法来更新 DOM。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码7-Vue中的$mount方法","slug":"学习Vue源码7-Vue中的mount方法 ","date":"2019-05-05T06:56:34.000Z","updated":"2019-06-26T07:51:50.002Z","comments":true,"path":"2019/05/05/学习Vue源码7-Vue中的mount方法 /","link":"","permalink":"http://yoursite.com/2019/05/05/学习Vue源码7-Vue中的mount方法 /","excerpt":"","text":"用法使用 vm.$mount() 可以手动地挂载一个未挂载的实例，比如：12345678910111213var MyComponent = Vue.extend(&#123; template: &apos;&lt;div&gt;Hello!&lt;/div&gt;&apos;&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount(&apos;#app&apos;)// 如果传入了el参数，则会直接调用$mount，最终效果和上面一样new MyComponent(&#123; el: &apos;#app&apos; &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById(&apos;app&apos;).appendChild(component.$el) 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// platforms\\web\\entry-runtime-with-compiler.jsconst idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)// 缓存原型上的$mount方法，具体会跟运行环境不同而不同// 如：浏览器 和 weexconst mount = Vue.prototype.$mount// 接着重写$mount方法Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; // 查找el el = el &amp;&amp; query(el) /* istanbul ignore if */ // Vue不允许挂载到&lt;html&gt;或&lt;body&gt;上面 if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; // 配置项 const options = this.$options // resolve template/el and convert to render function // 解析template并转换为render函数 if (!options.render) &#123; // 这里有一些列的判断 👇 let template = options.template if (template) &#123; if (typeof template === &apos;string&apos;) &#123; if (template.charAt(0) === &apos;#&apos;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &apos;production&apos;) &#123; warn(&apos;invalid template option:&apos; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; // 我们忽略这些判断代码，最终我们得到了template 👈 if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile&apos;) &#125; // 调用 compileToFunctions 方法，将template转化为render函数 👇 // 根据 platforms\\web\\compiler\\index.js 里的代码 compileToFunctions 方法就是 // compiler\\index.js 中 export 的 createCompiler const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== &apos;production&apos;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) // compileToFunctions 返回的东西可以看 compiler\\index.js 里的注释 options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if 这个可以忽略 */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&apos;compile end&apos;) measure(`vue $&#123;this._name&#125; compile`, &apos;compile&apos;, &apos;compile end&apos;) &#125; &#125; &#125; // 调用缓存的$mount方法挂载Vue return mount.call(this, el, hydrating)&#125; 首先，缓存原型上的 $mount 方法，具体会跟运行环境不同而不同，如：浏览器 和 weex。 重写原型上的$mount方法，如果有el参数，则会查找该DOM元素，且Vue不允许挂载到 html 或 body 上面 调用 compileToFunctions 方法将 template 转换为 render 函数 1234567891011121314151617181920212223242526272829303132333435363738// compiler\\index.js export const createCompiler = createCompilerCreator(function baseCompile ( template: string, options: CompilerOptions): CompiledResult &#123; // 生成AST树 const ast = parse(template.trim(), options) // 优化AST if (options.optimize !== false) &#123; optimize(ast, options) &#125; // generate函数会返回render与staticRenderFns const code = generate(ast, options) // 最后将 ast、render、staticRenderFns全部返回 return &#123; // AST ast, /* 这个是render函数 如果有这样一段代码 var v = new Vue(&#123; el:&apos;.arrow&apos;, data:&#123;a:1&#125;, template: &apos;&lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt;&apos; &#125;) console.log(v.$options.render) 会得到： ƒ anonymous() &#123; with(this)&#123;return _c(&apos;div&apos;,[_v(_s(a))])&#125; &#125; _c其实就是createElement函数的内部用法 Vue最终编译template的结果和我们直接用createElement手写render函数没两样。 */ render: code.render, // staticRenderFns 存放纯静态 render函数（就是没有使用data中的数据），比如这一段： // var v = new Vue(&#123; // el: &apos;.arrow&apos;, data: &#123; a: 1 &#125;, template: &apos;&lt;div&gt;hello&lt;/div&gt;&apos; // &#125;) // console.log(v.$options.staticRenderFns) // 这里输出就会看到里面的东西 staticRenderFns: code.staticRenderFns &#125;&#125;) 将 compileToFunctions 方法返回的 render 与 staticRenderFns 挂到options上 调用之前缓存的 mount.call(this, el, hydrating) 方法12345678910// 之前缓存的mount方法// platforms\\web\\runtime\\index.js// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 我们看到缓存的$mount方法调用了 mountComponent 方法，它在 core\\instance\\lifecycle.js 里面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; // el vm.$el = el // 一些警告提示语 if (!vm.$options.render) &#123; // code... &#125; // 触发 beforeMount 钩子 callHook(vm, &apos;beforeMount&apos;) let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123; // 非生产环境下的性能监控 // code... &#125; else &#123; updateComponent = () =&gt; &#123; // vm._render() 将 render函数转换为 vNode ，vm._update 以其为参数发布更新 vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher&apos;s constructor // since the watcher&apos;s initial patch may call $forceUpdate (e.g. inside child // component&apos;s mounted hook), which relies on vm._watcher being already defined // 我们在 watcher的 构造函数中将 vm._watcher 设置为 this（isRenderWatcher参数） // watcher 初始化时可能会调用 $forceUpdate 方法（比如：内部子组件的 mounted 钩子） // 这需要 vm._watcher 已经定义过，如下： // Vue.prototype.$forceUpdate = function () &#123; // const vm: Component = this // if (vm._watcher) &#123; // vm._watcher.update() // &#125; // &#125; // 实例化一个 Watcher 通过它的回调函数 updateComponent 来调用 vm._update 更新视图 new Watcher(vm, updateComponent, noop, &#123; before () &#123; // Vue已挂载且没被销毁才会触发 beforeUpdate 钩子 if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &apos;beforeUpdate&apos;) &#125; &#125; &#125;, true /* isRenderWatcher参数 */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook // 修改 vm._isMounted 为 true ，手动触发 mounted 钩子 if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &apos;mounted&apos;) &#125; return vm&#125; mountComponent 中最主要的是 调用 vm._render() 将 render函数 转换为 vNode ，再调用 vm._update 以生成的 vNode 为参数发布更新。 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 这里实例化一个 Watcher 通过它的回调函数 updateComponent 来调用 vm._update 更新视图 12345678new Watcher(vm, updateComponent, noop, &#123; before () &#123; // Vue已挂载且没被销毁才会触发 beforeUpdate 钩子 if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &apos;beforeUpdate&apos;) &#125; &#125;&#125;, true /* isRenderWatcher参数 */) 修改 vm._isMounted 为 true ，触发 mounted 钩子 总结 获得模版 template。 调用 compileToFunctions 获得 template 对应的 render函数。 调用 mountComponent ，其中的 vm._render() 将 render函数 转化为 vNode。 vm._update() 以生成的 vNode 为参数发布更新。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"实现一个Promise","slug":"Promise","date":"2019-04-28T03:50:11.000Z","updated":"2019-06-26T07:51:49.997Z","comments":true,"path":"2019/04/28/Promise/","link":"","permalink":"http://yoursite.com/2019/04/28/Promise/","excerpt":"","text":"先实现一个简易版Promise既然是简易版直接看在代码里的注释就可以了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 定义三种状态，pending可以向其他两个状态转换，但是一旦转换将不可再更改const PENDING = &apos;pending&apos;const FULFILLED = &apos;fulfilled&apos;const REJECTED = &apos;rejected&apos;/** * * @param &#123;Function&#125; fn Promise要执行的函数 */function MyPromise(fn) &#123; let self = this // 保存一份this self.status = PENDING // 默认为pending状态 self.value = null // Promise 的 value 值 self.fulfillCallback = [] // 成功回调 self.rejectCallback = [] // 失败回调 // resolve方法 function resolve(value) &#123; // 只有在pending状态时才会执行 if (self.status === PENDING) &#123; // 修改为对应状态 self.status = FULFILLED // 修改对应状态的 value self.value = value // 执行所有回调 self.fulfillCallback.map(cb =&gt; cb(self.value)) &#125; &#125; // reject方法 function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED self.value = reason self.rejectCallback.map(cb =&gt; cb(self.value)) &#125; &#125; // fn要传入 resolve 与 reject 然后&apos;直接执行&apos;，我们要捕获一下异常，如果存在异常直接执行reject try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;/** * @param &#123;Function&#125; onFulfilled // 成功callback * @param &#123;Function&#125; onRejected // 失败callback */MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; // 处理不传参数的情况 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; // pending状态下保存callbacks if (this.status === PENDING) &#123; this.fulfillCallback.push(onFulfilled) this.rejectCallback.push(onRejected) &#125; // 状态如果已经成功则执行入参 onFulfilled if (this.status === FULFILLED) &#123; onFulfilled(this.value) &#125; // 状态如果已经失败则执行入参 onRejected if (this.status === REJECTED) &#123; onRejected(this.value) &#125;&#125; 测试一下，可以看到两秒后弹出了’啦啦啦’12345678new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(&apos;啦啦啦&apos;) &#125;, 2000)&#125;).then(function (val) &#123; alert(val)&#125;) 实现符合Promise/A+规范的Promise实现了简易的Promise当然不够，接下来我们要补全我们的Promise，让其符合Promise/A+规范，中文版的：Promise/A+规范。 首先我们大致梳理一下有哪些点需要完善的： then必须返回一个Promise，使其可以继续then下去(then must return a promise) onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 (onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1]) 。注解3.1中大概是说onFulfilled 和 onRejected 方法需要异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行，所以我们要用setTimeout把这两个方法包起来。 最关键的是缺少承诺解决程序(2.3 The Promise Resolution Procedure)，可以理解为处理then之后如何继续then（下面的代码块有详细注释） 先给then返回Promise对MyPromise.prototype.then方法进行修改：1234567891011121314151617181920212223242526272829303132333435363738MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; // 处理不传参数的情况 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let self = this let backPromise // 要返回的Promose return backPromise = new MyPromise(function(resolve, reject) &#123; // pending状态下保存callbacks if (self.status === PENDING) &#123; self.fulfillCallback.push(onFulfilled) self.rejectCallback.push(onRejected) resolvePromise() &#125; // 状态如果已经成功则执行入参 onFulfilled else if (self.status === FULFILLED) &#123; onFulfilled(self.value) // 1️⃣ resolvePromise() &#125; // 状态如果已经失败则执行入参 onRejected else if (self.status === REJECTED) &#123; onRejected(self.value) // 2️⃣ resolvePromise() &#125; &#125;)&#125;/*（x指的是onFulfilled1️⃣, onRejected2️⃣的返回值）resolvePromise处理then之后的Promise，这块要处理的问题比较复杂，包括then中返回的Promise是否与x相等啊、then中用户是否自己又返回了一个Promise啊（x 为 Promise）x 为对象或函数啦我们这里先把这个函数空着*/function resolvePromise() &#123; &#125; 使用setTimeout包裹 onFulfilled 和 onRejected 方法，使其异步执行 This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. 使用setTimeout包裹之后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; // 处理不传参数的情况 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let self = this let backPromise // 要返回的Promose return backPromise = new MyPromise(function(resolve, reject) &#123; // pending状态下保存callbacks if (self.status === PENDING) &#123; self.fulfillCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.rejectCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) resolvePromise() &#125; // 状态如果已经成功则执行入参 onFulfilled else if (self.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) // 2️⃣ resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; // 状态如果已经失败则执行入参 onRejected else if (self.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) // 2️⃣ resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; &#125;)&#125;// 我们这里先把这个函数空着function resolvePromise(backPromise, x, resolve, reject) &#123;&#125; 最后一步，也是最麻烦的一步，补全resolvePromise函数如果 promise 和 x 指向同一对象，则抛出错误，这样可以避免循环引用 123456789function resolvePromise(backPromise, x, resolve, reject) &#123; let self = this let typeString = val =&gt; Object.prototype.toString.call(val) // 规范2.3.1：如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if (backPromise === x) &#123; reject(new TypeError(&apos;backPromise and x should not be the same&apos;)) &#125;&#125; x 为 Promise这个其实不用判断也可以，这里跳过。 x为对象或者函数大概是这样一个结构： 1234567891011// 先判断x是否为对象或者函数if (typeString(x) === &apos;[object Object]&apos; || typeString(x) === &apos;[object Function]&apos;) &#123; // code...&#125; else &#123; // 规范 2.3.4：如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x)&#125; 继续： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 先判断x是否为对象或者函数if (typeString(x) === &apos;[object Object]&apos; || typeString(x) === &apos;[object Function]&apos;) &#123; // ----------------------------------------------- 分割线 ----------------------------------------------- // 定义一个hasUsed用于规范2.3.3.3.3：如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 let hasUsed try &#123; // 规范 2.3.3.1：把 x.then 赋值给 then let then = x.then if (typeof then === &apos;function&apos;) &#123; // 规范 2.3.3.3：如果 then 是函数，将 x 作为函数的作用域 this 调用。 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: then.call(x, // 规范 2.3.3.1：如果/当 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) (y) =&gt; &#123; if (hasUsed) return hasUsed = true resolvePromise(backPromise, y, resolve, reject) &#125;, // 规范 2.3.3.2：如果/当 rejectPromise 以据因 r 为参数被调用，则以 r 为理由拒绝 promise (r) =&gt; &#123; if (hasUsed) return hasUsed = true reject(r) &#125; ) &#125; else &#123; // 规范 2.3.3.4：如果 then 不是函数，以 x 为参数执行 promise if (hasUsed) return hasUsed = true resolve(x) &#125; &#125; catch (e) &#123; // 规范 2.3.3.2：如果执行x.then的时候抛出了错误e，则以e为理由reject掉promise if (hasUsed) return hasUsed = true reject(e) &#125; // ----------------------------------------------- 分割线 -----------------------------------------------&#125; else &#123; // 规范 2.3.4：如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x)&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171// 定义三种状态，pending可以向其他两个状态转换，但是一旦转换将不可再更改const PENDING = &apos;pending&apos;const FULFILLED = &apos;fulfilled&apos;const REJECTED = &apos;rejected&apos;/** * * @param &#123;Function&#125; fn Promise要执行的函数 */function MyPromise(fn) &#123; let self = this // 保存一份this self.status = PENDING // 默认为pending状态 self.value = null // Promise 的 value 值 self.fulfillCallback = [] // 成功回调 self.rejectCallback = [] // 失败回调 // resolve方法 function resolve(value) &#123; // 只有在pending状态时才会执行 if (self.status === PENDING) &#123; // 修改为对应状态 self.status = FULFILLED // 修改对应状态的 value self.value = value // 执行所有回调 self.fulfillCallback.map(cb =&gt; cb(self.value)) &#125; &#125; // reject方法 function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED self.value = reason self.rejectCallback.map(cb =&gt; cb(self.value)) &#125; &#125; // fn要传入 resolve 与 reject 然后直接执行的，我们要捕获一下异常，如果存在异常直接执行reject try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;/** * @param &#123;Function&#125; onFulfilled // 成功callback * @param &#123;Function&#125; onRejected // 失败callback */MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; // 处理不传参数的情况 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val =&gt; val onRejected = typeof onRejected === &apos;function&apos; ? onRejected : err =&gt; &#123; throw err &#125; let self = this let backPromise // 要返回的Promose return backPromise = new MyPromise(function(resolve, reject) &#123; // pending状态下保存callbacks if (self.status === PENDING) &#123; self.fulfillCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) self.rejectCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; // 状态如果已经成功则执行入参 onFulfilled else if (self.status === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value) // 2️⃣ resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; // 状态如果已经失败则执行入参 onRejected else if (self.status === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value) // 2️⃣ resolvePromise(backPromise, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; &#125;)&#125;/*（x指的是onFulfilled1️⃣, onRejected2️⃣的返回值）resolvePromise处理then之后的Promise，这块要处理的问题比较复杂，包括then中返回的Promise是否与x相等啊、then中用户是否自己又返回了一个Promise啊（x 为 Promise）x 为对象或函数啦*/function resolvePromise(backPromise, x, resolve, reject) &#123; // let self = this let typeString = val =&gt; Object.prototype.toString.call(val) // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise（规范2.3.1） if (backPromise === x) &#123; reject(new TypeError(&apos;backPromise and x should not be the same&apos;)) &#125; // 先判断x是否为对象或者函数 if (typeString(x) === &apos;[object Object]&apos; || typeString(x) === &apos;[object Function]&apos;) &#123; // ----------------------------------------------- 分割线 ----------------------------------------------- // 定义一个hasUsed用于规范2.3.3.3.3：如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 let hasUsed try &#123; // 规范 2.3.3.1：把 x.then 赋值给 then let then = x.then if (typeof then === &apos;function&apos;) &#123; // 规范 2.3.3.3：如果 then 是函数，将 x 作为函数的作用域 this 调用。 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: then.call(x, // 规范 2.3.3.1：如果/当 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) y =&gt; &#123; if (hasUsed) return hasUsed = true resolvePromise(backPromise, y, resolve, reject) &#125;, // 规范 2.3.3.2：如果/当 rejectPromise 以据因 r 为参数被调用，则以 r 为理由拒绝 promise r =&gt; &#123; if (hasUsed) return hasUsed = true reject(r) &#125; ) &#125; else &#123; // 规范 2.3.3.4：如果 then 不是函数，以 x 为参数执行 promise if (hasUsed) return hasUsed = true resolve(x) &#125; &#125; catch (e) &#123; // 规范 2.3.3.2：如果执行x.then的时候抛出了错误e，则以e为理由reject掉promise if (hasUsed) return hasUsed = true reject(e) &#125; // ----------------------------------------------- 分割线 ----------------------------------------------- &#125; else &#123; // 规范 2.3.4：如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x) &#125;&#125; 最后提一下Promise.prototype.catch的实现123Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected)&#125; Promise.prototype.catch实际上就是对then方法的包装，他返回了一个成功方法为null，失败方法为我们传如的function的then方法，当Promise中发生语法错误：12345678910111213141516171819new MyPromise(function (resolve, reject) &#123; alert(a) // Uncaught ReferenceError: a is not defined /* alert(a)出现了语法错误 MyPromise代码中执行fn时，catch了错误，直接执行了reject(e)， try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125; 但是第一个then中并没有定义失败的方法，失败方法被默认赋值为了这样err =&gt; &#123; throw err &#125;一个方法，又将错误抛出，然后被catch捕获到 */&#125;).then(function (val) &#123; console.log(val)&#125;).catch(function(err) &#123; console.log(&apos;ERR&apos;, err) // ERR ReferenceError: a is not defined&#125;) 从catch的实现我想到了我遇到过的一道题目catch在捕获语法错误的同时，也会使全局错误捕获window.onerror无法捕获这个错误，在then方法中如何写，才能使window.onerror成功捕获到错误？123456789101112window.onerror = (e) =&gt; &#123; console.error(&apos;WINDOW&apos;, e) // 全局无法捕获错误&#125;new Promise(function (resolve, reject) &#123; resolve()&#125;).then(function (val) &#123; alert(hasNot)&#125;).catch(function (err) &#123; console.log(&apos;ERR&apos;, err) // hasNot is not defined 错误被catch捕获&#125;) 这里的一种方案是使用setTimeout包裹代码：1234567891011121314151617window.onerror = (e) =&gt; &#123; console.log(&apos;WINDOW&apos;, e) // 成功捕获错误&#125;new Promise(function (resolve, reject) &#123; resolve()&#125;).then(function (val) &#123; // 使用setTimeout将会报错的代码放到宏任务队列中去， // 以保证同步代码执行时不报错，不被catch捕获， // 待清空宏任务队列时，就会将错误抛到全局去 setTimeout(() =&gt; &#123; alert(hasNot) &#125;, 0)&#125;).catch(function (err) &#123; console.log(&apos;ERR&apos;, err)&#125;) 参考： Promises/A+【翻译】Promises/A+规范Promise的源码实现","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Buffer笔记","slug":"Buffer笔记","date":"2019-04-26T01:51:04.000Z","updated":"2019-06-26T07:51:49.995Z","comments":true,"path":"2019/04/26/Buffer笔记/","link":"","permalink":"http://yoursite.com/2019/04/26/Buffer笔记/","excerpt":"","text":"BufferBuffer是一个类数组对象，主要用于操作字节，它的元素为16进制两位数，即0-255的数值。Buffer非常像数组，它可以访问length属性的到长度，也可以通过下标访问元素。Buffer对象的内存分配不是在V8堆内存中，而是在Node的C++层实现内存申请的。 Buffer对象1234var str = &quot;Buffer笔记&quot; var buf = new Buffer(str, &apos;utf-8&apos;)console.log(buf)// &lt;Buffer 42 75 66 66 65 72 e7 ac 94 e8 ae b0&gt; Buffer对象的length12var buf = new Buffer(100)console.log(buf.length) // =&gt; 100 通过下标赋值12345678910console.log(buf[10]) // 这里会发现buf的元素是一个0-255的随机值buf[10] = 100console.log(buf[10]) // =&gt; 100给元素赋值如果小于0，就将该值逐次加256，直到得到一个0-255之间的整数，如果得到的数值大于255，就逐次减256，直到得到0-255间的数值。如果是小数，则只保留整数部分。buf[20] = -100; console.log(buf[20]); // 156 buf[21] = 300; console.log(buf[21]); // 44 buf[22] = 3.1415; console.log(buf[22]); // 3 Buffer内存分配为高效使用申请来的内存，Node采用slab分配机制，简单来说slab就是一块申请好的固定大小的内存区域，它有三个状态： full: 完全分配 partial: 部分分配 empty: 没有被分配 Node以8KB为界限来区分Buffer是大对象还是小对象，同时8KB(8*1024)也是每个slab的大小值，在Js中，以它作为单位单元进行内存分配。 Buffer转换Buffer对象可以与字符串相互转换，但目前只支持这几种：ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 1234// 字符串转Buffernew Buffer(str, [编码方式，默认UTF-8])// Buffer转字符串buf.write(string, [offset], [length], [encoding]) Buffer的拼接Buffer通常是一段一段传输的：123456789var fs = require(&apos;fs&apos;)var rs = fs.createReadStream(&apos;test.md&apos;)var data = &apos;&apos;rs.on(&quot;data&quot;, function (chunk)&#123; data += chunk // chunk就是Buffer对象&#125;)rs.on(&quot;end&quot;, function () &#123; console.log(data)&#125;) 使用字符串拼接的方式拼接Buffer在英文中并没有什么问题，但是，一旦输入流中又宽位字节码，就可能出现乱码。12data += chunk // 问题出在这里data = data.toString() + chunk.toString() // 字符串拼接会隐式调用toString方法 toString()对于英文没什么影响，但对于宽字节的中文就会造成乱码。 解决添加setEncoding()，但这种方式局限于UTF-8、UTF-16LE/UCS-2、Base64这三种编码。12var rs = fs.createReadStream(&apos;test.md&apos;, &#123; highWaterMark: 11&#125;)rs.setEncoding(&apos;utf8&apos;) 正确的拼接Buffer正确的拼接方式是用一个数组来储存接受到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个河边的Buffer对象：1234567891011var chunks = []var size = 0res.on(&apos;data&apos;, function (chunk) &#123; chunks.push(chunk) size += chunk.length&#125;); res.on(&apos;end&apos;, function () &#123; var buf = Buffer.concat(chunks, size); var str = iconv.decode(buf, &apos;utf8&apos;); console.log(str); &#125;)","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[]},{"title":"Node中的Js模块机制","slug":"Node中的Js模块机制","date":"2019-04-25T07:00:15.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2019/04/25/Node中的Js模块机制/","link":"","permalink":"http://yoursite.com/2019/04/25/Node中的Js模块机制/","excerpt":"","text":"CommonJS模块规范模块定义123exports.add = function() &#123; console.log(&apos;add&apos;)&#125; 模块引用在另一个文件中通过require引入模块后即可调用定义的属性或方法了12var add = require(&apos;./add&apos;).addadd() node模块分类核心模块（Node自带模块）在node源代码编译的过程中，就编译进了二进制执行文件，属于安装包的一部分。在node进程启动时，部分核心模块会被直接加载进内存，因此，这部分核心模块的引入不需要文件定位和编译执行，并且优先进行路径分析，所以核心模块加载速度最快。如果想要提高自己的node的加载速度，可以把自己的包，写入到安装包装中，使之变成核心模块。 核心模块的优先级，仅次于缓存加载，它在node的源代码编辑过程中已经编译为二进制代码，加载速度最快。 文件模块（用户编写第三方模块）文件模块是在运行时动态加载的，需要完整的路径分析、文件定位、编译执行的过程，加载速度比核心模块加载的速度要慢。我们新建一个文件module_path.js1console.log(module.paths) 执行1node module_path.js 可以看到这样一个输出12345678//linux[ &apos;/home/jackson/research/node_modules&apos;,&apos;/home/jackson/node_modules&apos;,&apos;/home/node_modules&apos;,&apos;/node_modules&apos; ]//win[ &apos;c:\\\\nodejs\\\\node_modules&apos;, &apos;c:\\\\node_modules&apos; ] 我们可以看出，这个模块路径的生成规则是：1.当前文件目录下的node_modules目录2.父目录下的的node_modules目录3.爷爷目录下的node_modules目录4.祖宗目录下的的node_modules目录，也就是向上一直找，直到根目录下的node_modules目录 这很像Js中的原型链，层层查找，找到为止。 注：Node对引入过的模块都会进行缓存，以减少二次引用时的开销。模块编译Node中每个文件就是一个模块，他的定义如下：1234567891011function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; if (parent &amp;&amp; parent.children) &#123; parent.children.push(this); &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 对于不同的扩展名文件，其加载方式如下： js文件，通过fs模块同步读取后编译执行。 node文件，这是用c/c++编写的扩展文件，通过dlopen()方法加载并编译。 json文件，通过fs模块同步读取后，用JSON.parse()解析并返回结果。 其余扩展名文件都当做js处理 每一个编译成功的模块都会将文件路径作为索引缓存到Module._cache对象中，以提高二次引入的性能。 JavaScript模块的编译我们知道每个模块中都有require、exports、module、filename、dirname，它们从何而来，事实上，在编译过程中，Node对js文件内容进行了头尾包装，变为如下形式：123456(function (exports, require, module, __filename, __dirname) &#123; var math = require(&apos;math&apos;) exports.area = function (radius) &#123; return Math.PI * radius * radius &#125;&#125;) 这样每个文件模块之间都有了作用域隔离，包装后的代码会通过vm原生模块调用runInThisContext()方法执行（类似于eval），返回一个具体的function对象。 最后将当前模块对象的exports属性、require方法、module（模块对象自身）、文件完整路径、文件目录当做参数传给这个function执行，最后return了模块的exports。 故exports上的任何方法和属性都可以被外部调用到。 exports和module.exportsmodule.exports才是真正的接口，exports只不过是它的一个辅助工具。 最终返回给调用的是module.exports而不是exports。所有的exports收集到的属性和方法，都赋值给了Module.exports。当然，这有个前提，就是module.exports本身不具备任何属性和方法。如果，module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。 参考： 《深入浅出Node.js》","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[]},{"title":"V8垃圾回收机制","slug":"V8垃圾回收机制","date":"2019-04-24T02:57:11.000Z","updated":"2019-06-26T07:51:49.997Z","comments":true,"path":"2019/04/24/V8垃圾回收机制/","link":"","permalink":"http://yoursite.com/2019/04/24/V8垃圾回收机制/","excerpt":"","text":"V8的内存限制在一般的后端语言中，在内存的使用上没什么限制，而在Node.js中却是被限制的（64ͮ位系统下约为1.4 GB，32ͮ位系统下约为0.7 GB）。这就导致Node.js无法直接操作过大的内存操作。 造成这种问题的原因，一是V8本是为浏览器设计的，很少会遇到使用大量内存的场景。二是垃圾回收机制所限，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收就需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上，这是前端浏览器与后端服务器都无法接受的。 当然这个限制也是可以修改的，在启动的时候传入以下参数：12node --max-old-space-size=1700 test.js // 单位为MBnode --max-new-space-size=1024 test.js // 单位为KB max-old-space-size为老生代内存空间，主要存放存活时间较长或常驻内存对象max-new-space-size为新生代内存空间，主要存放存活时间较短的对象这两个参数在V8初始化时生效，一旦生效不可改变，这意味着V8使用的内存无法根据使用情况自动扩充。 补充：默认情况下老生代内存空间 在64位系统上为1464MB，32位系统上为732MB新生代内存空间 在64位系统上为32MB，32位系统上为16MB如果想要跳出V8对内存大小的限制，我们可以使用Buffer，它不经过V8的内存分配机制，所以不存在堆内存的大小限制。由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件操作，而改用fs.createReadStream()和fs.createWriteStream()方法以流的形式实现大文件操作。12345678910var reader = fs.createReadStream(&apos;in.txt&apos;)var writer = fs.createWriteStream(&apos;out.txt&apos;)reader.on(&apos;data&apos;, function (chunk) &#123; writer.write(chunk)&#125;)reader.on(&apos;end&apos;, function () &#123;// 或者使用更简洁的方式：var reader = fs.createReadStream(&apos;in.txt&apos;)var writer = fs.createWriteStream(&apos;out.txt&apos;)reader.pipe(writer) 新生代垃圾回收新生代内存中主要通过 Scavenge 算法（直译捡垃圾吃的算法，手动滑稽）进行， Scavenge 算法具体又使用到 Cheney 算法。其将堆内存一分为二，每一部分空间称为 semispace。这两个空间一个处于使用中（我们称为FROM空间），另一个处于闲置状态（称为TO空间）。分配对象时是在FROM空间中进行分配。 这张是我画的整个过程： Scavenge 算法的缺点是只使用了堆内存中的一半，由于该算法只复制存活对象，且存活时间短的对象很少，所以Scavenge 算法在时间效率上表现优异，正式因为这些特点，所以这个算法很适合新生代垃圾回收。 新生代对象晋升当一个新生代中的对象经过多次新生代回收后任然存活，它将会被认为是生命周期较长的对象，这种对象随后将会被移动到老生代中，这叫做新生代对象晋升。 除此之外如果从FROM复制对象到TO空间时，TO空间的内存占比已经超过了25%，那么这个对象将直接晋升到老生代空间中。 设置25%这个值是因为 Scavenge 回收完成后，当前TO空间会变为FROM空间，如果其使用率过高，会影响后续内存分配。 附两张新生代晋升判断示意图： 老生代垃圾回收老生代中使用了 Mark-Sweep 与 Mark-Compact，来进行垃圾回收。 不使用 Scavenge 有两个原因，一是老生代中对象较多，复制效率会很低，二是老生代比较大，使用 Scavenge 会浪费一半内存空间，这一半就太多了。 Mark-Sweep分为两个阶段标记与清除，标记阶段会遍历堆内存中所有对象，并标记所有活着的对象。在之后的清除阶段将没有被标记的对象释放。 但这样Mark-Sweep会造成内存不连续，带来了内存碎片问题，因此引入了 Mark-Compact，Mark-Compact在Mark-Sweep基础上演变而来，它在整理的时候会将活着的对象往一端移动，整理与移动完成之后，直接清掉边界外的内存，完成回收。 Mark-Sweep的清理过程 但Mark-Sweep带来了内存碎片问题，Mark-Compact就是用来解决这个问题的 在V8中两种回收策略是结合使用的，Mark-Compact要移动对象，速度不快，故V8优先使用Mark-Sweep，在空间不足以分配给晋升对象时才使用Mark-Compact。 垃圾回收时的增量标记（Incremental Marking）垃圾回收执行时，代码运行是完全暂停的，在垃圾回收后，才会继续执行，这种行为被称为全停顿。 由于新生代内存空间不大，清理较快，即使全停顿对代码运行影响也不大。 但老生代就不能这样了，老生代通常都比较大，代码如果全停顿下来等待老生代垃圾回收完成就很可怕了。所以老生代采取的是垃圾回收与逻辑代码交替执行，清理一小段，就让代码执行一小会儿，这个交替执行直到标记阶段完成。 …未完 参考： 《深入浅出Node.js》","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"学习Vue源码6-nextTick的实现原理","slug":"学习Vue源码6-nextTick的实现原理","date":"2019-04-22T03:49:10.000Z","updated":"2019-06-26T07:51:50.001Z","comments":true,"path":"2019/04/22/学习Vue源码6-nextTick的实现原理/","link":"","permalink":"http://yoursite.com/2019/04/22/学习Vue源码6-nextTick的实现原理/","excerpt":"","text":"nextTick的实现原理 core/util/next-tick.js作用：Vue的DOM更新是异步的，nextTick可以让我们在下次DOM更新后，拿到更新后的DOM。 原理（Vue版本2.6.8）： 四套方案： Promise MutationObserver setImmediate setTimeout 依据运行环境的支持度，层层降级，最后的方案是都支持的 setTimeout 源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import &#123; noop &#125; from &apos;shared/util&apos;import &#123; handleError &#125; from &apos;./error&apos;import &#123; isIE, isIOS, isNative &#125; from &apos;./env&apos;export let isUsingMicroTask = false// 用于存放要执行的callback listsconst callbacks = []// 状态flaglet pending = false// 这个函数会将所有点饿callback拿出来执行function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;// 定义一个定时器方法变量，在下面的代码中会根据运行环境的不同赋予其不同的值let timerFuncif (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123; // 1.优先使用 Promise const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;)) &#123; // 2.次选方案 MutationObserver，其提供了监视对DOM树所做更改的能力 let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123; // 3.降级方案 setImmediate，其优于 setTimeout timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // 4.如果以上都不支持，则最终会使用 setTimeout timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &apos;nextTick&apos;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // pending为false就直接执行timerFunc if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用Gitlab-runner部署Gitlab的项目","slug":"使用Gitlab-runner部署Gitlab的项目","date":"2019-04-18T01:29:44.000Z","updated":"2019-06-26T07:51:49.999Z","comments":true,"path":"2019/04/18/使用Gitlab-runner部署Gitlab的项目/","link":"","permalink":"http://yoursite.com/2019/04/18/使用Gitlab-runner部署Gitlab的项目/","excerpt":"","text":"Step1 Linux 对 Linux 免密登录在这篇文章中已经实现了 Windows 对 Linux 的免密登录，Linux 对 Linux 也是类似的。 特别注意：我们在搭建 gitlab-runner 时创建了一个叫 ‘gitlab-runner’ 的用户，gitlab-runner 所有的操作都是在 ‘gitlab-runner’ 帐号下进行的可以在脚本中加入 whoami 命令查看：123whoami# 可以看到确实是 gitlab-runner 用户gitlab-runner 所以免密登录也应该在 ‘gitlab-runner’ 帐号下配置，如果是用了 ‘root’ 帐号配的免密登录，gitlab-runner 跑到免密登录时则会看到报错：12Host key verification failed.ERROR: Job failed: exit status 1 因为 ‘gitlab-runner’ 用户根本没有免密登录权限 登录gitlab-runner用户还记得我们在安装gitlab-runner时，有这样一行命令吗？1sudo useradd --comment &apos;GitLab Runner&apos; --create-home gitlab-runner --shell /bin/bash 就是在这里创建了gitlab-runner帐号如果没有，需重新创建，然后修改密码注意：这里修改密码不会影响 gitlab-runner 使用该账户1passwd gitlab-runner 接着使用gitlab-runner帐号登录，然后继续 假设我们要用机器A登录机器B 首先在机器A中生成公、私钥1ssh-keygen -t rsa 接着一路回车，然后可以键入以下命令查看生成的内容123cd ~/.sshls -a. .. authorized_keys id_rsa id_rsa.pub known_hosts 在机器A上输入以下命令，将机器A的公钥发送给机器B1ssh-copy-id root@xx.xx.xxx.xx # 机器B的公网IP 接着按提示输入yes或回车，最后需要输入机器B的密码，成功的话将会看到1Number of key(s) added: 1 尝试登录机器B12ssh root@xx.xx.xxx.xxWelcome to Alibaba Cloud Elastic Compute Service ! Step2 在本地创建一个项目这里直接使用 Vue-cli 生成项目1vue create gitlab-vue 本地运行一下 在 Gitlab 上也创建一个项目，将本地项目推送到 Gitlab 的项目中123456cd existing_foldergit initgit remote add origin git@xx.xx.xxx.xx:root/gitlab-vue.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master Step3 编写 .gitlab-ci.yml 文件在项目根目录创建 .gitlab-ci.yml 文件主要流程如下 安装构建依赖。 打包新文件。 登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去。 注意这里前两步都是在Gitlab-runner上完成的 根据流程我们先定义以下基本步骤，并提交，之后可以看到Pipelines一切正常12345678910111213141516171819202122232425262728293031323334353637383940stages: - install_deps - build_prod - deploy_prodcache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/ - dist# 安装构建依赖install_deps_job: stage: install_deps only: - master script: - echo &apos;安装构建依赖阶段&apos; tags: - my-tag# 打包新文件build_prod_job: stage: build_prod only: - master script: - echo &apos;打包新文件阶段&apos; tags: - my-tag# 登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去deploy_prod_job: stage: deploy_prod only: - master script: - echo &apos;登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去&apos; tags: - my-tag 接下来分步解决 1.安装构建依赖这一步比较简单，直接安装依赖即可注意：要先在服务器上安装 nodeJs，否则会报错 npm: command not found 安装方法看这里：linux下node的安装以及环境配置12345678910111213# 安装构建依赖install_deps_job: stage: install_deps # 这一步在多个分支上都会执行，一般会将所有环境的分支名都写上去 only: - dev - master script: - echo &apos;安装构建依赖阶段&apos; - pwd # 我们查看一下现在的目录位置: /home/gitlab-runner/builds/6_sebBuN/0/root/gitlab-vue - npm i # 安装依赖 tags: - my-tag 我们提交一下在 Gitlab-runner 服务器中我们输入以下命令查看一下12345678cd /home/gitlab-runner/builds/6_sebBuN/0/root/gitlab-vuels -a# 这里看到 node_modules 文件夹，说明已成功安装依赖. .editorconfig .gitlab-ci.yml public.. .eslintrc.js node_modules README.mdbabel.config.js .git package.json src.browserslistrc .gitignore postcss.config.js yarn.lock 2.打包新文件Vue-cli3 的打包命令会将项目打包在 dist 文件夹中这一步我们先移除旧版本的 dist 文件夹，然后重新打包1234567891011121314# 打包新文件build_prod_job: stage: build_prod only: - master script: - echo &apos;打包新文件阶段&apos; - pwd # 查看当前目录 - ls -a # 查看所有文件 - rm -rf ./dist # 删除当前文件夹下的 dist 文件夹 - npm run build # 打包 - ls -a # 打包完成，再次查看所有文件 tags: - my-tag 提交代码，在Pipeline中可以看到目录中多出了 dist 文件夹123456789101112131415161718$ ls -a...babel.config.js.browserslistrcdist # 这里多出了 dist 文件夹.editorconfig.eslintrc.js.git.gitignore.gitlab-ci.ymlnode_modulespackage.jsonpostcss.config.jspublicREADME.mdsrcyarn.lock 3.登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去我们在项目服务器的 root 新建 www 文件夹，用来放我们的项目打包文件 1234567891011121314151617181920# 登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去deploy_prod_job: stage: deploy_prod only: - master script: - echo &apos;登录项目部署服务器，移除旧版本项目文件，最后将打包好的文件拷贝过去&apos; - cd dist # 进入dist - pwd - whoami # gitlab-runner # 登录目标服务器 - ssh root@39.98.177.19 # 列出所有文件 - ssh root@39.98.177.19 &quot;ls -a&quot; # 删 www 文件夹下所有内容 - ssh root@39.98.177.19 &quot;rm -rf ./www/*&quot; # 使用 scp 命令远程拷贝文件 - scp -r -P 22 ./* root@39.98.177.19:/root/www tags: - my-tag 这里 ssh root@39.98.177.19 可能会报错 Pseudo-terminal will not be allocated because stdin is not a terminal.字面意思是伪终端将无法分配，因为标准输入不是终端。增加-t -t参数来强制伪终端分配，即使标准输入不是终端， 这里不用理会！。1ssh -t -t root@xx.xx.xxx.xx Step4 在项目服务器上安装 Nginx在阿里云安全组规则添加一个端口8889之前有弄过，这里不再赘述。 安装依赖包1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载Nginx并解压1234567cd /usr/localmkdir nginxcd nginx# 下载tar包wget http://nginx.org/download/nginx-1.13.7.tar.gz# 解压tar -xvf nginx-1.13.7.tar.gz 安装Nginx1234567cd /usr/local/nginx/nginx-1.13.7 # 执行./configure# 执行make命令make# 执行make installmake install 修改Nginx配置文件1vi /usr/local/nginx/conf/nginx.conf 做如下修改12345678910111213141516171819# user nobody;# ... 省略http&#123; server &#123; listen 8889; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /root/www; index index.html index.htm; &#125; &#125; # ... 省略&#125; 重启Nginx12cd /usr/local/nginx/sbin./nginx -s reload 访问IP+端口，我这里发现返回了403回到Nginx配置文件，将user nobody 的注释打开，并修改为 user root;12345678910111213141516171819user root;# ... 省略http&#123; server &#123; listen 8889; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /root/www; index index.html index.htm; &#125; &#125; # ... 省略&#125; 重启，终于可以正常访问了 我们修改代码，并提交，等待构建完成，刷新页面，可以看到修改已成功添加 参考： 如何在 CentOS 安装 node.js解决nginx 403forbidden问题","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"Linux免密登录","slug":"Linux免密登录","date":"2019-04-17T09:45:24.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2019/04/17/Linux免密登录/","link":"","permalink":"http://yoursite.com/2019/04/17/Linux免密登录/","excerpt":"","text":"准备工作：一台Linux系统服务器一台电脑（我的是windows 10系统） Step1 windows上生成 ssh key生成ssh key（这里替换为你的邮箱）1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 进入ssh目录1cd ~/.ssh 查看所有文件12ls -a # 可以看到 id_rsa id_rsa.pub 查看公钥内容（注意是.pub结尾的公钥文件）1cat id_rsa.pub 复制公钥内容1ssh-rsa XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX youremail@example.com Step2 Linux中写入上一步复制的公钥登录 Linux 服务器，执行命令1ssh-keygen -t rsa 然后一路回车 然后进入 .ssh1cd ~/.ssh 编辑 authorized_keys 文件1vi authorized_keys 进入编辑后，按 I 进入修改，将我们电脑上的公钥复制进去。修改完成后 依次按 Esc、:、w、q，回车保存修改。 然后查看一下12cat authorized_keysssh-rsa XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX youremail@example.com 看到已成功修改 登录一下1ssh root@xx.xxx.xxx.xxx # 填你的服务器IP 如果你的服务器是阿里云且重装过系统，可能会遇到以下报错12345678910111213@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:xi/sxkP1juN+73HCAhkSXRMCuN48zfMjDTUylonzAPo.Please contact your system administrator.Add correct host key in /c/Users/Wen Minghui/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /c/Users/Wen Minghui/.ssh/known_hosts:8ECDSA host key for xx.xxx.xxx.xxx has changed and you have requested strict checking.Host key verification failed. 解决：使用命令清除所连接的服务器IP1ssh-keygen -R XX.XX.XX.XX 再次尝试连接1ssh root@xx.xxx.xxx.xxx 可以看到登录成功123Last login: Wed Apr 17 18:03:44 2019 from 14.154.30.158Welcome to Alibaba Cloud Elastic Compute Service ! 如果是 Linux 对 Linux 的免密登录也是差不多的，下一篇就使用 Gitlab-runner 结合免密登录自动部署 Gitlab 上的项目。参考 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 的解决","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"安装Gitlab-runner","slug":"安装Gitlab-runner","date":"2019-04-17T01:34:02.000Z","updated":"2019-06-26T07:51:50.002Z","comments":true,"path":"2019/04/17/安装Gitlab-runner/","link":"","permalink":"http://yoursite.com/2019/04/17/安装Gitlab-runner/","excerpt":"","text":"前置工作两台服务器，我的都是Linux CentOS 7.6 64位一台用需要安装 Gitlab，关于如何安装 Gitlab ，可查看这篇文章 阿里云安装GITLAB笔记。另一台用于安装 Gitlab-runner。 Step1：安装Gitlab-runner下载系统对应的Gitlab-runner（当前安装版本为11.9.2）：12345678# Linux x86-64sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64# Linux x86sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386# Linux armsudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm 给Gitlab-runner添加执行权限：1sudo chmod +x /usr/local/bin/gitlab-runner 如果想使用 Docker 可以安装 Docker（不使用可直接跳过）1curl -sSL https://get.docker.com/ | sh 创建一个 GitLab CI 用户1sudo useradd --comment &apos;GitLab Runner&apos; --create-home gitlab-runner --shell /bin/bash 安装并启动服务12sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runnersudo gitlab-runner start Step2：注册Runner运行以下命令开始注册：1sudo gitlab-runner register 填入Gitlab URL：123Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )# 没有域名所以填的是IPhttp://xx.xx.xxx.xx:8888 输入注册Runner所需要的token：这里的token分为两种一种是 Shared Runner ，该 Runner 所有项目都可以使用位置：顶部设置图标🔧 -&gt; 左侧栏Overview -&gt; Runner另一种是 Specific Runner ，该 Runner 指定具体某个项目才可使用位置：进入某个项目 -&gt; 左侧栏Setting -&gt; CI/CD -&gt; 在内容区域找到Runners一项，点击展开123Please enter the gitlab-ci token for this runner# 这里我们使用 Shared Runner Tokenxxxxxxx 输入一个Runner的description ，可以在稍后的GitLab的UI中更改这个描述：12Please enter the gitlab-ci description for this runnertest-gitlab-runner-description 输入Runner的tags（这个tags后面会用到）12Please enter the gitlab-ci tags for this runner (comma separated)my-tag 选择Runner的执行者这里我使用 shell。12Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell 如果一切正常的话我们会看到1Runner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded! 如果选择了Docker则需要额外一步：12Please enter the Docker image (eg. ruby:2.1):alpine:latest 我们回到Share Runners 就可以看到我们添加的 runner 了 Step3 创建项目与 .gitlab-ci.yml 文件在项目根目录下创建 .gitlab-ci.yml 文件，然后用 git 提交。1234567891011121314151617181920212223242526272829303132333435363738394041424344# 定义 stages（阶段，会依次执行）stages: - install_deps - build_prod - deploy_prodcache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/ - dist# 安装构建依赖install_deps_job: stage: install_deps # 在哪个分支才会执行脚本 only: # - dev # - release - master script: - echo &apos;模拟安装构建依赖阶段&apos; tags: - my-tag# 构建预prod环境src目录下应用build_prod_job: stage: build_prod only: - master script: - echo &apos;构建预prod环境src目录下应用阶段&apos; tags: - my-tag# 部署生产环境deploy_prod_job: stage: deploy_prod only: - master script: - echo &apos;部署生产环境阶段&apos; tags: - my-tag 然后你可能会看到报错1234567Running with gitlab-runner 11.9.2 (fa86510e) on desc Z1UPKJjnUsing Shell executor...Running on iZwz98jvb8bcz40ko474qsZ...bash: line 68: git: command not foundbash: line 66: cd: /home/gitlab-runner/builds/Z1UPKJjn/0/main-group/main-project: No such file or directoryERROR: Job failed: exit status 1 报错的原因是我的服务器是一台只安装了 Gitlab-runner 的服务器，根据报错提示，需要 git 来拉取 Gitlab 服务器上的代码，所以我们安装 git：1yum -y install git 然后使用1git --version 查看 git 是否安装成功 之后重新执行pipline或提交代码，可以看到一切运行正常： 注意点： Gitlab-runner 服务器上需要安装 Git。 全部配置好了，提交后却一直处于 pending 状态并且提示：This build is stuck, because the project doesn&#39;t have any runners online assigned to it. Go to Runners page,这是因为未找到对应的 runner，原因一：可能是gitlab-runner注册失败，原因二：可能是.gitlab-ci.yml配置文件里面 tags 没有匹配到已注册可用的 runner，在 stage 中加入对应 runner 注册时输入的 tags 即可。 GitLab 最好不要与 GitLab Runner 装在同一台机器上。 参考: Install GitLab Runner manually on GNU/LinuxRegistering RunnersGitLab Runner commandsGitLab CI/CD Pipeline Configuration ReferenceDocker搭建自己的Gitlab CI Runner","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"阿里云安装Gitlab笔记","slug":"阿里云安装Gitlab笔记","date":"2019-04-16T08:35:35.000Z","updated":"2019-06-26T07:51:50.004Z","comments":true,"path":"2019/04/16/阿里云安装Gitlab笔记/","link":"","permalink":"http://yoursite.com/2019/04/16/阿里云安装Gitlab笔记/","excerpt":"","text":"前置工作 一台阿里云服务器（2核4G以上） 配置服务器入方向安全组规则，我这里配置了8888端口（阿里云安全组出方向默认允许所有访问，所以不用配置） Step1：安装和配置必要依赖项访问 Gitlab安装地址，选择对应系统的安装方式，我的是 CentOS 7.6 故选择 CentOS 7.X 的安装方式。 如何查看自己是什么系统：1lsb_release -a 在CentOS 7(以及RedHat/Oracle/Science Linux 7)上，使用下面的命令打开系统防火墙中的HTTP和SSH访问。12345sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 在执行 sudo firewall-cmd --permanent --add-service=http 时可能会遇到 FirewallD is not running 错误提示，意思是未运行防火墙。使用以下命令开启防火墙即可：1systemctl start firewalld.service 接下来，安装 Postfix 邮件通知服务。如果要使用其他解决方案，可跳过此步，并在安装GitLab之后配置外部SMTP服务器。123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 这一步可能会遇到一个报错 Job for postfix.service failed because the control process exited with error code. See &quot;systemctl status postfix.service&quot; and &quot;journalctl -xe&quot; for details.解决方法是修改 /etc/postfix/main.cf 的配置，使用：1vi /etc/postfix/main.cf 进入编辑 ‘main.cf’，按 I 进入修改：12inet_interfaces = allinet_protocols = ipv4 // 或 all 修改完成后 依次按 Esc、:、w、q，回车保存修改，之后重启服务。1sudo systemctl restart postfix Step2：添加GitLab包存储库并安装该包设置防火墙：1234# 开启 8888 端口firewall-cmd --zone=public --add-port=8888/tcp --permanent# 重启防火墙systemctl restart firewalld 添加GitLab包的仓库1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 接下来，安装Gitlab包：1sudo EXTERNAL_URL=&quot;https://gitlab.example.com&quot; yum install -y gitlab-ee 将https://gitlab.example.com更改为您要访问GitLab实例的URL。 安装将自动配置并启动该URL的GitLab。 我这里没有域名就直接使用 IP + 端口号的形式：1sudo EXTERNAL_URL=&quot;xx.xx.xxx.xx:8888&quot; yum install -y gitlab-ee 然后等待安装 如果安装完之后要修改访问的域名或者 IP，则需修改 /etc/gitlab/gitlab.rb 文件中的 external_url 一项，修改方法与上面修改 /etc/postfix/main.cf 的一样。 之后重新配置服务1gitlab-ctl reconfigure Step3：登录经过上面，的安装与设置，就可以访问域名或者IP了。打开xx.xx.xxx.xx:8888，需要设置root帐号的密码，之后即可使用root帐号登录。这里忘记截图了，就附上用户设置的一张截图吧 附:Gitlab常用命令：1234567891011121314//启动sudo gitlab-ctl start//停止sudo gitlab-ctl stop//重启sudo gitlab-ctl restart//查看状态sudo gitlab-ctl status//使更改配置生效sudo gitlab-ctl reconfigure 参考: GitLab Installation阿里云 GitLab 折腾笔记CentOS下yum命令出现Loaded plugins: fastestmirrorFailed to set locale, defaulting to C解决","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"在Hexo生成的github博客中使用本地图片","slug":"在Hexo生成的github博客中使用本地图片","date":"2019-04-16T06:36:44.000Z","updated":"2019-06-26T07:51:50.000Z","comments":true,"path":"2019/04/16/在Hexo生成的github博客中使用本地图片/","link":"","permalink":"http://yoursite.com/2019/04/16/在Hexo生成的github博客中使用本地图片/","excerpt":"","text":"将项目根目录的 _config.yml 中的 post_asset_folder 字段设为 true。 将 post_asset_folder 设置为 true 后 使用 hexo new “filename” 命令时会在_posts下生成一个同名文件夹。 安装 npm install hexo-asset-image –save 键入 hexo new “test” 命令，创建一片名为test的博文。 将图片资源放入test文件夹中。 1234|- _posts|- test|- Bg.png|- test.md 在test.md写入图片地址 test/Bg.png。 运行 hexo server 即可看到效果。 由于本blog使用的 anatole 主题在安装 hexo-asset-image 时报错，这里不做深究，故将图片放入github上另外一个项目中，再在博客中引用github资源。","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/其他/"}],"tags":[]},{"title":"Nuxt的plugins中的异步操作","slug":"Nuxt的plugins中的异步操作","date":"2019-03-27T09:06:13.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2019/03/27/Nuxt的plugins中的异步操作/","link":"","permalink":"http://yoursite.com/2019/03/27/Nuxt的plugins中的异步操作/","excerpt":"","text":"关于Nuxt的plugins官方文档提到的内容并不多：1234// nuxt.config.jsmodule.exports = &#123; plugins: [&apos;~plugins/vue-notifications&apos;]&#125; 12345// plugins/vue-notifications.jsimport Vue from &apos;vue&apos;import VueNotifications from &apos;vue-notifications&apos;Vue.use(VueNotifications) plugins 属性配置的所有插件会在 Nuxt.js 应用初始化之前被加载导入。 每次你需要使用 Vue.use() 时，你需要在 plugins/ 目录下创建相应的插件文件，并在 nuxt.config.js 中的 plugins 配置项中配置插件的路径。 如果我们需要一些异步操作，比如，一个多语言网站，想要调用接口获取多语言配置文件，再挂载到Vue-i18n上，则可使用如下方法： 导出一个默认函数，返回一个Promise（可为axios请求），异步操作完成后再进行挂载。1234567891011121314151617181920212223242526272829303132333435363738import Vue from &apos;vue&apos;import VueI18n from &apos;vue-i18n&apos;import En from &apos;~/locales/en.js&apos;import De from &apos;~/locales/de.js&apos;Vue.use(VueI18n)export default (&#123; app, store &#125;) =&gt; &#123; let p = new Promise(function (resolve, reject) &#123; //做一些异步操作 setTimeout(function () &#123; // Set i18n instance on app // This way we can use it in middleware and pages asyncData/fetch app.i18n = new VueI18n(&#123; locale: store.state.locale, fallbackLocale: &apos;en&apos;, messages: &#123; // en: require(&apos;~/locales/en.json&apos;), // cn: require(&apos;~/locales/cn.json&apos;) en: En, // 英 de: De, // 德 &#125; &#125;) app.i18n.path = link =&gt; &#123; if (app.i18n.locale === app.i18n.fallbackLocale) &#123; return `/$&#123;link&#125;` &#125; return `/$&#123;app.i18n.locale&#125;/$&#123;link&#125;` &#125; resolve() &#125;, 3000) &#125;) return p&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用void 0代替undefined","slug":"使用void0代替undefined","date":"2019-03-20T03:41:13.000Z","updated":"2019-06-26T07:51:49.999Z","comments":true,"path":"2019/03/20/使用void0代替undefined/","link":"","permalink":"http://yoursite.com/2019/03/20/使用void0代替undefined/","excerpt":"","text":"为什么建议使用void 0 来替代 undefined ? undefined 不是保留字，在低版本的IE浏览器中会被重写。 1234var undefined = 1console.log(undefined)// chrome undefined// 低版本IE 1 局部作用域中 undefined 仍然可以被重写。 123456(function() &#123; var undefined = 1 console.log(undefined) // chrome 1 // 低版本IE 1&#125;)() void 后面无论跟什么，其返回的都是 undefined ，且无法被修改。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"简单了解网页直播","slug":"简单了解网页直播","date":"2019-03-19T07:57:13.000Z","updated":"2019-06-26T07:51:50.003Z","comments":true,"path":"2019/03/19/简单了解网页直播/","link":"","permalink":"http://yoursite.com/2019/03/19/简单了解网页直播/","excerpt":"","text":"直播协议HLSHLS 全称是 HTTP Live Streaming。这是 Apple 提出的直播流协议。目前，IOS 和 高版本 Android 都支持 HLS。那什么是 HLS 呢？ HLS 主要的两块内容是 .m3u8 文件和 .ts 播放文件。接受服务器会将接受到的视频流进行缓存，然后缓存到一定程度后，会将这些视频流进行编码格式化，同时会生成一份 .m3u8 文件和其它很多的 .ts 文件。HLS 的基本架构为： 服务器：后台服务器接受视频流，然后进行编码和片段化。 编码：视频格式编码采用 H.264。音频编码为 AAC, MP3, AC-3，EC-3。然后使用 MPEG-2 Transport Stream 作为容器格式。 客户端：使用一个 URL 去下载 m3u8 文件，然后，开始下载 ts 文件，下载完成后，使用 playback software（即时播放器） 进行播放。 masterplaylist： live playlist: 动态列表。顾名思义，该列表是动态变化的，里面的 ts 文件会实时更新，并且过期的 ts 索引会被删除。默认，情况下都是使用动态列表。 event playlist: 静态列表。它和动态列表主要区别就是，原来的 ts 文件索引不会被删除，该列表是不断更新，而且文件大小会逐渐增大。它会在文件中，直接添加 #EXT-X-PLAYLIST-TYPE:EVENT 作为标识。 VOD playlist: 全量列表。它就是将所有的 ts 文件都列在 list 当中。如果，使用该列表，就和播放一整个视频没有啥区别了。它是使用 #EXT-X-ENDLIST 表示文件结尾。 m3u8文件内容（以下为live playlist，不包含汉字）123456789101112#EXTM3U m3u文件头#EXT-X-VERSION:3 PlayList版本#EXT-X-ALLOW-CACHE:NO 是否允许缓存#EXT-X-TARGETDURATION:5 分片最大时长，单位秒#EXT-X-MEDIA-SEQUENCE:1552956728 第一个TS分片的序列号，默认为 0#EXTINF:3.469, 指定每个媒体段(ts)的持续时间（秒），仅对其后面的URI有效http://media.test.com/1552956727.ts#EXTINF:4.145,http://media.test.com/1552956728.ts#EXTINF:4.141,http://media.test.com/1552956729.ts HLS如何完成直播？服务端：将接收到的流每缓存一定时间后包装为一个新的ts文件，然后更新m3u8文件。m3u8文件中只保留最新的几个片段。 客户端：直接使用video标签加载m3u8文件（live playlist），video标签会自动解析其内容进行直播播放。 1&lt;video src=&quot;http://hlsa.xxxxx.com/live/test.m3u8&quot; autoplay controls&gt;&lt;/video&gt; HLS的优点支持范围广，使用简单，完美适用于H5，是移动端天生的直播方案。 HLS的缺点由于 HLS 是基于 HTTP 的，所以其直播延迟较高。带来延迟的主要地方有： TCP 握手 m3u8 文件下载 m3u8 文件下所有 ts 文件下载 HLS的优化方案减少每个 m3u8 文件中的 ts文件的 数量和时长，但单个ts文件时间变短会增加服务器性能消耗。 RTMPRTMP即Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，它是基于 FLV 格式进行开发的，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信。 纯 RTMP: 直接通过 TCP 连接，端口为 1935 RTMPS: RTMP + TLS/SSL，用于安全性的交流。 RTMPE: RTMP + encryption。在 RTMP 原始协议上使用，Adobe 自身的加密方法 RTMPT: RTMP + HTTP。使用 HTTP 的方式来包裹 RTMP 流，这样能直接通过防火墙。不过，延迟性比较大。 RTMFP: RMPT + UDP。该协议常常用于 P2P 的场景中，针对延时有变态的要求。 RTMP的优点 延迟小 基于 TCP 长连接，不需要多次建连 只要浏览器支持FlashPlayer就能非常简易的播放。 RTMP的缺点 协议复杂，会提高开发成本。 它是基于 TCP 传输，非公共端口，可能会被防火墙阻拦。 RTMP 为 Adobe 私有协议，很多设备无法播放，需要使用第三方解码器才能播放。 有累积延迟，当网络状态差时，服务器会将包缓存起来，导致累积的延迟，解决方案是当客户端的缓冲区很大，就断开重连。 HTTP-FLVHTTP-FLV将音视频数据封装成 FLV，然后通过 HTTP 协议传输给客户端。 HTTP-FLV 与 RTMPT类似，都是针对于 FLV 视频格式做的直播分发流。 两者相同点 都是针对 FLV 格式 延时低 走的 HTTP 通道 两者不同点 HTTP-FLV直接发起长连接，下载对应的FLV文件，且头部信息简单。 RTMPT的握手协议过于复杂，分包，组包过程耗费资源大。 因为 RTMP 发的包很容易处理，通常 RTMP 协议会作为视频上传端来处理，然后经由服务器转换为 FLV 文件，通过 HTTP-FLV 下发给用户。 现在市面上，比较常用的就是 HTTP-FLV 进行播放。HTTP-FLV 的使用方式也很简单。和 HLS 一样，只需要添加一个连接即可12// 这里的.flv指的是FLV直播流，并不是说.flv结尾的都是HTTP-FLV 协议&lt;object type=&quot;application/x-shockwave-flash&quot; src=&quot;http://hlsa.xxxxx.com/live/test.flv&quot;&gt;&lt;/object&gt; 在高版本浏览器中，可是通过MSE（Media Source Extensions）来进行解析，MSE在下面会提到。 HTTP-FLV优点 延迟小 相对于RTMP，HTTP-FLV不会被防火墙墙掉 HTTP-FLV缺点 手机端不支持 协议对比 协议 传输协议 优势 缺陷 延迟 HLS TCP 手机浏览器完美支持 延迟高 10s以上 RTMP HTTP 能推能播，延迟低，私密性好 协议复杂，高并发表现不佳 1s - 3s HTTP-FLV HTTP 延迟低，直播网站常用 手机端不支持 2s - 3s MSE（Media Source Extensions）由于各大浏览器的对 FLV 的围追堵截，导致 FLV 在浏览器的生存状况堪忧，但由于 FLV 格式简单、处理效率高的特点，各大视频站后台开发者都不愿弃用，如果一旦更改的话，就需要对现有视频进行转码，而转码带来的一些列问题都让人无法接受。 而MSE（Media Source Extensions）的出现，解决的这一问题。 在没有 MSE 出现之前，前端对 video 的操作，仅仅局限在对视频文件的操作，并不能对视频流做任何相关的操作。现在 MSE 提供了一系列的接口，使开发者可以直接操作 media stream。 我们以MDN的例子来看下 MSE 是如何完成基本流的处理的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172var video = document.querySelector(&apos;video&apos;);var assetURL = &apos;frag_bunny.mp4&apos;;// 需要针对Blink特定的编解码器// ./mp4info frag_bunny.mp4 | grep Codecvar mimeCodec = &apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;;// 检测是否支持MediaSource &amp; 是否支持上面的mine编码if (&apos;MediaSource&apos; in window &amp;&amp; MediaSource.isTypeSupported(mimeCodec)) &#123; // 创建MediaSource实例 var mediaSource = new MediaSource(); // console.log(mediaSource.readyState); // closed 当前状态为关闭 /* 使用URL.createObjectURL，传入MediaSource实例来创建URL 使 MediaSource 与 &lt;video&gt; 建立联系 创建出的URL就是在各直播平台的html代码中能看到的blob形式 blob:https://www.test.com/eb639f5a-4a64-4e9c-819f-e0ecca7d7bf0 */ video.src = URL.createObjectURL(mediaSource); // 监听mediaSource的sourceopen事件，再sourceOpen函数中进行下一步操作 mediaSource.addEventListener(&apos;sourceopen&apos;, sourceOpen);&#125; else &#123; console.error(&apos;Unsupported MIME type or codec: &apos;, mimeCodec);&#125;function sourceOpen (_) &#123; //console.log(this.readyState); // open 当前状态已经开启 var mediaSource = this; /* 设置相关的编码器 接收一个 mimeType 表示该流的编码格式，返回一个具体的视频流sourceBuffer。 sourceBuffer 是直接与视频流相关的API。 */ var sourceBuffer = mediaSource.addSourceBuffer(mimeCodec); // 异步拉取相关的音视频流 fetchAB(assetURL, function (buf) &#123; /* 添加sourceBuffer的updateend事件的监听 sourceBuffer.appendBuffer会触发updateend */ sourceBuffer.addEventListener(&apos;updateend&apos;, function (_) &#123; // 停止接收视频流（注意：并不是中断的意思） mediaSource.endOfStream(); // 播放视频 video.play(); //console.log(mediaSource.readyState); // ended 当前状态为结束 &#125;); // 将`视频流`添加到sourceBuffer中 sourceBuffer.appendBuffer(buf); &#125;);&#125;;// 异步拉取相关的音视频流function fetchAB (url, cb) &#123; console.log(url); var xhr = new XMLHttpRequest; xhr.open(&apos;get&apos;, url); xhr.responseType = &apos;arraybuffer&apos;; xhr.onload = function () &#123; cb(xhr.response); &#125;; xhr.send();&#125;; 以上代码大致可分为3步（具体可看代码注释）： 异步拉取数据 MediaSource 处理数据 将数据流交给 audio/video 标签播放 以上代码只是播放了一段视频，如果想要做到直播，那么我们就需要不停的获取最新的视频流，然后再合适的时候调用sourceBuffer.appendBuffer(buf)添加到sourceBuffer中。 将代码做一下修改，多添加几个视频流，是不是就可以做到直播了呢？： 12345678910sourceBuffer.addEventListener(&apos;updateend&apos;, function (e) &#123; if (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === &apos;open&apos;) &#123; mediaSource.endOfStream() video.play() &#125;&#125;)sourceBuffer.appendBuffer(buf)// 多添加几个视频流sourceBuffer.appendBuffer(buf)sourceBuffer.appendBuffer(buf) 运行代码我们发现报错了：Failed to execute &#39;appendBuffer&#39; on &#39;SourceBuffer&#39;: This SourceBuffer is still processing an &#39;appendBuffer&#39; or &#39;remove&#39; operation.意思是，SourceBuffer现在正在添加appendBuffer，还没加完，不要再往里面加了，这就非常尴尬了。 正确的做法是应该在sourceBuffer的updateend事件中进行appendBuffer操作。例如：12345678910111213141516171819202122var i = 1sourceBuffer.addEventListener(&apos;updateend&apos;, function (e) &#123; if (!sourceBuffer.updating &amp;&amp; mediaSource.readyState === &apos;open&apos;) &#123; mediaSource.endOfStream() video.play() &#125; 假如一段视频5s长，我们在第4s的时候appendBuffer if (mediaSource.readyState === &apos;ended&apos;) &#123; setTimeout(() =&gt; &#123; try &#123; 设置添加的视频流播放的起始时间 sourceBuffer.timestampOffset = 5 * i sourceBuffer.appendBuffer(arrayBuffer) &#125; catch (e) &#123; console.error(e) &#125; finally &#123; i++ &#125; &#125;, 4000); &#125;&#125;)sourceBuffer.appendBuffer(buf) 这样一直appendBuffer，就可以达到直播效果。 注：chrome 的 SourceBuffer 大小为 音频 12 MB, 视频 150 MB，如果一直添加SourceBuffer是会满的，会捕获到The SourceBuffer is full, and cannot free space to append additional buffers的报错。 关于如何定时获取直播视频、如何正确的处理 SourceBuffer 的缓存内容，以及相关错误处理，这里不做了解。 总结 手机端： 简单粗暴，直接使用 HLS （.m3u8） 来直播。 PC端： 对于高版本浏览器，可直接使用 Media Source Extensions 处理视频流，加 video 直播。 对于不支持的MSE的浏览器可降级为 HTTP-FLV 或 RTMP 直播。 补充： 国内90%的直播平台都是采用的RTMP和HTTP-FLV的混合，HLS很少，而国外大部分采用的DASH，少部分用HLS和其他协议。 参考： https://cloud.tencent.com/developer/article/1020510 https://cloud.tencent.com/developer/article/1005457 https://segmentfault.com/a/1190000010440054 https://www.jianshu.com/p/1bfe4470349b","categories":[{"name":"直播","slug":"直播","permalink":"http://yoursite.com/categories/直播/"}],"tags":[]},{"title":"学习Vue源码5-数组操作的hack处理","slug":"学习Vue源码5-数组操作的hack处理","date":"2019-03-16T08:12:10.000Z","updated":"2019-06-26T07:51:50.001Z","comments":true,"path":"2019/03/16/学习Vue源码5-数组操作的hack处理/","link":"","permalink":"http://yoursite.com/2019/03/16/学习Vue源码5-数组操作的hack处理/","excerpt":"","text":"core\\observer\\array.jsObject.defineProperty不能监听数组的变化，这里是对数组操作的hack处理 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; def &#125; from &apos;../util/index&apos;const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ &apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;]/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &apos;push&apos;: case &apos;unshift&apos;: inserted = args break case &apos;splice&apos;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码4-简版响应式数据原理","slug":"学习Vue源码4-简版响应式数据原理","date":"2019-03-15T09:12:10.000Z","updated":"2019-06-26T07:51:50.001Z","comments":true,"path":"2019/03/15/学习Vue源码4-简版响应式数据原理/","link":"","permalink":"http://yoursite.com/2019/03/15/学习Vue源码4-简版响应式数据原理/","excerpt":"","text":"上一篇中提到了initData中会调用observe方法，然后会利用Object.defineProperty对data进行劫持，这里来简单实现以下响应式数据原理； 具体步骤如下： Observer对Obj的每一个属性调用defineReactive方法，defineReactive会使用Object.defineProperty来监听数据的get、set； Dep用来记录有哪些订阅者（Watcher）订阅了这个数据，并提供add方法添加订阅者（Watcher）、notify方法通知所有订阅者（Watcher）更新视图； 在defineReactive中会 new 一个 Dep()，Dep的subs中储存所有引用了该 data 的订阅者（Watcher）； 如何向Dep的subs添加订阅者（Watcher）呢？Vue在定义数据劫持的getter时，如果存在静态属性Dep.target，则会调用当前Dep的addSub来添加一个订阅者（Watcher）到List； 什么时候创建（Watcher）呢？ Vue在分析html模版时，一旦发现依赖了某个data，就会new 一个 Watcher()； 若数据发生变化会调用Dep的notify()方法，遍历所有的订阅者（Watcher）并执行它们的update方法；123456789101112131415161718192021// 定义数据，这里仅考虑Object形式var data = &#123; name: &apos;wdk&apos;, age: 25 &#125;function observe(obj) &#123; if (!obj || typeof obj !== &apos;object&apos;) return var ob = new Observer(obj) return ob&#125;// 观察者function Observer(obj) &#123; this.value = obj this.walk(obj)&#125;Observer.prototype.walk = function(obj) &#123; const keys = Object.keys(obj) // 遍历数据&amp;调用defineReactive for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839function Dep() &#123; this.subs = [] // 订阅者List&#125;// 添加订阅者Dep.prototype.addSub = function (sub) &#123; // sub是Watcher的实例 this.subs.push(sub)&#125;// 通知所有订阅者并调用它们的update方法Dep.prototype.notify = function () &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;)&#125;function defineReactive(obj, key) &#123; var value = obj[key] // 值 var dep = new Dep() // 递归子属性 observe(value) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(&apos;获取数据&apos;) // 将 Watcher 添加到订阅List if (Dep.target) &#123; dep.addSub(Dep.target) &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; console.log(&apos;修改数据&apos;) value = newVal // 执行 watcher 的 update 方法 dep.notify() &#125; &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637function update(value) &#123; document.querySelector(&apos;div&apos;).innerText = value&#125;function Watcher(obj, key, cb) &#123; // 将 Dep.target 指向自己， // 之后会调用data的值，使之触发Object.defineProperty的getter会操作 // 由于静态属性Dep.target存在，则会将该订阅者Watcher（Dep.target = this = 当前Watcher实例）加入到subs中（订阅者List） Dep.target = this this.cb = cb this.obj = obj this.key = key // 然后触发属性的 getter 添加监听 this.value = obj[key] // 将 Dep.target 置空 Dep.target = null&#125;Watcher.prototype.update = function () &#123; this.value = this.obj[this.key] // 调用 callback 方法更新 Dom this.cb(this.value)&#125;// 开始劫持observe(data)// 模拟解析到模版 &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 触发new Watcher()new Watcher(data, &apos;name&apos;, update)// 模拟解析到模版 &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt; 触发new Watcher()new Watcher(data, &apos;age&apos;, update)// get数据console.log(data.name)// set数据data.name = &apos;修改后数据&apos;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码3","slug":"学习Vue源码3","date":"2019-03-14T09:12:10.000Z","updated":"2019-06-26T07:51:50.001Z","comments":true,"path":"2019/03/14/学习Vue源码3/","link":"","permalink":"http://yoursite.com/2019/03/14/学习Vue源码3/","excerpt":"","text":"暴露出Vue src/core/instance/index.js 首先定义了名为Vue的函数 123456789function Vue (options) &#123; // 使用函数调用Vue()来调用Vue时给出错误警告 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) &#125; this._init(options)&#125; 然后初始化&amp;挂载一些功能 12345initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) 最后将Vue函数导出 先看initMixin(Vue) src/core/instance/init.jsinitMixin在Vue.prototype上挂载了_init方法，该_init方法会在new Vue({})时首先调用。12345678910111213141516// 参数的处理// merge optionsif (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options)&#125; else &#123; // 合并配置options vm.$options = mergeOptions( // 解析构造函数配置 resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm )&#125; resolveConstructorOptions：123456789101112131415161718192021222324252627// 处理Vue与Vue子类这两种情况的options export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options // 是否是Vue的子类 if (Ctor.super) &#123; const superOptions = resolveConstructorOptions(Ctor.super) // 找到超类的Options const cachedSuperOptions = Ctor.superOptions // if (superOptions !== cachedSuperOptions) &#123; // 对比父类中的options 有没有发生变化 // super(Vue)的Options配置若改变，处理新的Options // super option changed, // need to resolve new options. Ctor.superOptions = superOptions // check if there are any late-modified/attached options (#4976) const modifiedOptions = resolveModifiedOptions(Ctor) // update base extend options if (modifiedOptions) &#123; extend(Ctor.extendOptions, modifiedOptions) &#125; options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; // 返回获merge自己的options与父类的options属性 return options &#125; 后续还有 12345678910111213141516171819202122232425262728// 😀初始化生命周期initLifecycle(vm)export function initLifecycle (vm: Component) &#123; const options = vm.$options // 建立所有父子关系 let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; // 又是一波属性挂载 vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 1234567891011121314// 😀️初始化事件initEvents(vm)export function initEvents (vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events // vm.$options._parentListeners为父组件中定义的事件，如@click const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 123// 😀初始化RenderinitRender(vm) 123// 😀触发beforeCreate钩子callHook(vm, &apos;beforeCreate&apos;) 1234// 在data/props之前初始化注入// resolve injections before data/propsinitInjections(vm) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 😀State初始化，prop/method/data/computed/watch都在这里完成初始化，是Vue实例create的关键initState(vm)export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 处理props if (opts.props) initProps(vm, opts.props) // 处理methods，然后将每一个方法绑定在vm上，故可以以this.methodName()来调用methods&#123;&#125;中的方法 if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; // 存在data处理data initData(vm) &#125; else &#123; // 不存在data默认data为&#123;&#125; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 处理computed if (opts.computed) initComputed(vm, opts.computed) // 处理watch if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125;// initData中会调用observe方法，这里就会调用Vue最核心，利用Object.defineProperty对data进行劫持function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( &apos;data functions should return an object:\\n&apos; + &apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &apos;production&apos;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 代理data，即this.xxx 可以的到this.data.xxx的数据 proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 123// 在data/props之后初始化provide// resolve provide after data/propsinitProvide(vm) 12// 😀触发created钩子callHook(vm, &apos;created&apos;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码2","slug":"学习Vue源码2","date":"2019-03-13T09:12:10.000Z","updated":"2019-06-26T07:51:50.001Z","comments":true,"path":"2019/03/13/学习Vue源码2/","link":"","permalink":"http://yoursite.com/2019/03/13/学习Vue源码2/","excerpt":"","text":"全局api挂载 src/core/global-api/index.js在Vue上挂载Vue的配置文件、工具、属性，初始化各种全局方法: Vue.util 各种工具函数 Vue.set/delete Vue.nextTick Vue.options initUse(Vue) 挂载Vue.use方法 initMixin(Vue) 挂载Vue.mixin方法 initExtend(Vue) 挂载方法（使用 Vue 的基础构造函数，创建一个“子类(subclass)”。） initAssetRegisters(Vue) Vue.extend需要单独提一下 在Vue.extend的内部定义一个Sub，Sub继承于Super（指Vue） Vue.extend()返回Sub，Sub 是 Vue 的子类 所以 ‘new Vue({});’ 与 ‘var p = Vue.extend({}); new P();’ 实际上是类似的东西 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Vue.cid = 0let cid = 1/** * 定义一个Sub函数，继承于Vue，然后返回 * Class inheritance */Vue.extend = function (extendOptions: Object): Function &#123; extendOptions = extendOptions || &#123;&#125; // Super 指向 Vue const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; name) &#123; validateComponentName(name) &#125; // 定义一个Sub函数，继承Vue，然后返回 const Sub = function VueComponent (options) &#123; this._init(options) &#125; Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub[&apos;super&apos;] = Super // 对于props与computed属性，我们在扩展时定义代理getter在Vue实例 // 这样可以避免对创建的每个实例进行Object.DefineProperty调用。 // 配置有props，初始化props if (Sub.options.props) &#123; initProps(Sub) &#125; // 配置有computed，初始化computed if (Sub.options.computed) &#123; initComputed(Sub) &#125; // 允许进一步使用 extension/mixin/plugin Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type] &#125;) // enable recursive self-lookup if (name) &#123; Sub.options.components[name] = Sub &#125; // 在扩展时保留对超类的配置项引用 // 在之后的实例化时，我们可以检查超类的配置项是否已更新 Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend(&#123;&#125;, Sub.options) // 缓存构造函数 // cache constructor cachedCtors[SuperId] = Sub // 返回Sub return Sub&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"学习Vue源码1-目录结构与入口文件","slug":"学习Vue源码1-目录结构与入口文件","date":"2019-03-12T09:12:10.000Z","updated":"2019-06-26T07:51:50.000Z","comments":true,"path":"2019/03/12/学习Vue源码1-目录结构与入口文件/","link":"","permalink":"http://yoursite.com/2019/03/12/学习Vue源码1-目录结构与入口文件/","excerpt":"","text":"学习Vue源码，我拷贝的一份源码在这里，版本为2.6.8，里面有我做的各种注释。（注：暂不考虑SSR部分的代码） 文件结构123456789|--- core |--- components 组件 |--- global-api 需要全局挂载的js都在这个文件夹，在src/core/global-api/index.js中会全部引用 |--- instance 实例 |--- observer 观察者 |--- util 工具 |--- vdom |--- config.js Vue自身的配置 |--- index.js 入口文件 入口文件 src/core/index.js引入Vue函数，初始化全局API，挂载$isServer、$ssrContext属性与FunctionalRenderContext方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 这个就是Vueimport Vue from &apos;./instance/index&apos;// 初始化全局APIimport &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;// 环境判断，用于判断是否是服务端import &#123; isServerRendering &#125; from &apos;core/util/env&apos;// 功能渲染上下文import &#123; FunctionalRenderContext &#125; from &apos;core/vdom/create-functional-component&apos;// 执行初始化全局APIinitGlobalAPI(Vue)/** * vm.$isServer * 在Vue.prototype上定义$isServer，用于判断当前 Vue 实例是否运行于服务器 */Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123; get: isServerRendering&#125;)/** * vm.$ssrContext * 在Vue.prototype设置$ssrContext属性 * 可以通过 this.$ssrContext 来直接访问组件中的服务器端渲染上下文(SSR context)。 */Object.defineProperty(Vue.prototype, &apos;$ssrContext&apos;, &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// FunctionalRenderContext方法，用于SSR运行时helper安装，// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, &apos;FunctionalRenderContext&apos;, &#123; value: FunctionalRenderContext&#125;)// Vue版本Vue.version = &apos;__VERSION__&apos;export default Vue/** * hasOwn: 检查对象是否有某个属性 * */","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用Less时calc无法正确编译的问题","slug":"使用Less时calc无法正确编译的问题","date":"2019-02-21T06:46:13.000Z","updated":"2019-06-26T07:51:49.999Z","comments":true,"path":"2019/02/21/使用Less时calc无法正确编译的问题/","link":"","permalink":"http://yoursite.com/2019/02/21/使用Less时calc无法正确编译的问题/","excerpt":"","text":"问题编写Less时使用calc：1width: calc(100% - 30px); 会被编译成：1width: calc(100%); 解决方法写为如下形式可解决：1width: calc(~&quot;100% - 30px&quot;); 如写入变量：123456@a: 30px;width: calc(~&quot;100% - &quot; + @a);或width: calc(~&quot;100% - &quot; @a);或width: calc(~&quot;100% - @&#123;a&#125;&quot;);","categories":[{"name":"Less","slug":"Less","permalink":"http://yoursite.com/categories/Less/"}],"tags":[]},{"title":"Vue2数据改变,View却不更新的问题","slug":"Vue2数据改变，View却不更新的问题","date":"2019-01-23T08:03:33.000Z","updated":"2019-06-26T07:51:49.997Z","comments":true,"path":"2019/01/23/Vue2数据改变，View却不更新的问题/","link":"","permalink":"http://yoursite.com/2019/01/23/Vue2数据改变，View却不更新的问题/","excerpt":"","text":"使用Vue2开发的时候偶尔会遇到，明明data已经更新，View层却没有刷新的问题。 这种情况一般常见于嵌套层级过于复杂的Object中，data确实已经修改，但是由于Vue底层机制，无法监听到data变动，从而不能正确的修改View。 解决方案有以下几种： 使用 Vue.set 或 this.$Set 使用 JSON.parse 与 JSON.stringify 123const obj = JSON.parse(JSON.stringify(this.obj))obj.item.img = &apos;&apos;this.obj = obj 使用 Object.assign({}, obj) 123const obj = Object.assign(&#123;&#125;, this.obj)obj.item.img = &apos;&apos;this.obj = obj 使用 vm.$forceUpdate() 1vm.$forceUpdate()会使 Vue 实例重新渲染。但它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 通常来说使用以上几种方式，就可以解决问题，但如果任然无法解决，还有另外一种方式，强行使Vue触发Vue更新： 12345678910111213// 在data中定义一个数据data() &#123; return &#123; refresh: true &#125;&#125;// 在template中引用，并将其隐藏&lt;div style=&quot;opacity: 0; height: 0;&quot;&gt;&#123;&#123; refresh &#125;&#125;&lt;/div&gt;// 需要更新复杂数据时，手动修改refresh值，使Vue更新View层this.obj.xxx = &apos;xxx&apos; // obj更新this.refresh = !this.refresh","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"笛卡尔积算法","slug":"笛卡尔积算法","date":"2018-12-31T10:49:13.000Z","updated":"2019-06-26T07:51:50.003Z","comments":true,"path":"2018/12/31/笛卡尔积算法/","link":"","permalink":"http://yoursite.com/2018/12/31/笛卡尔积算法/","excerpt":"","text":"常用在商品SKU上，用于展示每种属性的组合，如： ‘红黄蓝’与‘大小’，可组合为红大、红小、黄大、黄小、蓝大、蓝小。1234567891011121314151617181920function calcDescartes(array) &#123; // 长度小于2 return if (array.length &lt; 2) return array[0] || [] return [].reduce.call(array, function (col, set) &#123; // console.log(&apos;====&apos;, col, set) // 仅第一次 col为传入参数的第一个元素、set为第二个元素； // 之后的每一次 col为上一次处理的结果数组、set为传入参数的下一个元素 var res = [] // 以下是col与set的组合操作 col.forEach(function (c) &#123; set.forEach(function (s) &#123; var t = [].concat(Array.isArray(c) ? c : [c]) t.push(s) res.push(t) &#125;) &#125;) return res &#125;)&#125;console.log(calcDescartes([[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [&apos;A&apos;, &apos;B&apos;]]))","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[]},{"title":"微信网页版的消息接受机制","slug":"微信网页版的消息接受机制","date":"2018-12-31T06:49:13.000Z","updated":"2019-06-26T07:51:50.002Z","comments":true,"path":"2018/12/31/微信网页版的消息接受机制/","link":"","permalink":"http://yoursite.com/2018/12/31/微信网页版的消息接受机制/","excerpt":"","text":"今天无意间使用了一下网页版微信，出于前端的本能就打开了Network，想看一下微信消息接收的实现，想象中的Websocket并没有出现，自己尝试用手机给网页微信发送几条消息，发现网页微信的实现比想象中的要简单很多。 大致原理（长轮询）： 1.微信网页端动态创建script，src为’https://webpush.wx.qq.com/cgi-bin/mmwebwx-bin/synccheck&#39;与一些参数。 2.该请求会一直处于pending状态，pending状态最多维持约25秒。 3.当微信号接收到消息，该请求会返回内容’window.synccheck={retcode: “0”, selector: “2”}’，接着浏览器端会发起请求拉取最新消息，然后网页微信端重新创建script，回到第一步。 4.如果25秒后仍没有接收到消息，会返回window.synccheck={retcode: “0”, selector: “0”}，网页微信端会重新创建script，回到第一步。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"Vue递归组件","slug":"Vue递归组件","date":"2018-12-25T08:59:13.000Z","updated":"2019-06-26T07:51:49.997Z","comments":true,"path":"2018/12/25/Vue递归组件/","link":"","permalink":"http://yoursite.com/2018/12/25/Vue递归组件/","excerpt":"","text":"使用Vue开发树状组件的时候需要使用到递归组件，即在模板中调用自己。 要使用递归组件，该组件必须有name属性。 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;template&gt; &lt;div&gt; &lt;div class=&quot;list-item&quot; v-for=&quot;(item, index) in treeData&quot; :key=&quot;index&quot;&gt; &lt;p @click=&quot;itemClick(item)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/p&gt; &lt;div class=&quot;child&quot; v-if=&quot;item.childs.length&quot;&gt; &lt;product-tree :treeData=&quot;item.childs&quot;&gt;&lt;/product-tree&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;product-tree&apos;, data () &#123; return &#123; treeData: [ &#123; id: &apos;1&apos;, pid: null, name: &apos;一级类目1&apos;, childs: [ &#123; id: &apos;1-1&apos;, pid: 1, name: &apos;二级类目1&apos;, childs: [ &#123; id: &apos;1-1-1&apos;, pid: 1-1, name: &apos;三级类目1&apos;, childs: [ ] &#125; ] &#125;, &#123; id: &apos;1-2&apos;, pid: 1, name: &apos;二级类目2&apos;, childs: [ ] &#125; ] &#125;, &#123; id: &apos;2&apos;, pid: null, name: &apos;一级类目2&apos;, childs: [ ] &#125;, ] &#125; &#125;, created() &#123; &#125;, methods: &#123; // 菜单点击 itemClick(item) &#123; console.log(item) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"Nuxt中的路由权限判断","slug":"Nuxt中的路由权限判断","date":"2018-12-13T02:52:13.000Z","updated":"2019-06-26T07:51:49.996Z","comments":true,"path":"2018/12/13/Nuxt中的路由权限判断/","link":"","permalink":"http://yoursite.com/2018/12/13/Nuxt中的路由权限判断/","excerpt":"","text":"上个项目小试了下使用Nuxt做多语言官网，这次要做一个多语言商城项目，功能不算复杂，算是一个简化版的商城，涉及到了路由权鉴，这里记录一下。 Nuxt权限拦截分为两种情况，一个是直接请求页面的服务端层面拦截，另一个是在浏览器路由跳转的客户端拦截，这里需要对着两种情况做处理。由于服务端没有window对象，拿不到localStorage内的token，在服务端需要使用’js-cookie’，在cookie中也设置token，服务端在request中拿到cookie中的token来判断权限。在客户端则使用localStorage来判断权限。1import Cookies from &apos;js-cookie&apos; utils.js123456789101112131415161718192021222324252627// 设置localStorageexport function setStorage(name, val) &#123; window.localStorage.setItem(name, JSON.stringify(val))&#125;// 获取localStorageexport function getStorage(name) &#123; return JSON.parse(window.localStorage.getItem(name)) || null&#125;// 设置token，cookie与localStorage上都需要设置export function setToken(token) &#123; Cookies.set(&apos;token&apos;, token) setStorage(&apos;token&apos;, token)&#125;// 获取tokenexport function getToken() &#123; return getStorage(&apos;token&apos;)&#125;// 获取request的cookieexport function getCookieFromReq(req, name) &#123; if (!req.headers.cookie) return const valCookie = req.headers.cookie.split(&apos;;&apos;).find(c =&gt; c.trim().startsWith(`$&#123;name&#125;=`)) if (!valCookie) return const val = valCookie.split(&apos;=&apos;)[1] return val&#125; 登录页12345678910// 处理登录login() &#123; // 校验表单 if (!this.validate()) return // 登录请求省略，这里仅展示token设置 const token = &apos;dsdjhfwegfiwegdvwed&apos; setToken(token) this.$store.commit(&apos;SET_TOKEN&apos;, token) window.location.href = &apos;/&apos;&#125; middleware文件夹下新建权鉴判断js：accountVerification.js （这里去除多语言判断，仅展示权鉴部分）1234567891011121314151617181920import &#123; getCookieFromReq, getToken &#125; from &apos;~/utils/utils&apos;/** * 权限的验证，重定向未登录状态下的一些路由访问到登录页去 */export default function (&#123; isHMR, app, store, req, route, params, error, redirect &#125;) &#123; if (isHMR) return /* 登录权鉴判断部分 */ const isClient = process.client // 是否是客户端 const isServer = process.server // 是否是服务端 // 服务端从cookie拿token，客户端从local中拿token const token = isServer ? getCookieFromReq(req, &apos;token&apos;) : isClient ? getToken() : null /* 无权限访问，跳转到登录页 */ if (!token) &#123; redirect(&apos;/login&apos;) &#125;&#125; 最后，在要使用该中间件的page中添加1middleware: &apos;accountVerification&apos; 该中间件就应用到对应的页面上了。 附：官方给出的权限判断demo","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"本地调试Google-Sign-In","slug":"本地调试Google-Sign-In","date":"2018-12-01T10:11:13.000Z","updated":"2019-06-26T07:51:50.003Z","comments":true,"path":"2018/12/01/本地调试Google-Sign-In/","link":"","permalink":"http://yoursite.com/2018/12/01/本地调试Google-Sign-In/","excerpt":"","text":"最近要开发的项目需要做谷歌登录的功能 谷歌第三方登录 在阅读文档的时候注意到，要先配置 OAuth client，其中有一项是配置重定向URL且不能是IP。 看到这里就产生了本地开发如何调试获取用户信息的疑惑。 解决方法：使用SwitchHosts工具（可以直接在github搜索，下载对应版本），通过修改本地hosts（hosts无法修改的可自行百度解决），将某个域名指向为本地ip，如本地地址为 http://192.168.1.134:8000/ ，要配置为www.demo.com 打开 http://www.demo.com:8000 即可访问到和 http://192.168.1.134:8000一样的内容。 将之前的重定向地址填为 http://www.demo.com:8000 即可成功获得Google用户信息。 Tips：所有的OAuth client均可在 这里管理。","categories":[{"name":"Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[]},{"title":"记一次使用element-ui开发时，使用el-menu组件遇到的问题","slug":"el-menu.bug","date":"2018-11-29T10:25:00.000Z","updated":"2019-06-26T07:51:49.997Z","comments":true,"path":"2018/11/29/el-menu.bug/","link":"","permalink":"http://yoursite.com/2018/11/29/el-menu.bug/","excerpt":"","text":"element-ui版本: 2.4.11 场景：vue路由分为两种，一种显示，由el-menu组件负责展示，以当前path作为菜单is-active 样式显示的条件；一种隐藏，在页面中以vue-router的方法来跳转。 问题：点击el-menu-item组件可以正确的通知el-menu组件，对当前激活菜单样式做出调整。但使用vue-router进行跳转，无法触发emit方法来修改el-menu组件内部状态，倒置页面跳转了，菜单还高亮在原来的菜单； 解决方法：在不修改element-ui源码的前提下，只需要加上以下代码，来监听路由变化，使用ref获取menu组件，直接修改其中的activeIndex的值。 简化代码如下： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;!-- menu添加ref --&gt; &lt;el-menu :default-active=&quot;currentPath&quot; background-color=&quot;#282a3c&quot; text-color=&quot;#d2d9e0&quot; active-text-color=&quot;#fff&quot; ref=&quot;menu&quot; &gt; &lt;/el-menu&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; currentPath: this.$route.path &#125; &#125;, watch: &#123; // 添加监听，手动改变activeIndex值，解决vue-router跳转，菜单仍然高亮的bug &apos;$route&apos; (to, from) &#123; this.$refs.menu.activeIndex = to.path &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用nuxt时遇到的head问题","slug":"nuxt-head","date":"2018-11-20T10:21:13.000Z","updated":"2019-06-26T07:51:49.998Z","comments":true,"path":"2018/11/20/nuxt-head/","link":"","permalink":"http://yoursite.com/2018/11/20/nuxt-head/","excerpt":"","text":"使用Nuxt开发Vue-SSR项目，在nuxt.config.js中统一配置了head： 1234567891011head: &#123; title: &apos;这是title&apos;, meta: [ &#123; charset: &apos;utf-8&apos; &#125;, &#123; name: &apos;renderer&apos;, content: &apos;webkit&apos; &#125;, &#123; name: &apos;force-rendering&apos;, content: &apos;webkit&apos; &#125;, &#123; &apos;http-equiv&apos;: &apos;X-UA-Compatible&apos;, content: &apos;IE=Edge,chrome=1&apos; &#125;, &#123; name: &apos;viewport&apos;, content: &apos;width=device-width, initial-scale=1&apos; &#125;, // code ... ]&#125;, 开发中发现在首页中，以上meta添加不上，切换其他页面后才会添加。原因： 在index.vue中，设置了head函数，却未返回任何内容，其他页面都返回了正确的内容，故切换页面才正常添加： 1234export default &#123; head() &#123; &#125;&#125; page文件的head方法，要么不写，写了就至少需要返回一个对象 123456export default &#123; head() &#123; return &#123; &#125; &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"开发Vue SPA 单页应用时，使用prerender-spa-plugin与vue-i18n遇到的问题","slug":"prerender-spa-plugin与vue-i18n","date":"2018-11-15T04:08:10.000Z","updated":"2019-06-26T07:51:49.998Z","comments":true,"path":"2018/11/15/prerender-spa-plugin与vue-i18n/","link":"","permalink":"http://yoursite.com/2018/11/15/prerender-spa-plugin与vue-i18n/","excerpt":"","text":"开发公司官网，需要做多语言，又要有SEO，且使用Vue开发。首先想到的是自己搭建Vue SSR，但做官网没有必要搞这么麻烦，遂想到了使用prerender-spa-plugin来做预渲染，vue-i18n来做多语言，于是有了以下大致代码： prerender-spa-plugin部分12345678910// main.jsnew Vue(&#123; el: &apos;#app&apos;, router, store, mounted () &#123; document.dispatchEvent(new Event(&apos;render-event&apos;)) &#125;, render: h =&gt; h(App)&#125; 1234567891011121314151617181920212223// webpack.config.jsconst path = require(&apos;path&apos;)const PrerenderSPAPlugin = require(&apos;prerender-spa-plugin&apos;)const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123; plugins: [ ... new PrerenderSPAPlugin(&#123; // webpack 打包输出路径，用于插件预渲染 staticDir: path.join(__dirname, &apos;dist&apos;), // 需要渲染的路由 routes: [ &apos;/&apos;, &apos;/about&apos;, &apos;/其他路由...&apos; ], renderer: new Renderer(&#123; headless: true, // main.js 中 document.dispatchEvent(new(&apos;render-event&apos;))， // 两者的事件名称要一致。 renderAfterDocumentEvent: &apos;render-event&apos; &#125;) &#125;) ]&#125; vue-i18n部分1234567891011121314151617181920212223242526// main.js// 引入并useimport VueI18n from &apos;vue-i18n&apos;Vue.use(VueI18n)// 引入语言包import zh from &apos;./lang/zh&apos;import en from &apos;./lang/en&apos;const messages = &#123; zh en &#125;// 实例化 const i18n = new VueI18n(&#123; locale: localStorage.getItem(&apos;lang&apos;) || &apos;zh&apos;, // 语言 messages&#125;)// 挂载到Vue上new Vue(&#123; i18n, router, store, render: h =&gt; h(App)&#125;).$mount(&apos;#app&apos;) 运行之后却发现，切换到英文版本，再刷新，页面总会先显示中文，再快速闪回英文。 排查原因之后发现，prerender-spa-plugin在使用Headless浏览器生成页面结构时，页面语言为中文，用户访问英文版网站时，返回的html内容为中文，js执行后会将中文再替换为英文。试了一些方法也没有很好的解决这个问题。 虽然去除prerender-spa-plugin插件可以解决这个问题，但是也就失去了SEO。 最终我们决定使用Nuxt.js来开发，在这个官方demo的基础上进行修改，暂以generate模式打包完成官网开发。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[]},{"title":"使用pm2时遇到的问题","slug":"pm2-problem","date":"2018-11-04T09:44:13.000Z","updated":"2019-06-26T07:51:49.998Z","comments":true,"path":"2018/11/04/pm2-problem/","link":"","permalink":"http://yoursite.com/2018/11/04/pm2-problem/","excerpt":"","text":"一个使用Nuxt开发的多语言官网项目，代码提交后使用gitlab自动部署项目，服务器上使用PM2来管理。 由于一些原因前端项目和后端项目在同一台服务器，后端重启服务器，会导致前端服务挂掉，后来增加了服务器重启自动执行脚本，重启后将Nuxt项目跑起来。 但之后通过gitlab-CI自动部署的代码 pm2 都跑不起来 之前gitlab-CI配置为 pm2 delete all &amp;&amp; pm2 start npm –name “nuxt-official-website” – run start” 后添加了pm2 stop all，解决了这个问题 pm2 stop all &amp;&amp; pm2 delete all &amp;&amp; pm2 start npm –name “nuxt-official-website” – run start”","categories":[{"name":"Pm2","slug":"Pm2","permalink":"http://yoursite.com/categories/Pm2/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-10-14T01:00:00.000Z","updated":"2019-06-26T07:51:49.998Z","comments":true,"path":"2018/10/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/14/hello-world/","excerpt":"","text":"早在两年前就有搞过一个hexo的博客，但是因为种种原因（懒癌）一直没有更新过。之后偶尔在简书、掘金上记录过一些东西。今天重新开坑，又一次搞了hexo的博客，暂时没有打算弄域名，直接用github的。写的东西可能不是那么高大上，可能是工作中遇到的坑或者是对于某些知识的学习笔记，不过这都不重要，重要的是希望自己可以坚持写下去。有空的话或许会把以前写过的一些东西搬到这边来，随缘。","categories":[],"tags":[]}]}