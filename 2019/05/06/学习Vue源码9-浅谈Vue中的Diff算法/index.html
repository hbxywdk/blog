<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="hbxywdk,hbxywdk@gmail.com"><title>学习Vue源码9-浅谈Vue中的Diff算法 · DK'S BLOG</title><meta name="description" content="虚拟DOM操作DOM的代价操作DOM的代价很高，影响页面性能的主要问题有以下几点：

访问和修改DOM元素
修改DOM元素的样式，导致重绘或重排
通过对DOM元素的事件处理，完成与用户的交互功能

DOM的修改会导致重绘或重排

重绘：重绘是指一些样式的修改，元素的位置和大小都没有改变，浏览器会根据"><meta name="keywords" content="blog,FE,HTML,CSS,Javascript,Vue,Nuxt"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">DK'S BLOG</a></h3><div class="description"><p>Judge not from appearances.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/DKWang8"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/3136805851"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/hbxywdk"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/de.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>学习Vue源码9-浅谈Vue中的Diff算法</a></h3></div><div class="post-content"><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><h4 id="操作DOM的代价"><a href="#操作DOM的代价" class="headerlink" title="操作DOM的代价"></a>操作DOM的代价</h4><p><code>操作DOM的代价很高</code>，影响页面性能的主要问题有以下几点：</p>
<ul>
<li>访问和修改DOM元素</li>
<li>修改DOM元素的样式，导致<code>重绘</code>或<code>重排</code></li>
<li>通过对DOM元素的事件处理，完成与用户的交互功能</li>
</ul>
<p><code>DOM的修改会导致重绘或重排</code></p>
<ul>
<li>重绘：重绘是指一些样式的修改，元素的位置和大小都没有改变，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</li>
<li>重排/回流：是指元素的位置或尺寸发生了变化，浏览器需要重新计算渲染树，而新的渲染树建立后，浏览器会重新绘制页面。</li>
</ul>
<p><code>重绘相对于重排还好一些，重绘仅仅改变变化元素的样式即可，但重排（回流）则会重新计算所有元素之间的位置关系然后重新绘制元素</code><br><br><code>如果频繁操作DOM，其必然带来性能变低，浏览器卡慢</code></p>
<h4 id="为何需要虚拟DOM？"><a href="#为何需要虚拟DOM？" class="headerlink" title="为何需要虚拟DOM？"></a>为何需要虚拟DOM？</h4><p>接下来，我们看一下真实的DOM元素，我们打开某度的首页，在控制台输入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dom1 = document.querySelectorAll(&apos;div&apos;)[0]</span><br><span class="line">for ( let x in dom1 ) &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到一个div下其实是有很多属性的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">align</span><br><span class="line">title</span><br><span class="line">lang</span><br><span class="line">translate</span><br><span class="line">dir</span><br><span class="line">dataset</span><br><span class="line">hidden</span><br><span class="line">tabIndex</span><br><span class="line">accessKey</span><br><span class="line">draggable</span><br><span class="line">spellcheck</span><br><span class="line">autocapitalize</span><br><span class="line">contentEditable</span><br><span class="line">isContentEditable</span><br><span class="line">......等上百个</span><br></pre></td></tr></table></figure></p>
<p>一个DOM拥有这么多属性，这也是带来性能问题的原因之一，撇开我们用不上的属性，我们其实可以<code>使用js来模拟一个仅保留我们需要的属性的DOM</code>，这样的模拟DOM其实就是<code>虚拟DOM</code>。<br><br>比如我们可以用以下代码模拟一个内容为’Hello Word’，id名与class名为test的div元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: &apos;div&apos;,</span><br><span class="line">  id: &apos;test&apos;,</span><br><span class="line">  className: &apos;test&apos;</span><br><span class="line">  text: &apos;Hello Word&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Vue、React都使用了虚拟DOM技术，让新、旧DOM的变化对比在Js层完成，最后仅修改变化了的DOM，直接避免了频繁操作DOM的情况，大大提升页面性能。</p>
<h3 id="Vnode"><a href="#Vnode" class="headerlink" title="Vnode"></a>Vnode</h3><p>Vnode就是虚拟DOM技术在Vue中的实现，它的源码在<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="noopener">这里</a>，它在模拟DOM的情况下又添加了很多框架本身需要的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void;</span><br><span class="line">  data: VNodeData | void;</span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void;</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; // rendered in this component&apos;s scope</span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void;</span><br><span class="line">  componentInstance: Component | void; // component instance</span><br><span class="line">  parent: VNode | void; // component placeholder node</span><br><span class="line"></span><br><span class="line">  // code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了虚拟DOM那么就要有对比新、旧虚拟DOM的变化算法，这种算法就叫Diff算法：</p>
<h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><h4 id="Diff算法同级比较"><a href="#Diff算法同级比较" class="headerlink" title="Diff算法同级比较"></a>Diff算法同级比较</h4><p>求两个任意树之间的最小修改是一个时间复杂度为O(n^3)问题。这样的时间复杂度是我们无法接受的。<br>在Web应用中将组件移动到树中的不同级别是非常罕见的，通常只在孩子中间横向移动。<br>所以Diff算法采用的是<code>同级比较</code>，将算法的时间复杂度降低到了O(N)，这大大降低了复杂性，同时也不会造成很大损失，正如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff1.png" alt="同级比较"></p>
<p>所以如果我们进行了跨级别的组件移动操作，实际上是会先删除DOM，再在对应的层级上新建一个DOM。</p>
<h4 id="循环中为何需要key属性？"><a href="#循环中为何需要key属性？" class="headerlink" title="循环中为何需要key属性？"></a>循环中为何需要key属性？</h4><p>我们看这张图：</p>
<p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff2.png" alt="为何需要key"></p>
<p>如果我们循环生成了5个组件，然后我们又插入了一个新的同类组件，对于我们来说很难知道如何在两个组件Lists中建立映射，所以就会变成上图左侧所示，按顺序一一建立关联。<br>如果有了key的存在情况则大不一样，它能很容易的帮助代码解决映射问题，让代码在正确的地方进行正确的操作，这对代码的性能提升也有很大的帮助。</p>
<h4 id="简单分析Diff算法"><a href="#简单分析Diff算法" class="headerlink" title="简单分析Diff算法"></a>简单分析Diff算法</h4><p>我们以Vue（v2.6.8）代码为例，代码位置在<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js" target="_blank" rel="noopener">src/core/vdom/patch.js</a>中。</p>
<p>首先我们先明确几个方法：</p>
<ol>
<li><p>工具方法isUndef、isDef等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 判断v是否是undefined或null</span><br><span class="line">export function isUndef (v: any): boolean %checks &#123;</span><br><span class="line">  return v === undefined || v === null</span><br><span class="line">&#125;</span><br><span class="line">// 判断v是否不是undefined或null</span><br><span class="line">export function isDef (v: any): boolean %checks &#123;</span><br><span class="line">  return v !== undefined &amp;&amp; v !== null</span><br><span class="line">&#125;</span><br><span class="line">// 其他工具方法可以自行查看</span><br></pre></td></tr></table></figure>
</li>
<li><p>sameVnode：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否是同一个Vnode</span><br><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>nodeOps 封装了一些原生DOM操作方法，在platforms\web\runtime\node-ops.js中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// code...</span><br><span class="line">export function createElementNS (namespace: string, tagName: string): Element &#123;</span><br><span class="line">  return document.createElementNS(namespaceMap[namespace], tagName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createTextNode (text: string): Text &#123;</span><br><span class="line">  return document.createTextNode(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createComment (text: string): Comment &#123;</span><br><span class="line">  return document.createComment(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function removeChild (node: Node, child: Node) &#123;</span><br><span class="line">  node.removeChild(child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function appendChild (node: Node, child: Node) &#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br><span class="line">// code...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>对比新、老vnode，进行最小程度的修改</p>
<ul>
<li>如果是<code>初始化</code>会传以下几个参数（core\instance\lifecycle.js）：</li>
<li><code>vm.__patch__(vm.$el, vnode, hydrating, false)</code> </li>
<li>// vm.$el 是要挂载到的DOM，vnode就是vnode，hydrating用于服务端渲染不用管，最后一个参数是removeOnly</li>
<li>如果是<code>更新</code>会传两个参数</li>
<li><code>vm.__patch__(prevVnode, vnode)</code> </li>
<li>// prevVnode 是旧 vNode，vnode 是新 vNode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">core\vdom\patch.js</span><br><span class="line">return function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">  // vnode不存在，oldVnode存在，说明节点被移除了，直接调用销毁钩子</span><br><span class="line">  if (isUndef(vnode)) &#123;</span><br><span class="line">    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let isInitialPatch = false</span><br><span class="line">  const insertedVnodeQueue = []</span><br><span class="line">  // 如果oldVnode不存在的话，就新建一个根节点</span><br><span class="line">  if (isUndef(oldVnode)) &#123;</span><br><span class="line">    // empty mount (likely as component), create new root element</span><br><span class="line">    isInitialPatch = true</span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">    // 👇根据 oldVnode 是否存在 nodeType 属性 来判断是否是一个真实DOM节点</span><br><span class="line">    // 👇如果存在 nodeType 说明当前走的是 初始化 流程</span><br><span class="line">    const isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line"></span><br><span class="line">    // 走update流程 且 是同一个节点，直接调用 patchVnode 方法</span><br><span class="line">    if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      // 修补现有根节点</span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      // oldVnode 是 真实节点，走 init 流程</span><br><span class="line">      if (isRealElement) &#123;</span><br><span class="line">        // mounting to a real element</span><br><span class="line">        // check if this is server-rendered content and if we can perform</span><br><span class="line">        // a successful hydration.</span><br><span class="line">        // Vnode在服务端渲染的一些处理，这里暂且不看</span><br><span class="line">        // 如果oldVnode的是一个Element节点 &amp;&amp; 存在服务端渲染的属性</span><br><span class="line">        if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          // 则移除其SSR属性，再将hydrating设置为true</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">          hydrating = true</span><br><span class="line">        &#125;</span><br><span class="line">        if (isTrue(hydrating)) &#123;</span><br><span class="line">          if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">            invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">            return oldVnode</span><br><span class="line">          &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              &apos;The client-side rendered virtual DOM tree is not matching &apos; +</span><br><span class="line">              &apos;server-rendered content. This is likely caused by incorrect &apos; +</span><br><span class="line">              &apos;HTML markup, for example nesting block-level elements inside &apos; +</span><br><span class="line">              &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; +</span><br><span class="line">              &apos;full client-side render.&apos;</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // either not server-rendered, or hydration failed.</span><br><span class="line">        // create an empty node and replace it</span><br><span class="line">        // 不是服务端渲染的话，且是初始化流程，把oldVnode替换为一个空的vNode</span><br><span class="line">        oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 当前节点与其父节点</span><br><span class="line">      const oldElm = oldVnode.elm</span><br><span class="line">      const parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">      // 创建一个新的 node</span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        // extremely rare edge case: do not insert if old element is in a</span><br><span class="line">        // leaving transition. Only happens when combining transition +</span><br><span class="line">        // keep-alive + HOCs. (#4590)</span><br><span class="line">        oldElm._leaveCb ? null : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      // update parent placeholder node element, recursively</span><br><span class="line">      // 递归更新父节点占位节点元素</span><br><span class="line">      if (isDef(vnode.parent)) &#123;</span><br><span class="line">        let ancestor = vnode.parent</span><br><span class="line">        const patchable = isPatchable(vnode)</span><br><span class="line">        while (ancestor) &#123;</span><br><span class="line">          for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">            cbs.destroy[i](ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          if (patchable) &#123;</span><br><span class="line">            for (let i = 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">              cbs.create[i](emptyNode, ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            // #6513</span><br><span class="line">            // invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">            // e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">            const insert = ancestor.data.hook.insert</span><br><span class="line">            if (insert.merged) &#123;</span><br><span class="line">              // start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">              for (let i = 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                insert.fns[i]()</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            registerRef(ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 有父元素</span><br><span class="line">      if (isDef(parentElm)) &#123;</span><br><span class="line">        removeVnodes(parentElm, [oldVnode], 0, 0)</span><br><span class="line">      &#125; </span><br><span class="line">      // 没有父元素触发销毁</span><br><span class="line">      else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  return vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>patch 方法针对<code>初始化</code>与<code>更新</code>这两种情况做处理，<br>关于<code>初始化</code>与<code>更新</code>的判断：patch 函数的第一个参数传的如果是一个真实DOM，那么就会有nodeType属性，则是初始化。<br>如果是更新，且新旧两个vNode值得比较（即调用samevnode方法返回true，说明是同一个节点）则会调用 patchVnode 进一步比较。</p>
<h4 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h4><p>修补vnode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode ( oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly ) &#123;</span><br><span class="line">  // 如果是同一个vnode return</span><br><span class="line">  if (oldVnode === vnode) &#123; return &#125;</span><br><span class="line">  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    // 克隆重用 vnode</span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 设置 新vnode的elm 与 旧vnode.elm 相同（都为同一个DOM）</span><br><span class="line">  const elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">  if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = true</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 静态树重用元素</span><br><span class="line">  if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i</span><br><span class="line">  const data = vnode.data</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldCh = oldVnode.children</span><br><span class="line">  const ch = vnode.children</span><br><span class="line">  if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  if (isUndef(vnode.text)) &#123;</span><br><span class="line">    // 如果新旧 vNode都有 children 则调用 updateChildren 方法来对比他俩的 children</span><br><span class="line">    if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; else if (isDef(ch)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (isDef(oldCh)) &#123;</span><br><span class="line">      removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">    &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  if (isDef(data)) &#123;</span><br><span class="line">    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要看这段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">  if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果 oldVnode 与 vNode 都有 children 则调用 <code>updateChildren</code> 方法来对比他俩的 children，<br>在 updateChildren 方法中就会用到 <code>Diff算法</code> 来对比、更新节点，同时再 updateChildren 中也会调用 patchVnode 继续对比下一级子节点。</li>
<li>如果oldVnode 没有 children，而 vNode 有，则调用 addVnode 方法，添加所有的 children。</li>
<li>如果 oldVnode 有 children，而 vNode 有，则调用 removeVnode 方法，移除原有的 children。</li>
<li>如果 oldVnode 与 vNode 都是文本节点，则会用 vNode 的文本替换 oldVnode 的文本。</li>
</ol>
<h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>这个方法是 diff 算法的核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  let oldStartIdx = 0 // 旧list起始索引</span><br><span class="line">  let newStartIdx = 0 // 新list起始索引</span><br><span class="line">  let oldEndIdx = oldCh.length - 1 // 旧list结尾索引</span><br><span class="line">  let oldStartVnode = oldCh[0] // 旧的起始vnode初始赋值为list的第一个</span><br><span class="line">  let oldEndVnode = oldCh[oldEndIdx] // 旧的结尾vnode初始赋值为list的最后一个</span><br><span class="line">  let newEndIdx = newCh.length - 1 // 新list结尾索引</span><br><span class="line">  let newStartVnode = newCh[0] // 旧的起始vnode初始赋值为list的第一个</span><br><span class="line">  let newEndVnode = newCh[newEndIdx] // 旧的结尾vnode初始赋值为list的最后一个</span><br><span class="line">  /**</span><br><span class="line">   * 变量定义</span><br><span class="line">   * oldKeyToIdx要存一个哈希表，存放的内容是oldVnode的key</span><br><span class="line">   * idxInOld会存放根据哈希表中的key找到的对应oldVnode</span><br><span class="line">   * vnodeToMove我们要移动的vnode</span><br><span class="line">   * refElm就到下面去看注释把</span><br><span class="line">   */    </span><br><span class="line">  let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  // removeOnly是一个用于&lt;transition-group&gt;的特殊的flag</span><br><span class="line">  // 以保证移除有过渡效果的的元素时保持它正确的定位</span><br><span class="line">  const canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line"></span><br><span class="line">    // oldStartVnode不存在，则将oldStartVnode赋值为下一个vnode</span><br><span class="line">    if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left</span><br><span class="line"></span><br><span class="line">    // oldEndVnode不存在则将oldEndVnode赋值为上一个vnode</span><br><span class="line">    &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">    // 如果oldStartVnode, newStartVnode为同一个vnode，直接去patchVnode（打补丁）</span><br><span class="line">    // 然后，新旧startVnode各向前前进一格</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">    // 如果oldEndVnode, newEndVnode为同一个vnode，直接去patchVnode（打补丁）</span><br><span class="line">    // 然后，新旧endVnode各向后后退一格</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">    // 如果oldStartVnode, newEndVnode为同一个vnode（vnode被移动到右边去了）</span><br><span class="line">    // oldStartVnode前进一格</span><br><span class="line">    // newEndVnode后退一格</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right</span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">    // 如果oldEndVnode, newStartVnode是同一个vnode，说明vnode被移到左边去了</span><br><span class="line">    // newStartVnode前进一格</span><br><span class="line">    // oldEndVnode后退一格</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left</span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">    // 最后，所有的对比不上</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      // 创建了一个哈希表，其存放的内容是old vnode的key</span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      // old vnode的哈希表中找不到，则说明是新元素啊，这里就新建一个元素</span><br><span class="line">      if (isUndef(idxInOld)) &#123; // New element 新加进来的元素</span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">      // else 就是找到啦，</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 这个就是我们找到的和 newVnode的startIndex 索引相同的 oldVnode，我们要把它移到当前的oldStartVnode的前面去</span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = undefined</span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // same key but different element. treat as new element</span><br><span class="line">          // 不过呢，万一key相同，但是通过sameVnode方法比较出来的结果是不相同，则new一个元素，插到当前的oldStartVnode的前面去</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 这里就循环完毕啦</span><br><span class="line">  // 但是如果这里发现 oldStartIdx &gt; oldEndIdx 说明，有新增的元素</span><br><span class="line">  // 我们把它们选出来，用refElm存一下，然后啊，使用addVnodes批量调用创建（createElm）把这些vnode加到真实DOM中</span><br><span class="line">  if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  // else呢，说明新的vnodes比老的少</span><br><span class="line">  // 我们调用removeVnodes方法，参数包含oldStartIdx 与 oldEndIdx，把不要的删掉嘛</span><br><span class="line">  &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>updateChildren的代码中呢，主要是一个while循环，新旧Lists中无论哪一个先循环完都会退出循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  // code...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// oldStartIdx &gt; oldEndIdx，新Lists中新增了某些元素</span><br><span class="line">if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  // addVnodes操作</span><br><span class="line">  // code...</span><br><span class="line">&#125;</span><br><span class="line">// else说明新Lists中移除了某些元素</span><br><span class="line">else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  // removeVnodes操作</span><br><span class="line">  // code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接看源码感觉头都炸了，这里通过画图的方式会更合适一些。<br><code>注意：以下每张图之间没有联系</code></p>
<p>首先会在新旧Lists的头尾定义各定义一个标记，分别为：oldStartIdx，oldEndIdx，newStartIdx，newEndIdx，用图表示是这个样子：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff3.jpg" alt="diff3"></p>
<ol>
<li><p>oldStartVnode, newStartVnode相同的情况：<br>执行patchVnode方法<br>oldStartVnode与newStartVnode都前进一格<br>完成这些操作就变成了下图这样：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff4.jpg" alt="diff4"></p>
</li>
<li><p>oldEndVnode, newEndVnode相同的情况：<br>执行patchVnode方法<br>oldEndVnode与newEndVnode都后退一格<br>完成这些操作就变成了下图这样：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff5.jpg" alt="diff5"></p>
</li>
<li><p>oldStartVnode, newEndVnode相同的情况：<br>这种情况下意味着当前 <code>旧Lists的StartIdx位置的元素</code>，在<code>新Lists中</code>被挪到了<code>EndIdx位置</code>（Vnode moved right）<br>在执行完patchVnode方法之后，在<code>真实DOM中</code>我们还要将 <code>oldStart 插到 oldEnd之后</code><br>oldStartVnode前进一格<br>newEndVnode后退一格<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff6.jpg" alt="diff6"></p>
</li>
<li><p>oldEndVnode, newStartVnode相同的情况：<br>这种情况下意味着当前 <code>旧Lists的EndIdx位置的元素</code>，在<code>新Lists中</code>被挪到了<code>StartIdx位置</code>（Vnode moved left）<br>在执行完patchVnode方法之后，在<code>真实DOM中</code>我们还要将 <code>oldEnd 插到 oldStart之前</code><br>newStartVnode前进一格<br>oldEndVnode后退一格<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff7.jpg" alt="diff7"></p>
</li>
</ol>
<p><code>ELSE！</code>如果上面四种情况都比对不中，也是就出现下图的情况：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff8.jpg" alt="diff8"></p>
<p>则会执行 <code>createKeyToOldIdx</code> 方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  let i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    if (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回一个 哈希表(obj)，各项 键为 vnode 的 key属性，值为 vnode 的下标<br>哈希表中的内容包含处于 oldStart 至 oldEnd 的 vnode，大概长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  vnodeKeyA: 1,</span><br><span class="line">  vnodeKeyC: 2,</span><br><span class="line">  vnodeKeyD: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着从哈希表中寻找是否有与newStartVnode<code>一致key</code>的oldVNode节点<br>接着看下面第5条：</p>
<ol start="5">
<li>我们在哈希表中找到了oldVnode节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnodeToMove = oldCh[idxInOld] // 这个就是我们找到的`旧的vnode`</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里还分了两种情况</p>
<ul>
<li>一、<code>光比较key，肯定不足以判断两个vnode相同</code>，我着这里再调用sameVnode(vnodeToMove, newStartVnode)方法来对比<br>如果相同：<br>执行patchVnode<br>oldCh[idxInOld]赋undefined // oldCh[idxInOld] = undefined ，我们已经用vnodeToMove保存了一份了<br>然后在<code>真实DOM中</code>，<code>把vnodeToMove插入到oldStart之前</code><br>newStartVnode都前进一格<br>放代码把：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vnodeToMove = oldCh[idxInOld]</span><br><span class="line">if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">  oldCh[idxInOld] = undefined</span><br><span class="line">  canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">&#125; else &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff9.jpg" alt="diff9"></p>
<ul>
<li>二、key相同，但sameVnode比较出来不相同<br>这种情况下则调用createElm创建一个新的元素插到oldStart前面<br>newStartVnode都前进一格<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff10.jpg" alt="diff10"></li>
</ul>
<ol start="6">
<li><p>我们在哈希表中！！！没有找到oldVnode！！！节点：<br>这种情况下和 5 中的第二种情况一模一样<br>调用createElm创建一个新的元素插到oldStart前面<br>newStartVnode都前进一格</p>
</li>
<li><p>到了这一步，while已经循环完毕了，接下来要处理新旧List长短不相同的情况</p>
</li>
</ol>
<ul>
<li>一、oldStartIdx &gt; oldEndIdx，oldStart 超过了oldEnd，说明<code>新List比旧Lists长</code><br>我们需要把没遍历到的vnode选出来，用refElm存一下，然后啊，使用addVnodes批量调用创建（createElm）把这些vnode加到真实DOM中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff11.jpg" alt="diff11"></p>
<ul>
<li>二、newStartIdx &gt; newEndIdx，说明<code>旧List比新Lists长</code><br>我们调用removeVnodes方法，参数包含oldStartIdx 与 oldEndIdx，把多余的删掉<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if&#123;</span><br><span class="line">  // code...</span><br><span class="line">&#125;</span><br><span class="line">else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-04/diff12.jpg" alt="diff12"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="https://blog.csdn.net/u013929284/article/details/56483035" target="_blank" rel="noopener">高频dom操作和页面性能优化探索</a><br><a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">React’s diff algorithm</a><br><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">https://github.com/answershuto/learnVue</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-06</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Vue/" title="Vue">Vue </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/05/06/学习Vue源码9-浅谈Vue中的Diff算法/,DK'S BLOG,学习Vue源码9-浅谈Vue中的Diff算法,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/05/07/撸一个简易富文本编辑器/" title="撸一个简易富文本编辑器">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/05/06/学习Vue源码8-vm-render与vm-update/" title="学习Vue源码8-vm._render与vm._update">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>