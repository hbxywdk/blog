<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="hbxywdk,hbxywdk@gmail.com"><title>使用Canvas压缩Jpg图片丢失Exif信息问题 · DK'S BLOG</title><meta name="description" content="遇到的问题最近开发遇到一个问题，后台想要在用户上传的图片中获取到 Exif 信息，APP 确认 Exif 信息有传，最后排查到 Exif 丢失的原因是 H5 对 APP 传回的照片进行了压缩。H5 使用的压缩库是 lrz，将 H5 压缩关闭后，后台就可以获取到 Exif 信息了。
APP 传给 H5"><meta name="keywords" content="blog,FE,HTML,CSS,Javascript,Vue,Nuxt"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">DK'S BLOG</a></h3><div class="description"><p>Judge not from appearances.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/DKWang8"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/3136805851"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/hbxywdk"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/de.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>使用Canvas压缩Jpg图片丢失Exif信息问题</a></h3></div><div class="post-content"><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>最近开发遇到一个问题，后台想要在用户上传的图片中获取到 Exif 信息，APP 确认 Exif 信息有传，最后排查到 Exif 丢失的原因是 H5 对 APP 传回的照片进行了压缩。H5 使用的压缩库是 <a href="https://github.com/think2011/localResizeIMG" target="_blank" rel="noopener">lrz</a>，将 H5 压缩关闭后，后台就可以获取到 Exif 信息了。</p>
<p>APP 传给 H5 的图片内容是 base64 化的 jpg 图，前端压缩后，传压缩后的 base64 图片给后台。</p>
<p>APP 传给 H5 的图片比较大，本着节省用户流量与缩短上传时间的考虑，必须在前端压缩再传给后台。</p>
<h4 id="问题产生的原因"><a href="#问题产生的原因" class="headerlink" title="问题产生的原因"></a>问题产生的原因</h4><p>查看 lrz 的源码，发现它是使用 canvas 将原图绘制到其上，再将 canvas 的内容转为 base64 格式的图片。</p>
<p>我又看了其他一款纯前端图片压缩库后，发现它俩都是使用 canvas 来进行图片压缩（貌似纯前端图片压缩方法基本就canvas），使用 canvas 压缩图片虽然可以达到大比例压缩的目的，但是最后从 canvas 中导出的图片必然会将原图中保存的 Exif 等信息内容一并丢掉。</p>
<h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><h5 id="Base64-出现的原因"><a href="#Base64-出现的原因" class="headerlink" title="Base64 出现的原因"></a>Base64 出现的原因</h5><p>有些网络传输方式并不支持所有的字节，例如传统的邮件只支持可见字符的传输，像ASCII码的控制字符就不能传输。图片二进制流的每个字节不可能全部是可见字符，所以也不能传输。<br>那么就需要在不改变传统协议的情况下，做一种扩展来支持二进制文件传输，这就是 Base64 出现的原因，它可将不可打印的字符用可打印字符来表示，以实现传输的目的。<br>Base64 从名称就可以看出，它是一种基于64个可打印字符来表示二进制数据的方法。</p>
<h5 id="Base64-原理"><a href="#Base64-原理" class="headerlink" title="Base64 原理"></a>Base64 原理</h5><p><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-08/base64index.png" alt="Base64索引表"></p>
<p>Base64只有64个字符，6的bit即可表示64个字符(2的6次方为64)，正常的字符是使用8bit表示。我们看下面这张图：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-08/base64-1.jpg" alt="Base64原理图"><br><code>Hello!</code> 这个字符串的二进制值如第三行所示，正常字符使用 8bit 表示，转换 base64 则使用 6bit 表示，以 6个一截断，再对照 base64 索引表可以很容易的得出其 base64 编码结果为 SGVsbG8h。<br>Tips: 转换后长度/转换前长度 为 4:3。</p>
<p>如果原始字符串长度不能被3整除，就需要用0来补充，如下图：<br><img src="https://raw.githubusercontent.com/hbxywdk/hexo-blog/master/assets/2019-08/base64-2.jpg" alt="Base64补位"></p>
<p>Hello!! Base64编码的结果为 SGVsbG8hIQAA，由于补充的两个<code>AA</code>不应该携带信息，这里以<br><code>AA</code>表示会造成数据错误，所以会以 <code>=</code>替换补位的<code>AA</code>，故最终的结果为 <code>SGVsbG8hIQ==</code>。</p>
<p>这里只是简单讲一下 Base64，更多详情可看这篇文章：<a href="https://www.cnblogs.com/peterYong/p/10959964.html" target="_blank" rel="noopener">https://www.cnblogs.com/peterYong/p/10959964.html</a></p>
<h4 id="什么是-Exif？"><a href="#什么是-Exif？" class="headerlink" title="什么是 Exif？"></a>什么是 Exif？</h4><p>可交换图像文件格式 Exif（Exchangeable image file format），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据，它储存在相机设备拍摄的图片的二进制文件中。<br>Exif信息以0xFFE1作为开头标记，后两个字节表示Exif信息的长度。所以Exif信息最大为64 kb，而内部采用TIFF格式。</p>
<p>JPEG文件的内容都以二进制值 <code>0xFFD8</code>（Start of image 简称 SOI）开始, 以二进制值<code>0xFFD9</code>（End of image 简称 EOI）结束。 在JPEG的数据 中有好几种类似于二进制 0xFFXX 的数据, 它们都统称作 “标记”, 并且它们代表了一段JPEG的 信息数据。</p>
<p>SOI 与 EOI 两个特殊的标记的后不跟数据, 而其他的标记会在其后附带数据。</p>
<p>标记的基本结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xFF+标记号(1个字节)+数据大小描述符(2个字节)+数据内容(n个字节)</span><br></pre></td></tr></table></figure></p>
<p>标记的种类又很多种，0xFFE0~0xFFEF之间的标记被叫做 <code>应用标记</code>，存放 Exif 信息的标记以 <code>APP1(0xFFE1)</code> 开头，</p>
<h4 id="问题的解决方案"><a href="#问题的解决方案" class="headerlink" title="问题的解决方案"></a>问题的解决方案</h4><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><p>原压缩图片不变，通过 <a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">Exif.js</a> 获取到原图  Exif 信息后通过接口传给后台，这种方案没什么意思，接着看方案二。</p>
<h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>保存原图  Exif 信息，待图片压缩完成后，将原图  Exif 信息拼接到压缩图上。</p>
<p>由于传输的图片都是 base64 格式，这里提供一个网址可以查看 base64 图片的 exif 信息：<a href="http://code.ciaoca.com/javascript/exif-js/demo/base64" target="_blank" rel="noopener">http://code.ciaoca.com/javascript/exif-js/demo/base64</a></p>
<p>在方案一中，我提到了 Exif.js，不过遗憾的是它提供的只有读 Exif 信息的方法，没有写 Exif 信息的方法，所以想要实现 Exif 信息拼接就得手撸了，不过好在我找到了一篇相关文章：<a href="http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#more，里面的代码已经实现了这个功能，所以我准备直接修改" target="_blank" rel="noopener">http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#more，里面的代码已经实现了这个功能，所以我准备直接修改</a> lrz 源码，使其可以额外输出一个带有 Exif 信息的 base64 压缩图。</p>
<p>拼接 Exif 的核心代码：</p>
<p>压缩原始 base64 图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 原始 base64 图片，由于太长，这里省略展示</span><br><span class="line">let orignBase64 = &apos;data:image/jpeg;base64,/9j/4QIMRXhpZgAATU0AKgAAAAgACQEAAAQAA 省略......&apos;；;</span><br><span class="line">let minBase64 = null; // 压缩图</span><br><span class="line">let exif = null; // 存 Exif 信息</span><br><span class="line"></span><br><span class="line">// 压缩使用的是 lrz 可自行在 github 上搜索</span><br><span class="line">lrz(orignBase64, &#123; width: 800&#125;)</span><br><span class="line">.then(function (rst) &#123;</span><br><span class="line">    minBase64 = rst.base64;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (err) &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>取得 Exif 信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 工具函数 将 base64 转 ArrayBuffer</span><br><span class="line">function base64ToArrayBuffer(base64, contentType) &#123;</span><br><span class="line">    contentType = contentType || base64.match(/^data\:([^\;]+)\;base64,/mi)[1] || &apos;&apos;; // e.g. &apos;data:image/jpeg;base64,...&apos; =&gt; &apos;image/jpeg&apos;</span><br><span class="line">    base64 = base64.replace(/^data\:([^\;]+)\;base64,/gmi, &apos;&apos;);</span><br><span class="line">    // btoa是binary to ascii，将binary的数据用ascii码表示，即Base64的编码过程</span><br><span class="line">    // atob则是ascii to binary，用于将ascii码解析成binary数据</span><br><span class="line">    var binary = atob(base64);</span><br><span class="line">    // console.log(binary)</span><br><span class="line">    var len = binary.length;</span><br><span class="line">    var buffer = new ArrayBuffer(len);</span><br><span class="line">    var view = new Uint8Array(buffer);</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        view[i] = binary.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line">// 将原始 base64 转换为 arrayBuffer</span><br><span class="line">let orignBuffer = base64ToArrayBuffer(orignBase64);</span><br><span class="line">// 调用 getSegments 获取 0xFFE0~0xFFEF 开头的应用标记片段</span><br><span class="line">getSegments(orignBuffer);</span><br></pre></td></tr></table></figure></p>
<p>这里给出标记的大致结构，下面的代码会用到：<br>标记开头 | 标记类型 | 标记大小 | 标记内容</p>
<ul>
<li>| - | - | -<br>0xff | 标记类型(1字节) | 数据大小(2字节) | 数据内容(n字节)</li>
</ul>
<p>关于标记类型，可以在 <a href="https://github.com/exif-js/exif-js/blob/master/exif.js" target="_blank" rel="noopener">Exif.js</a> 的源码中找到，比如<code>图片宽度 ImageWidth 对应的标记是 0x0100</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 获取 0xFFE0~0xFFEF 开头的应用标记片段</span><br><span class="line">function getSegments(arrayBuffer) &#123;</span><br><span class="line">    var head = 0, segments = [];</span><br><span class="line">    var length, endPoint, seg;</span><br><span class="line">    var arr = [].slice.call(new Uint8Array(arrayBuffer), 0);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        // SOS(Start of Scan, 由 0xff 0xda 开头)</span><br><span class="line">        // 遍历到 SOS 表示已经遍历完所有标记，再往下就是图像数据流了，直接 break</span><br><span class="line">        if (arr[head] === 0xff &amp;&amp; arr[head + 1] === 0xda) &#123; break;&#125;</span><br><span class="line"></span><br><span class="line">        // SOI(Start of Image)是 JPG 文件的开头内容，由 0xff 0xd8 开头</span><br><span class="line">        if (arr[head] === 0xff &amp;&amp; arr[head + 1] === 0xd8) &#123;</span><br><span class="line">            head += 2;</span><br><span class="line">        &#125; </span><br><span class="line">        // 找出每个标记片段</span><br><span class="line">        else &#123;</span><br><span class="line">            // 每个标记开头后跟着的两个字节记录了该标记所记录内容的长度</span><br><span class="line">            length = arr[head + 2] * 256 + arr[head + 3]; // 内容长度</span><br><span class="line">            endPoint = head + length + 2; // 内容结束位置</span><br><span class="line">            // 从0xff开头，到标记数据内容结束全部截出来</span><br><span class="line">            seg = arr.slice(head, endPoint);</span><br><span class="line">            head = endPoint;</span><br><span class="line">            // push整个标记信息</span><br><span class="line">            segments.push(seg);</span><br><span class="line">        &#125;</span><br><span class="line">        if (head &gt; arr.length) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // console.warn(&apos;分割片段&apos;, segments);</span><br><span class="line">    getEXIF(segments)</span><br><span class="line">&#125;</span><br><span class="line">// 从标记片段筛选 &amp; 取出 exif 信息</span><br><span class="line">function getEXIF(segments) &#123;</span><br><span class="line">    if (!segments.length) &#123; return []; &#125;</span><br><span class="line">    var seg = [];</span><br><span class="line">    for (var x = 0; x &lt; segments.length; x++) &#123;</span><br><span class="line">        var s = segments[x];</span><br><span class="line">        // 0xff 0xe1开头的才是 exif数据(即app1)</span><br><span class="line">        if (s[0] === 0xff &amp;&amp; s[1] === 0xe1) &#123; // app1 exif 0xff 0xe1</span><br><span class="line">            seg = seg.concat(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exif = seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拼接 Exif 到压缩后的 base64 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 插入 Exif 信息</span><br><span class="line">function insertEXIF(resizedImg, exifArr) &#123;</span><br><span class="line">    var arr = [].slice.call(new Uint8Array(resizedImg), 0);</span><br><span class="line">    //不是标准的JPEG文件</span><br><span class="line">    if (arr[2] !== 0xff || arr[3] !== 0xe0) &#123;</span><br><span class="line">        return resizedImg; </span><br><span class="line">    &#125;</span><br><span class="line">    var app0_length = arr[4] * 256 + arr[5]; //两个字节</span><br><span class="line"></span><br><span class="line">    // 拼接文件 SOI + EXIF + 去除APP0的图像信息</span><br><span class="line">    var newImg = [0xff, 0xd8].concat(exifArr, arr.slice(4 + app0_length)); </span><br><span class="line">    return new Uint8Array(newImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let minBuffer = base64ToArrayBuffer(minBase64);</span><br><span class="line">let newImg = insertEXIF(minBuffer, exif);</span><br><span class="line">console.log(&apos;最终输出图片&apos;, newImg)</span><br></pre></td></tr></table></figure></p>
<p>把新生成的图片复制到 <a href="http://code.ciaoca.com/javascript/exif-js/demo/base64" target="_blank" rel="noopener">http://code.ciaoca.com/javascript/exif-js/demo/base64</a> 可以看到 Exif 信息已经成功添加。</p>
<h4 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h4><p>上面有很多二进制文件操作，这里简单补充一些相关知识。</p>
<h5 id="二进制数组产生的原因"><a href="#二进制数组产生的原因" class="headerlink" title="二进制数组产生的原因"></a>二进制数组产生的原因</h5><p>二进制数组产生的原因与WebGL项目有关，为的满足 JavaScript 与显卡之间大量的、实时的数据交换，这些通信的数据都得是二进制的。</p>
<h5 id="ArrayBuffer-对象"><a href="#ArrayBuffer-对象" class="headerlink" title="ArrayBuffer 对象"></a>ArrayBuffer 对象</h5><p>ArrayBuffer 是内存中的一段二进制数据，无法直接操作，可使用 <code>视图（TypedArray、DataView）</code>提供的数组方法，操作内存，其作用是以指定格式解读二进制数据。</p>
<h5 id="TypedArray-对象"><a href="#TypedArray-对象" class="headerlink" title="TypedArray 对象"></a>TypedArray 对象</h5><p>用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Int8Array：8位有符号整数，长度1个字节。</span><br><span class="line">Uint8Array：8位无符号整数，长度1个字节。</span><br><span class="line">Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</span><br><span class="line">Int16Array：16位有符号整数，长度2个字节。</span><br><span class="line">Uint16Array：16位无符号整数，长度2个字节。</span><br><span class="line">Int32Array：32位有符号整数，长度4个字节。</span><br><span class="line">Uint32Array：32位无符号整数，长度4个字节。</span><br><span class="line">Float32Array：32位浮点数，长度4个字节。</span><br><span class="line">Float64Array：64位浮点数，长度8个字节。</span><br></pre></td></tr></table></figure></p>
<p>TypedArray 指定数据格式读取整个 ArrayBuffer。</p>
<h5 id="DataView-对象"><a href="#DataView-对象" class="headerlink" title="DataView 对象"></a>DataView 对象</h5><p>用来生成内存的视图，可以自定义格式和字节序，同样支持9种数据类型，相较于 TypedArray 更加灵活，比如可以以不同的格式读取同一个 ArrayBuffer 上不同位置的数据。</p>
<h5 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h5><p>Blob(binary large object)，二进制文件大对象，是存储二进制文件的“容器”。Blob构造函数接受两个参数，第一个参数是一个包含实际数据的数组，第二个参数是数据的MIME类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Blob([data], &#123;type: &quot;application/octet-binary&quot;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>与 ArrayBuffer 的区别：</p>
<ul>
<li>它俩都能存二进制数据，但 Blob 储存量更大。</li>
<li>Blob 可以设置数据的 MIME 类型。</li>
<li>ArrayBuffer 表示原始的二进制数据，需要通过视图进行操作。</li>
<li>Blob对象表示一个不可变、原始数据的类文件对象。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote>
<p><a href="https://www.cnblogs.com/peterYong/p/10959964.html" target="_blank" rel="noopener">https://www.cnblogs.com/peterYong/p/10959964.html</a><br><a href="https://blog.csdn.net/yyjsword/article/details/28876739" target="_blank" rel="noopener">https://blog.csdn.net/yyjsword/article/details/28876739</a><br><a href="http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#more" target="_blank" rel="noopener">http://icaife.github.io/2015/05/19/js-compress-JPEG-width-exif/#more</a><br><a href="http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc2" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/stdlib/arraybuffer.html#toc2</a><br><a href="https://www.jianshu.com/p/54d878aa0237" target="_blank" rel="noopener">https://www.jianshu.com/p/54d878aa0237</a></p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-08-16</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Js/" title="Js">Js </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/08/16/canvas压缩jpg丢失exif/,DK'S BLOG,使用Canvas压缩Jpg图片丢失Exif信息问题,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/09/16/Vuex源码分析3/" title="Vuex源码分析3">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/08/01/Vuex源码分析2/" title="Vuex源码分析2">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>